"""
Custom scalars
"""
scalar DateTime
scalar JSON
scalar JSONObject

# ------------------------------------------------------------------------------
# Enums
# ------------------------------------------------------------------------------

enum UsersSortBy {
  NAME
  CREATED_AT
  ROLE
  VERIFIED_AT
}

enum SortDir {
  ASC
  DESC
}

enum EventsSortBy {
  START_AT
  CREATED_AT
  UPDATED_AT
  MEMBERS_COUNT
}

type PageInfo {
  total: Int!
  limit: Int!
  offset: Int!
  hasNext: Boolean!
  hasPrev: Boolean!
}

type CursorPageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type UsersResult {
  items: [User!]!
  pageInfo: PageInfo!
}

type EventsResult {
  items: [Event!]!
  pageInfo: PageInfo!
}

type NotificationsResult {
  items: [Notification!]!
  pageInfo: PageInfo!
}

type UserEventsResult {
  items: [Event!]!
  total: Int!
}

type UserReviewsResult {
  items: [Review!]!
  total: Int!
}

"Event check-in log entry for audit trail"
type EventCheckinLog {
  id: ID!
  eventId: ID!
  memberId: ID # EventMember.id - Nullable for event-level config changes
  actorId: ID # User.id who performed action
  action: CheckinAction!
  method: CheckinMethod
  source: CheckinSource!
  result: CheckinResult_Status! # Use different name to avoid conflict with mutation result type
  reason: String
  comment: String
  showCommentToUser: Boolean!
  metadata: JSON

  createdAt: DateTime!

  # Relations
  actor: User
}

"Status for log entry result"
enum CheckinResult_Status {
  SUCCESS
  DENIED
  NOOP
}

type EventCheckinLogsResult {
  items: [EventCheckinLog!]!
  pageInfo: PageInfo!
}

input UsersSort {
  by: UsersSortBy!
  dir: SortDir!
}

"Visibility of an event"
enum Visibility {
  PUBLIC
  HIDDEN
}

enum AddressVisibility {
  PUBLIC
  AFTER_JOIN
  HIDDEN
}

enum MembersVisibility {
  PUBLIC
  AFTER_JOIN
  HIDDEN
}

"Join mode - how users can join an event"
enum JoinMode {
  OPEN
  REQUEST
  INVITE_ONLY
}

"Meeting mode / capacity grouping"
enum Mode {
  ONE_TO_ONE
  GROUP
  CUSTOM
}

"How the meeting happens"
enum MeetingKind {
  ONSITE
  ONLINE
  HYBRID
}

"User role (global)"
enum Role {
  ADMIN
  MODERATOR
  USER
}

"Skill / difficulty level (enum array in DB)"
enum Level {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

"Media asset purpose"
enum MediaPurpose {
  USER_AVATAR
  USER_COVER
  EVENT_COVER
  GALLERY_IMAGE
}

"Per-event role"
enum EventMemberRole {
  OWNER
  MODERATOR
  PARTICIPANT
}

"Membership lifecycle status"
enum EventMemberStatus {
  JOINED
  PENDING
  INVITED
  REJECTED
  BANNED
  LEFT
  KICKED
  CANCELLED
  WAITLIST
}

"Check-in method - how user can check in to an event"
enum CheckinMethod {
  SELF_MANUAL # User clicks 'I am here' button
  MODERATOR_PANEL # Organizer checks in from management panel
  EVENT_QR # User scans event's shared QR code
  USER_QR # Organizer scans user's individual QR code
}

"Check-in action type for audit log"
enum CheckinAction {
  CHECK_IN # User/moderator performed check-in
  UNCHECK # Check-in was removed
  REJECT # Check-in was rejected by organizer
  BLOCK_ALL # All check-in methods blocked for user
  UNBLOCK_ALL # All check-in methods unblocked
  BLOCK_METHOD # Specific method blocked
  UNBLOCK_METHOD # Specific method unblocked
  QR_TOKEN_ROTATED # QR token was regenerated
  METHODS_CHANGED # Event check-in configuration changed
  ATTEMPT_DENIED # Check-in attempt was denied
}

"Source of check-in action"
enum CheckinSource {
  USER # Action initiated by the user themselves
  MODERATOR # Action initiated by event owner/moderator
  SYSTEM # Automatic action (e.g., status change invalidation)
}

"Result of check-in action"
enum CheckinResult {
  SUCCESS # Action completed successfully
  DENIED # Action was denied (permission/validation issue)
  NOOP # No operation (already in desired state)
}

"Member event type for audit log"
enum MemberEvent {
  JOIN
  REQUEST
  APPROVE
  REJECT
  LEAVE
  KICK
  BAN
  UNBAN
  INVITE
  ACCEPT_INVITE
  CANCEL_REQUEST
  WAITLIST
  WAITLIST_LEAVE
  WAITLIST_PROMOTE
}

"Join form question type"
enum JoinQuestionType {
  TEXT
  SINGLE_CHOICE
  MULTI_CHOICE
}

enum FeedbackQuestionType {
  TEXT
  SINGLE_CHOICE
  MULTI_CHOICE
}

"High-level notification category/kind"
enum NotificationKind {
  # Event lifecycle
  EVENT_CREATED
  EVENT_UPDATED
  EVENT_CANCELED
  EVENT_DELETED

  # Membership
  EVENT_INVITE
  EVENT_INVITE_ACCEPTED
  EVENT_MEMBERSHIP_APPROVED
  EVENT_MEMBERSHIP_REJECTED
  EVENT_MEMBER_KICKED
  EVENT_MEMBER_ROLE_CHANGED
  JOIN_REQUEST
  BANNED
  UNBANNED

  # Waitlist
  WAITLIST_JOINED
  WAITLIST_PROMOTED

  # Reviews & Feedback
  EVENT_REVIEW_RECEIVED
  EVENT_FEEDBACK_RECEIVED
  EVENT_FEEDBACK_REQUEST
  REVIEW_HIDDEN

  # Comments
  EVENT_COMMENT_ADDED
  COMMENT_REPLY
  COMMENT_HIDDEN

  # Messages
  NEW_MESSAGE
  NEW_COMMENT
  NEW_REVIEW
  EVENT_CHAT_MESSAGE

  # Check-in
  CHECKIN_CONFIRMED # Check-in successful
  CHECKIN_REJECTED # Check-in was rejected by organizer
  CHECKIN_BLOCKED # Check-in was blocked
  CHECKIN_UNBLOCKED # Check-in was unblocked
  # Reminders & System
  EVENT_REMINDER
  SYSTEM
}

"Polymorphic target for notifications (deep-link)"
enum NotificationEntity {
  EVENT
  MESSAGE
  PAYMENT
  INVOICE
  USER
  REVIEW
  SYSTEM
  OTHER
}

"Report entity type"
enum ReportEntity {
  EVENT
  COMMENT
  REVIEW
  USER
  MESSAGE
  CHAT
}

"Subscription plan tiers"
enum SubscriptionPlan {
  PLUS
  PRO
}

"User plan source"
enum UserPlanSource {
  SUBSCRIPTION
  ONE_OFF
}

"Billing period"
enum BillingPeriod {
  MONTHLY
  YEARLY
}

"Subscription status"
enum SubscriptionStatus {
  INCOMPLETE
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  PAUSED
}

"Event/Event plan tiers"
enum EventPlan {
  FREE
  PLUS
  PRO
}

"Sponsorship status"
enum SponsorshipStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELED
}

"User effective plan (computed from active periods)"
enum UserEffectivePlan {
  FREE
  PLUS
  PRO
}

"Event time-based status (computed on read)"
enum EventStatus {
  ANY
  UPCOMING
  ONGOING
  PAST
  CANCELED
  DELETED
}

"Publication status of an event (DRAFT -> PUBLISHED or SCHEDULED -> PUBLISHED)"
enum PublicationStatus {
  DRAFT
  PUBLISHED
  SCHEDULED
}

"Event lifecycle status filter for myEvents query"
enum EventLifecycleStatus {
  UPCOMING
  ONGOING
  FINISHED
  CANCELED
  DELETED
}

"Why joining is locked (computed)"
enum JoinLockReason {
  FULL
  INVITE_ONLY
  NOT_OPEN_YET
  CUTOFF
  NO_LATE_JOIN
  LATE_CUTOFF
  MANUAL
  ENDED
  CANCELED
  DELETED
  OTHER
}

# ------------------------------------------------------------------------------
# Types
# ------------------------------------------------------------------------------

"Session"
type SessionUser {
  id: String!
  name: String!
  email: String!
  role: Role!
  avatarKey: String
  avatarBlurhash: String
  verifiedAt: DateTime
  profile: UserProfile

  # Billing & Subscriptions
  effectivePlan: UserEffectivePlan!
}

"Presigned upload URL response"
type PresignedUpload {
  uploadUrl: String!
  uploadKey: String!
  provider: String!
}

type ConfirmMediaUploadPayload {
  success: Boolean!
  mediaKey: String!
  mediaAssetId: ID!
}

"User"
type User {
  id: ID!
  email: String!
  name: String!
  avatarKey: String
  avatarBlurhash: String
  role: Role!
  verifiedAt: DateTime
  suspendedAt: DateTime
  suspensionReason: String
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSeenAt: DateTime

  # Profile / Preferences
  locale: String!
  timezone: String!
  acceptedTermsAt: DateTime
  acceptedMarketingAt: DateTime

  # Extended Profile (1:1 relations)
  profile: UserProfile
  privacy: UserPrivacy
  stats: UserStats

  # Collections
  socialLinks: [UserSocialLink!]!
  categoryLevels: [UserCategoryLevel!]!
  availability: [UserAvailability!]!
  badges: [UserBadge!]!

  # Billing & Subscriptions
  effectivePlan: UserEffectivePlan!
  planEndsAt: DateTime
  activeSubscription: UserSubscription
  activePlanPeriods: [UserPlanPeriod!]!
}

type UserProfile {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  displayName: String
  bioShort: String
  bioLong: String

  city: String
  country: String
  homeLat: Float
  homeLng: Float

  coverKey: String
  coverBlurhash: String

  speaks: [String!]!
  interests: [String!]!
  preferredMode: Mode
  preferredMaxDistanceKm: Float
}

type UserPrivacy {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  dmPolicy: String!
  showLastSeen: String!
  showLocation: String!
  showEvents: String!
  showReviews: String!
  showStats: String!

  defaultAddressVisibility: AddressVisibility!
  defaultMembersVisibility: MembersVisibility!
}

type UserStats {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  eventsCreated: Int!
  eventsJoined: Int!
  reviewsCount: Int!

  hostRatingAvg: Float
  attendeeRatingAvg: Float

  lastActiveAt: DateTime
}

type UserSocialLink {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  provider: String!
  url: String!
  verified: Boolean!
}

type UserCategoryLevel {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  categoryId: ID!
  category: Category!
  level: Level!
  notes: String
}

type UserAvailability {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  weekday: Int!
  startMin: Int!
  endMin: Int!
  tzSnap: String
}

type UserBadge {
  id: ID!
  userId: ID!
  createdAt: DateTime!

  slug: String!
  data: JSON
  earnedAt: DateTime!
}

# ==============================================================================
# Billing Types
# ==============================================================================

"User subscription (auto-renewable)"
type UserSubscription {
  id: ID!
  userId: ID!
  user: User!

  plan: SubscriptionPlan!
  billingPeriod: BillingPeriod!
  status: SubscriptionStatus!

  stripeCustomerId: String!
  stripeSubscriptionId: String
  stripePriceId: String

  currentPeriodStart: DateTime
  currentPeriodEnd: DateTime
  trialEndsAt: DateTime

  cancelAtPeriodEnd: Boolean!
  canceledAt: DateTime

  createdAt: DateTime!
  updatedAt: DateTime!
}

"User plan period (subscription or one-off)"
type UserPlanPeriod {
  id: ID!
  userId: ID!
  user: User!

  plan: SubscriptionPlan!
  source: UserPlanSource!
  billingPeriod: BillingPeriod!

  amount: Float!
  currency: String!

  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePaymentEventId: String
  stripeCheckoutSessionId: String

  startsAt: DateTime!
  endsAt: DateTime!

  createdAt: DateTime!
}

"Event/Event sponsorship"
type EventSponsorship {
  id: ID!
  eventId: ID!
  sponsorId: ID!
  event: Event!
  sponsor: User!

  plan: EventPlan!
  status: SponsorshipStatus!

  startsAt: DateTime
  endsAt: DateTime

  boostsTotal: Int!
  boostsUsed: Int!
  localPushesTotal: Int!
  localPushesUsed: Int!

  stripePaymentEventId: String
  stripeCheckoutSessionId: String

  createdAt: DateTime!
  updatedAt: DateTime!
}

"Individual event sponsorship transaction (purchase, upgrade, reload)"
type EventSponsorshipPeriod {
  id: ID!
  eventId: ID!
  sponsorId: ID!

  plan: EventPlan!
  actionType: String!

  boostsAdded: Int!
  localPushesAdded: Int!

  amount: Float!
  currency: String!

  stripeCustomerId: String
  stripePaymentEventId: String
  stripeCheckoutSessionId: String

  createdAt: DateTime!

  event: Event!
  sponsor: User!
}

"Checkout session response"
type CheckoutSession {
  checkoutUrl: String!
  sessionId: String!
}

"Event sponsorship checkout response"
type EventSponsorshipCheckout {
  checkoutUrl: String!
  sessionId: String!
  sponsorshipId: ID!
}

"User plan info (computed)"
type UserPlanInfo {
  plan: UserEffectivePlan!
  planEndsAt: DateTime
  source: UserPlanSource
  billingPeriod: BillingPeriod
}

"Category with translated names in JSON, e.g. { pl,de,en }"
type Category {
  id: ID!
  slug: String!
  names: JSONObject!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Tag used for search/filtering"
type Tag {
  id: ID!
  label: String!
  slug: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Event membership (user-in-event)"
type EventMember {
  id: ID!
  eventId: ID!
  userId: ID!
  role: EventMemberRole!
  status: EventMemberStatus!

  addedBy: User
  joinedAt: DateTime
  leftAt: DateTime
  note: String
  rejectReason: String

  # Check-in fields
  isCheckedIn: Boolean!
  checkinMethods: [CheckinMethod!]!
  lastCheckinAt: DateTime
  memberCheckinToken: String # Unique token for USER_QR method
  # Check-in blocking
  checkinBlockedAll: Boolean!
  checkinBlockedMethods: [CheckinMethod!]!

  # Check-in rejection tracking
  lastCheckinRejectionReason: String
  lastCheckinRejectedAt: DateTime
  lastCheckinRejectedBy: User

  user: User!
  event: Event!
  joinAnswers: [EventJoinAnswer!]!
}

"Join form question for REQUEST mode"
type EventJoinQuestion {
  id: ID!
  eventId: ID!
  order: Int!
  type: JoinQuestionType!
  label: String!
  helpText: String
  required: Boolean!
  options: JSON
  maxLength: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Join form answer from a user"
type EventJoinAnswer {
  id: ID!
  eventId: ID!
  userId: ID!
  questionId: ID!
  answer: JSON!
  createdAt: DateTime!
  updatedAt: DateTime!
  question: EventJoinQuestion!
  user: User!
}

# ------------------------------------------------------------------------------
# Feedback System
# ------------------------------------------------------------------------------

"Feedback question for post-event feedback"
type EventFeedbackQuestion {
  id: ID!
  eventId: ID!
  order: Int!
  type: FeedbackQuestionType!
  label: String!
  helpText: String
  required: Boolean!
  options: JSON
  maxLength: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Feedback answer from a user (post-event)"
type EventFeedbackAnswer {
  id: ID!
  eventId: ID!
  userId: ID!
  questionId: ID!
  answer: JSON!
  createdAt: DateTime!
  updatedAt: DateTime!

  # Relations
  user: User!
  question: EventFeedbackQuestion!
}

"Join request with answers for host review"
type EventJoinRequest {
  member: EventMember!
  answers: [EventJoinAnswer!]!
}

"Result type for paginated join requests"
type EventJoinRequestsResult {
  items: [EventJoinRequest!]!
  pageInfo: PageInfo!
}

# Feedback Results
"Aggregated feedback statistics for a question"
type FeedbackQuestionStats {
  question: EventFeedbackQuestion!
  totalAnswers: Int!
  # For CHOICE types - distribution of answers
  choiceDistribution: [ChoiceDistribution!]
  # For TEXT type - list of text answers
  textAnswers: [TextAnswerWithUser!]
}

type ChoiceDistribution {
  option: String!
  count: Int!
  percentage: Float!
}

type TextAnswerWithUser {
  answer: String!
  userId: ID!
  userName: String!
  createdAt: DateTime!
}

"Complete feedback results for an event"
type EventFeedbackResults {
  eventId: ID!
  questionStats: [FeedbackQuestionStats!]!
  totalRespondents: Int!
}

"Combined result for review submission"
type SubmitReviewAndFeedbackResult {
  review: Review!
  feedbackAnswers: [EventFeedbackAnswer!]!
}

type SendFeedbackRequestsResult {
  success: Boolean!
  sentCount: Int!
  skippedCount: Int!
  message: String
}

"Event"
type Event {
  id: ID!
  title: String!
  description: String
  notes: String

  categories: [Category!]!
  tags: [Tag!]!

  visibility: Visibility!
  joinMode: JoinMode!
  mode: Mode!
  min: Int
  max: Int

  startAt: DateTime!
  endAt: DateTime!

  """
  Open joins X minutes before start (null = open immediately after publish)
  """
  joinOpensMinutesBeforeStart: Int

  """
  Close joins before start when now >= startAt - X minutes (null = no pre-start cutoff)
  """
  joinCutoffMinutesBeforeStart: Int

  """
  Allow joining after the event has started (late join)
  """
  allowJoinLate: Boolean!

  """
  Close late join when now >= startAt + X minutes (null = allowed until endAt)
  """
  lateJoinCutoffMinutesAfterStart: Int

  """
  Manual kill-switch for joins; overrides time/cutoff windows
  """
  joinManuallyClosed: Boolean!
  joinManuallyClosedAt: DateTime
  joinManuallyClosedBy: User
  joinManualCloseReason: String

  meetingKind: MeetingKind!
  onlineUrl: String

  lat: Float
  lng: Float
  address: String
  placeId: String
  radiusKm: Float

  # City information for filtering and grouping
  cityName: String
  cityPlaceId: String

  # PostgreSQL enum[]
  levels: [Level!]!

  # Media
  coverKey: String
  coverBlurhash: String

  addressVisibility: AddressVisibility!
  membersVisibility: MembersVisibility!

  # Derived counters
  joinedCount: Int!
  commentsCount: Int!
  messagesCount: Int!
  savedCount: Int! # How many users saved/favourited this event (visible to owner/moderators)
  # Ownership
  ownerId: String
  owner: User

  # Access policy: OWNER/MODERATOR can see all statuses; others see JOINED only.
  members: [EventMember!]!

  # ---------- Computed helpers ----------
  status: EventStatus! # single, high-level status
  isFull: Boolean!
  hasStarted: Boolean!
  isFavourite: Boolean! # Whether the current user has favourited this event
  hasEnded: Boolean!
  isOngoing: Boolean!
  canJoin: Boolean! # generic yes/no for primary CTA
  joinOpen: Boolean! # precise: can the viewer join *now*
  lockReason: JoinLockReason # when joinOpen=false, why
  isOnsite: Boolean!
  isOnline: Boolean!
  isHybrid: Boolean!
  withinLock: Boolean! # ← DODAJ TO
  # Publication status (DRAFT -> PUBLISHED or SCHEDULED -> PUBLISHED)
  publicationStatus: PublicationStatus!
  publishedAt: DateTime
  scheduledPublishAt: DateTime

  # Cancellation (read-only state)
  canceledAt: DateTime
  canceledBy: User
  cancelReason: String
  isCanceled: Boolean!

  # Soft-delete (read-only state)
  deletedAt: DateTime
  deletedBy: User
  deleteReason: String
  isDeleted: Boolean!

  # Billing & Sponsorship
  sponsorshipPlan: EventPlan!
  sponsorship: EventSponsorship
  boostedAt: DateTime # Last time event was boosted (for priority sorting)
  # Check-in configuration
  checkinEnabled: Boolean!
  enabledCheckinMethods: [CheckinMethod!]!
  eventCheckinToken: String # Token for EVENT_QR (shared QR code)
  # Appearance customization
  appearance: EventAppearance

  # Relations
  inviteLinks: [EventInviteLink!]!
  faqs: [EventFaq!]!
  joinQuestions: [EventJoinQuestion!]!
  agendaItems: [EventAgendaItem!]!

  createdAt: DateTime!
  updatedAt: DateTime!
}

"Notification stored in DB; polymorphic target"
type Notification {
  id: ID!
  kind: NotificationKind!
  title: String
  body: String
  data: JSON
  dedupeKey: String
  readAt: DateTime
  createdAt: DateTime!

  recipient: User!
  actor: User

  entityType: NotificationEntity!
  entityId: ID

  # Convenience: resolved when entityType=EVENT (join on eventId or entityId)
  event: Event
}

type NotificationBadgeChanged {
  recipientId: String!
}

# Simple aggregated counters per event; useful for badges
type EventMemberStats {
  joined: Int!
  pending: Int!
  invited: Int!
  rejected: Int!
  banned: Int!
  left: Int!
  kicked: Int!
}

"""
User permissions for a specific event.
Indicates what actions the current user can perform.
"""
type EventPermissions {
  "User is the owner of the event"
  isOwner: Boolean!
  "User is a moderator of the event"
  isModerator: Boolean!
  "User is a participant (joined member)"
  isParticipant: Boolean!
  "User is an app-level admin"
  isAppAdmin: Boolean!
  "User is an app-level moderator"
  isAppModerator: Boolean!
  "User can access management interface"
  canManage: Boolean!
}

# ------------------------------------------------------------------------------
# Direct Messages (DM)
# ------------------------------------------------------------------------------

"Direct message thread between two users"
type DmThread {
  id: ID!
  aUserId: ID!
  bUserId: ID!
  pairKey: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastMessageAt: DateTime

  aUser: User!
  bUser: User!
  messages: [DmMessage!]!

  # Computed helpers
  unreadCount: Int!
  lastMessage: DmMessage
}

"Direct message in a thread"
type DmMessage {
  id: ID!
  threadId: ID!
  senderId: ID!
  content: String!
  replyToId: ID
  createdAt: DateTime!
  readAt: DateTime
  editedAt: DateTime
  deletedAt: DateTime

  thread: DmThread!
  sender: User!
  replyTo: DmMessage
  reactions: [MessageReaction!]!
}

"DM thread mute preference"
type DmMute {
  id: ID!
  threadId: ID!
  userId: ID!
  muted: Boolean!
  createdAt: DateTime!

  thread: DmThread!
  user: User!
}

"Paginated DM threads result"
type DmThreadsResult {
  items: [DmThread!]!
  pageInfo: PageInfo!
}

"Cursor-based DM messages connection"
type DmMessagesConnection {
  edges: [DmMessageEdge!]!
  pageInfo: CursorPageInfo!
}

type DmMessageEdge {
  node: DmMessage!
  cursor: String!
}

# ------------------------------------------------------------------------------
# Comments
# ------------------------------------------------------------------------------

"Comment on an event (2-level threading)"
type Comment {
  id: ID!
  eventId: ID!
  authorId: ID!
  threadId: ID!
  parentId: ID
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deletedById: ID
  hiddenAt: DateTime
  hiddenById: ID

  event: Event!
  author: User!
  parent: Comment
  replies: [Comment!]!
  deletedBy: User
  hiddenBy: User

  # Computed
  repliesCount: Int!
}

"Paginated comments result"
type CommentsResult {
  items: [Comment!]!
  pageInfo: PageInfo!
}

# ------------------------------------------------------------------------------
# Reviews
# ------------------------------------------------------------------------------

"Review for an event (1-5 stars)"
type Review {
  id: ID!
  eventId: ID!
  authorId: ID!
  rating: Int!
  content: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deletedById: ID
  hiddenAt: DateTime
  hiddenById: ID

  event: Event!
  author: User!
  deletedBy: User
  hiddenBy: User
}

"Paginated reviews result"
type ReviewsResult {
  items: [Review!]!
  pageInfo: PageInfo!
}

"Review statistics for an event"
type ReviewStats {
  totalCount: Int!
  averageRating: Float!
  ratingDistribution: [RatingCount!]!
}

"Rating count for a specific star rating"
type RatingCount {
  rating: Int!
  count: Int!
}

# ------------------------------------------------------------------------------
# Reports
# ------------------------------------------------------------------------------

"Report status"
enum ReportStatus {
  OPEN
  INVESTIGATING
  RESOLVED
  DISMISSED
}

"Report for content moderation"
type Report {
  id: ID!
  reporterId: ID!
  entity: ReportEntity!
  entityId: ID!
  reason: String!
  status: ReportStatus!
  createdAt: DateTime!
  resolvedAt: DateTime

  reporter: User!
}

"Paginated reports result"
type ReportsResult {
  items: [Report!]!
  pageInfo: PageInfo!
}

# ------------------------------------------------------------------------------
# Event Chat (Event Chat Messages)
# ------------------------------------------------------------------------------

"Message in an event chat room"
type EventChatMessage {
  id: ID!
  eventId: ID!
  authorId: ID!
  content: String!
  replyToId: ID
  createdAt: DateTime!
  editedAt: DateTime
  deletedAt: DateTime

  event: Event!
  author: User!
  replyTo: EventChatMessage
  reactions: [MessageReaction!]!

  # Computed
  isEdited: Boolean!
  isDeleted: Boolean!
}

"Aggregated reaction for a message"
type MessageReaction {
  emoji: String!
  count: Int!
  users: [User!]!
  reacted: Boolean!
}

"Paginated event chat messages result"
type EventChatMessagesResult {
  items: [EventChatMessage!]!
  pageInfo: CursorPageInfo!
  hasMore: Boolean!
}

"Cursor-based Event messages connection"
type EventMessagesConnection {
  edges: [EventMessageEdge!]!
  pageInfo: CursorPageInfo!
}

type EventMessageEdge {
  node: EventChatMessage!
  cursor: String!
}

# ------------------------------------------------------------------------------
# Map Clustering
# ------------------------------------------------------------------------------

"Bounding box for map viewport"
input BBoxInput {
  swLat: Float!
  swLon: Float!
  neLat: Float!
  neLon: Float!
}

"Filters for clustering map events"
input ClusterFiltersInput {
  "Search query (keywords)"
  q: String
  "Category slugs to filter by"
  categorySlugs: [String!]
  "Tag slugs to filter by"
  tagSlugs: [String!]
  "Levels to filter by"
  levels: [Level!]
  "Meeting kinds to filter by"
  kinds: [MeetingKind!]
  "Join modes to filter by"
  joinModes: [JoinMode!]
  "Show only verified organizers"
  verifiedOnly: Boolean
  "Event status filter"
  status: EventStatus
  "Start date ISO string for date range filter"
  startISO: String
  "End date ISO string for date range filter"
  endISO: String
  "City name for location filter"
  city: String
  "City latitude for location filter"
  cityLat: Float
  "City longitude for location filter"
  cityLng: Float
  "Distance in km from city center"
  distanceKm: Float
}

"Clustered point on the map representing one or more events"
type Cluster {
  id: ID!
  latitude: Float!
  longitude: Float!
  count: Int!
  region: String!
  geoJson: JSON!
}

"Page metadata for region events"
type PageMeta {
  page: Int!
  totalItems: Int!
  totalPages: Int!
  prevPage: Int
  nextPage: Int
}

"Paginated result for events in a map region"
type RegionEventPage {
  data: [Event!]!
  meta: PageMeta!
}

# ------------------------------------------------------------------------------
# Inputs
# ------------------------------------------------------------------------------

input CreateCategoryInput {
  slug: String!
  names: JSONObject!
}

input UpdateCategoryInput {
  slug: String
  names: JSONObject
}

input CreateTagInput {
  label: String!
  slug: String!
}

input UpdateTagInput {
  label: String
  slug: String
}

input LocationInput {
  lat: Float
  lng: Float
  address: String
  placeId: String
  radiusKm: Float
  cityName: String
  cityPlaceId: String
}

input JoinQuestionInputData {
  type: JoinQuestionType!
  label: String!
  helpText: String
  required: Boolean
  options: JSON
  maxLength: Int
}

input CreateEventInput {
  # Required fields
  title: String!
  categorySlugs: [String!]!
  startAt: DateTime!
  endAt: DateTime!

  # Optional basic fields
  description: String
  meetingKind: MeetingKind!
  onlineUrl: String
  location: LocationInput

  # Capacity (defaults set by backend based on mode)
  mode: Mode!
  min: Int
  max: Int

  # Privacy
  visibility: Visibility!
  joinMode: JoinMode!
}

input UpdateEventInput {
  title: String
  categorySlugs: [String!]
  tagSlugs: [String!]
  description: String
  notes: String

  visibility: Visibility
  joinMode: JoinMode
  mode: Mode
  min: Int
  max: Int

  startAt: DateTime
  endAt: DateTime

  # Joins windows / cutoffs
  joinOpensMinutesBeforeStart: Int
  joinCutoffMinutesBeforeStart: Int
  allowJoinLate: Boolean
  lateJoinCutoffMinutesAfterStart: Int
  joinManuallyClosed: Boolean
  joinManualCloseReason: String

  meetingKind: MeetingKind
  onlineUrl: String

  location: LocationInput
  levels: [Level!]

  addressVisibility: AddressVisibility
  membersVisibility: MembersVisibility
}

input InviteMemberInput {
  eventId: ID!
  userId: ID!
}

input ApproveMembershipInput {
  eventId: ID!
  userId: ID!
}

input RejectMembershipInput {
  eventId: ID!
  userId: ID!
  note: String
}

input KickMemberInput {
  eventId: ID!
  userId: ID!
  note: String
}

input UpdateMemberRoleInput {
  eventId: ID!
  userId: ID!
  role: EventMemberRole!
}

# Check-in input types

input CheckInMemberInput {
  eventId: ID!
  userId: ID!
  method: CheckinMethod!
}

input UncheckInMemberInput {
  eventId: ID!
  userId: ID!
  method: CheckinMethod
}

input RejectMemberCheckinInput {
  eventId: ID!
  userId: ID!
  reason: String
  showReasonToUser: Boolean
  blockMethod: CheckinMethod # If provided, block this specific method
  blockAll: Boolean # If true, block all check-in methods
}

input BlockMemberCheckinInput {
  eventId: ID!
  userId: ID!
  blockAll: Boolean # If true, block all methods
  method: CheckinMethod # If blockAll=false, block only this method
  reason: String
}

input UnblockMemberCheckinInput {
  eventId: ID!
  userId: ID!
  unblockAll: Boolean # If true, unblock all methods
  method: CheckinMethod # If unblockAll=false, unblock only this method
}

input UpdateEventCheckinConfigInput {
  eventId: ID!
  checkinEnabled: Boolean
  enabledCheckinMethods: [CheckinMethod!]
}

type CheckinResult {
  success: Boolean!
  message: String
  member: EventMember
  event: Event
}

# NEW: Ban / Unban / Cancel pending-or-invite
input BanMemberInput {
  eventId: ID!
  userId: ID!
  note: String
}

input UnbanMemberInput {
  eventId: ID!
  userId: ID!
}

input CancelPendingOrInviteForUserInput {
  eventId: ID!
  userId: ID!
}

input PromoteFromWaitlistInput {
  eventId: ID!
  userId: ID!
}

# DM Inputs
input SendDmMessageInput {
  recipientId: ID!
  content: String!
  replyToId: ID
}

input UpdateDmMessageInput {
  content: String!
}

# Comment Inputs
input CreateCommentInput {
  eventId: ID!
  content: String!
  parentId: ID
}

input UpdateCommentInput {
  content: String!
}

# Review Inputs
input CreateReviewInput {
  eventId: ID!
  rating: Int!
  content: String
}

input UpdateReviewInput {
  rating: Int
  content: String
}

# Report Inputs
input CreateReportInput {
  entity: ReportEntity!
  entityId: ID!
  reason: String!
}

input UpdateReportStatusInput {
  status: ReportStatus!
}

# Event Chat Inputs
input SendEventMessageInput {
  eventId: ID!
  content: String!
  replyToId: ID
}

input EditEventMessageInput {
  content: String!
}

# Event Invite Link Inputs
input CreateEventInviteLinkInput {
  eventId: ID!
  maxUses: Int
  expiresAt: DateTime
}

# Join Form Inputs
input CreateJoinQuestionInput {
  eventId: ID!
  order: Int!
  type: JoinQuestionType!
  label: String!
  helpText: String
  required: Boolean
  options: JSON
  maxLength: Int
}

input UpdateJoinQuestionInput {
  order: Int
  label: String
  helpText: String
  required: Boolean
  options: JSON
  maxLength: Int
}

# Feedback Inputs
input CreateFeedbackQuestionInput {
  eventId: ID!
  order: Int!
  type: FeedbackQuestionType!
  label: String!
  helpText: String
  required: Boolean
  options: JSON
  maxLength: Int
}

input UpdateFeedbackQuestionInput {
  order: Int
  label: String
  helpText: String
  required: Boolean
  options: JSON
  maxLength: Int
}

input FeedbackAnswerInput {
  questionId: ID!
  answer: JSON!
}

input SubmitReviewAndFeedbackInput {
  eventId: ID!
  # Review data
  rating: Int!
  content: String
  # Feedback answers (optional)
  feedbackAnswers: [FeedbackAnswerInput!]
}

input JoinAnswerInput {
  questionId: ID!
  answer: JSON!
}

input RequestJoinEventInput {
  eventId: ID!
  answers: [JoinAnswerInput!]!
}

input ApproveJoinRequestInput {
  eventId: ID!
  userId: ID!
}

input RejectJoinRequestInput {
  eventId: ID!
  userId: ID!
  reason: String
}

# Notification Preference Inputs
input UpdateNotificationPreferenceInput {
  emailOnInvite: Boolean
  emailOnJoinRequest: Boolean
  emailOnMessage: Boolean
  pushOnReminder: Boolean
  inAppOnEverything: Boolean
}

# ------------------------------------------------------------------------------
# Admin Input Types
# ------------------------------------------------------------------------------

input AdminUpdateUserInput {
  name: String
  email: String
  role: Role
  verifiedAt: DateTime
  locale: String
}

input AdminInviteUserInput {
  email: String!
  name: String
  role: Role!
}

input AdminCreateUserInput {
  email: String!
  name: String
  role: Role!
  verified: Boolean!
}

# Admin Event Management Inputs
input AdminBulkUpdateEventsInput {
  visibility: Visibility
  joinManuallyClosed: Boolean
  joinManualCloseReason: String
}

type AdminBulkUpdateResult {
  success: Int!
  failed: Int!
  errors: [String!]
}

# ------------------------------------------------------------------------------
# Billing Inputs
# ------------------------------------------------------------------------------

input CreateSubscriptionCheckoutInput {
  plan: SubscriptionPlan!
  billingPeriod: BillingPeriod!
  withTrial: Boolean
}

input CreateOneOffCheckoutInput {
  plan: SubscriptionPlan!
  billingPeriod: BillingPeriod!
}

input CreateEventSponsorshipCheckoutInput {
  eventId: ID!
  plan: EventPlan!
  actionType: String
  actionPackageSize: Int
}

# ------------------------------------------------------------------------------
# Queries
# ------------------------------------------------------------------------------

type Query {
  notifications(
    recipientId: ID!
    unreadOnly: Boolean = false
    entityType: NotificationEntity
    limit: Int = 50
    offset: Int = 0
  ): NotificationsResult!

  events(
    limit: Int = 20
    offset: Int = 0
    visibility: Visibility
    joinMode: JoinMode
    joinModes: [JoinMode!]
    ownerId: ID
    memberId: ID
    upcomingAfter: DateTime
    endingBefore: DateTime
    categorySlugs: [String!]
    tagSlugs: [String!]
    levels: [Level!]
    kinds: [MeetingKind!]
    keywords: [String!]
    status: EventStatus
    verifiedOnly: Boolean
    distanceKm: Float
    near: LocationInput
    sortBy: EventsSortBy = START_AT
    sortDir: SortDir = ASC
  ): EventsResult!

  event(id: ID!): Event

  eventMembers(
    eventId: ID!
    status: EventMemberStatus
    role: EventMemberRole
    limit: Int = 50
    offset: Int = 0
  ): [EventMember!]!

  eventMember(eventId: ID!, userId: ID!): EventMember

  """
  Get current user's membership for a specific event.
  Returns null if user is not authenticated or has no membership.
  Unlike eventMember, this doesn't require userId parameter.
  """
  myMembershipForEvent(eventId: ID!): EventMember

  myMemberships(
    status: EventMemberStatus
    role: EventMemberRole
    limit: Int = 50
    offset: Int = 0
  ): [EventMember!]!

  """
  Get all events where current user has membership, with flexible filtering.
  Supports filtering by membership role/status AND event lifecycle status.
  """
  myEvents(
    "Filter by membership role (OWNER, MODERATOR, MEMBER)"
    role: EventMemberRole
    "Filter by membership status (JOINED, PENDING, INVITED, etc.)"
    membershipStatus: EventMemberStatus
    "Filter by event lifecycle status (UPCOMING, ONGOING, FINISHED, etc.) - supports multiple"
    eventStatuses: [EventLifecycleStatus!]
    "Pagination limit"
    limit: Int = 50
    "Pagination offset"
    offset: Int = 0
  ): [EventMember!]!

  eventMemberStats(eventId: ID!): EventMemberStats!

  """
  Check user's permissions for a specific event.
  Returns permission flags for the current authenticated user.
  """
  eventPermissions(eventId: ID!): EventPermissions!

  # Event Invite Links
  eventInviteLinks(
    eventId: ID!
    includeRevoked: Boolean = false
  ): [EventInviteLink!]!
  eventInviteLink(id: ID, code: String): EventInviteLink
  validateInviteLink(code: String!): EventInviteLinkValidation!

  # Event Favourites
  myFavourites(limit: Int = 20, offset: Int = 0): EventFavouritesResult!
  isFavourite(eventId: ID!): Boolean!

  # Join Form
  eventJoinQuestions(eventId: ID!): [EventJoinQuestion!]!
  eventJoinRequests(
    eventId: ID!
    limit: Int = 20
    offset: Int = 0
  ): EventJoinRequestsResult!
  myJoinRequests(
    status: EventMemberStatus
    limit: Int = 20
    offset: Int = 0
  ): [EventMember!]!

  # Feedback
  eventFeedbackQuestions(eventId: ID!): [EventFeedbackQuestion!]!
  eventFeedbackResults(eventId: ID!): EventFeedbackResults!
  myFeedbackAnswers(eventId: ID!): [EventFeedbackAnswer!]!
  canSubmitFeedback(eventId: ID!): Boolean!

  # Agenda
  eventAgendaItems(eventId: ID!): [EventAgendaItem!]!

  # ==============================================================================
  # Billing & Subscriptions
  # ==============================================================================

  "Get user's current effective plan"
  myPlan: UserPlanInfo!

  "Get user's active subscription (if any)"
  mySubscription: UserSubscription

  "Get user's active plan periods"
  myPlanPeriods(limit: Int = 10): [UserPlanPeriod!]!

  "Get all event sponsorship transaction history for the current user"
  myEventSponsorships(limit: Int = 50): [EventSponsorshipPeriod!]!

  "Get event sponsorship for an event"
  eventSponsorship(eventId: ID!): EventSponsorship

  categoriesBySlugs(slugs: [String!]!, limit: Int): [Category!]!
  categories(query: String, limit: Int = 50): [Category!]!
  category(id: ID, slug: String): Category
  checkCategorySlugAvailable(slug: String!): Boolean!
  getCategoryUsageCount(slug: String!): Int!

  tagsBySlugs(slugs: [String!]!, limit: Int): [Tag!]!
  tags(query: String, limit: Int = 50): [Tag!]!
  tag(id: ID, slug: String): Tag
  checkTagSlugAvailable(slug: String!): Boolean!
  getTagUsageCount(slug: String!): Int!

  users(
    limit: Int = 50
    offset: Int = 0
    q: String
    role: Role
    verifiedOnly: Boolean
    sortBy: UsersSortBy = CREATED_AT
    sortDir: SortDir = DESC
  ): UsersResult!

  user(id: ID, name: String): User

  me: SessionUser

  # DM Queries
  dmThreads(
    limit: Int = 20
    offset: Int = 0
    unreadOnly: Boolean = false
  ): DmThreadsResult!

  dmThread(id: ID, otherUserId: ID): DmThread

  dmMessages(
    threadId: ID!
    first: Int = 20
    before: String
    after: String
  ): DmMessagesConnection!

  # Comment Queries
  comments(
    eventId: ID!
    limit: Int = 50
    offset: Int = 0
    threadId: ID
    parentId: ID
  ): CommentsResult!

  comment(id: ID!): Comment

  # Review Queries
  reviews(
    eventId: ID!
    limit: Int = 20
    offset: Int = 0
    rating: Int
  ): ReviewsResult!

  review(id: ID!): Review

  reviewStats(eventId: ID!): ReviewStats!

  myReview(eventId: ID!): Review

  # Report Queries (admin only)
  reports(
    limit: Int = 20
    offset: Int = 0
    status: ReportStatus
    entity: ReportEntity
  ): ReportsResult!

  report(id: ID!): Report

  # Event Chat Queries
  eventMessages(
    eventId: ID!
    first: Int = 20
    before: String
    after: String
  ): EventMessagesConnection!

  eventUnreadCount(eventId: ID!): Int!

  # User Block Queries
  myBlocks(limit: Int = 50, offset: Int = 0): UserBlocksResult!
  isBlocked(userId: ID!): Boolean!

  # Notification Preference Queries
  myNotificationPreferences: NotificationPreference!

  # Mute Queries
  eventMute(eventId: ID!): EventMute
  dmMute(threadId: ID!): DmMute

  # Map Clustering Queries
  clusters(
    bbox: BBoxInput!
    zoom: Float!
    filters: ClusterFiltersInput
  ): [Cluster!]!

  regionEvents(
    region: String!
    page: Int = 1
    perPage: Int = 20
    filters: ClusterFiltersInput
  ): RegionEventPage!

  # Admin User Management Queries
  adminUserComments(userId: ID!, limit: Int, offset: Int): AdminCommentsResult!
  adminUserReviews(userId: ID!, limit: Int, offset: Int): AdminReviewsResult!
  adminUserMemberships(
    userId: ID!
    limit: Int
    offset: Int
  ): AdminMembershipsResult!
  adminUserEvents(userId: ID!, limit: Int, offset: Int): AdminEventsResult!
  adminUserDmThreads(
    userId: ID!
    limit: Int
    offset: Int
  ): AdminDmThreadsResult!
  adminUserNotifications(
    userId: ID!
    limit: Int
    offset: Int
  ): NotificationsResult!

  userEvents(userId: ID!, limit: Int, offset: Int): UserEventsResult!
  userReviews(userId: ID!, limit: Int, offset: Int): UserReviewsResult!

  # Check-in queries
  """
  Get check-in logs for an event (moderator only)
  """
  eventCheckinLogs(
    eventId: ID!
    limit: Int
    offset: Int
    action: CheckinAction
    method: CheckinMethod
    memberId: ID
  ): EventCheckinLogsResult!

  # Admin Content Moderation Queries
  adminComments(
    limit: Int
    offset: Int
    eventId: ID
    userId: ID
  ): AdminCommentsResult!
  adminReviews(
    limit: Int
    offset: Int
    eventId: ID
    userId: ID
    rating: Int
  ): AdminReviewsResult!
}

# ------------------------------------------------------------------------------
# Admin Result Types
# ------------------------------------------------------------------------------

type AdminCommentsResult {
  items: [Comment!]!
  pageInfo: AdminPageInfo!
}

type AdminReviewsResult {
  items: [Review!]!
  pageInfo: AdminPageInfo!
}

type AdminMembershipsResult {
  items: [AdminMembershipItem!]!
  pageInfo: AdminPageInfo!
}

type AdminEventsResult {
  items: [AdminEventItem!]!
  pageInfo: AdminPageInfo!
}

type AdminDmThreadsResult {
  items: [AdminDmThreadItem!]!
  pageInfo: AdminPageInfo!
}

type AdminPageInfo {
  total: Int!
  hasMore: Boolean!
}

type AdminMembershipItem {
  id: ID!
  status: EventMemberStatus!
  role: EventMemberRole!
  joinedAt: DateTime
  event: AdminEventSummary!
}

type AdminEventItem {
  id: ID!
  title: String!
  startAt: DateTime!
  status: String!
  joinedCount: Int!
}

type AdminDmThreadItem {
  id: ID!
  createdAt: DateTime!
  lastMessageAt: DateTime
  otherUser: User!
  messageCount: Int!
}

type AdminEventSummary {
  id: ID!
  title: String!
  startAt: DateTime!
}

# ------------------------------------------------------------------------------
# Mutations
# ------------------------------------------------------------------------------
type Mutation {
  # categories & tags
  createCategory(input: CreateCategoryInput!): Category!
  updateCategory(id: ID!, input: UpdateCategoryInput!): Category!
  deleteCategory(id: ID!): Boolean!

  createTag(input: CreateTagInput!): Tag!
  updateTag(id: ID!, input: UpdateTagInput!): Tag!
  deleteTag(id: ID!): Boolean!

  # events
  createEvent(input: CreateEventInput!): Event!
  updateEvent(id: ID!, input: UpdateEventInput!): Event!
  deleteEvent(id: ID!): Boolean!
  cancelEvent(id: ID!, reason: String): Event!
  closeEventJoin(eventId: ID!, reason: String): Event!
  reopenEventJoin(eventId: ID!): Event!

  # Publication management
  """
  Publish event immediately (DRAFT/SCHEDULED -> PUBLISHED)
  """
  publishEvent(id: ID!): Event!
  """
  Schedule event publication for a specific time (DRAFT -> SCHEDULED)
  """
  scheduleEventPublication(id: ID!, publishAt: DateTime!): Event!
  """
  Cancel scheduled publication (SCHEDULED -> DRAFT)
  """
  cancelScheduledPublication(id: ID!): Event!
  """
  Unpublish event (PUBLISHED -> DRAFT)
  """
  unpublishEvent(id: ID!): Event!

  # memberships (user endpoints)
  requestJoinEvent(eventId: ID!): Event! # Deprecated: use requestJoinEventWithAnswers
  requestJoinEventWithAnswers(input: RequestJoinEventInput!): Event!
  cancelJoinRequest(eventId: ID!): Boolean!
  leaveEvent(eventId: ID!): Event!
  acceptInvite(eventId: ID!): Event!

  # waitlist (user endpoints)
  joinWaitlistOpen(eventId: ID!): Event!
  leaveWaitlist(eventId: ID!): Boolean!

  # memberships (owner/mod endpoints)
  inviteMember(input: InviteMemberInput!): Event!
  approveMembership(input: ApproveMembershipInput!): Event! # Deprecated: use approveJoinRequest
  approveJoinRequest(input: ApproveJoinRequestInput!): Event!
  rejectMembership(input: RejectMembershipInput!): Event! # Deprecated: use rejectJoinRequest
  rejectJoinRequest(input: RejectJoinRequestInput!): Event!
  kickMember(input: KickMemberInput!): Event!
  updateMemberRole(input: UpdateMemberRoleInput!): Event!
  banMember(input: BanMemberInput!): Event!
  unbanMember(input: UnbanMemberInput!): Event!
  promoteFromWaitlist(input: PromoteFromWaitlistInput!): Event!
  cancelPendingOrInviteForUser(
    input: CancelPendingOrInviteForUserInput!
  ): Boolean!

  # Check-in (user endpoints)
  """
  User checks themselves in manually (SELF_MANUAL method)
  """
  checkInSelf(eventId: ID!): CheckinResult!
  """
  User removes their own check-in (SELF_MANUAL method only)
  """
  uncheckInSelf(eventId: ID!): CheckinResult!

  # Check-in (moderator endpoints)
  """
  Moderator checks in a member via panel (MODERATOR_PANEL method)
  """
  checkInMember(input: CheckInMemberInput!): CheckinResult!
  """
  Moderator removes a member's check-in
  """
  uncheckInMember(input: UncheckInMemberInput!): CheckinResult!
  """
  Moderator rejects check-in with optional comment and block
  """
  rejectMemberCheckin(input: RejectMemberCheckinInput!): CheckinResult!
  """
  Moderator blocks member's check-in (all methods or specific method)
  """
  blockMemberCheckin(input: BlockMemberCheckinInput!): CheckinResult!
  """
  Moderator unblocks member's check-in
  """
  unblockMemberCheckin(input: UnblockMemberCheckinInput!): CheckinResult!

  # Check-in QR endpoints
  """
  Check in via shared event QR code (EVENT_QR method)
  """
  checkInByEventQr(eventId: ID!, token: String!): CheckinResult!
  """
  Check in member via their individual QR code (USER_QR method, scanned by moderator)
  """
  checkInByUserQr(token: String!): CheckinResult!

  # Check-in configuration (moderator)
  """
  Update event check-in configuration
  """
  updateEventCheckinConfig(input: UpdateEventCheckinConfigInput!): Event!
  """
  Rotate (regenerate) event QR token for security
  """
  rotateEventCheckinToken(eventId: ID!): Event!
  """
  Rotate (regenerate) member's individual QR token
  """
  rotateMemberCheckinToken(eventId: ID!, memberId: ID!): EventMember!

  # Event Invite Links
  createEventInviteLink(input: CreateEventInviteLinkInput!): EventInviteLink!
  updateEventInviteLink(
    id: ID!
    input: UpdateEventInviteLinkInput!
  ): EventInviteLink!
  revokeEventInviteLink(id: ID!): EventInviteLink!
  deleteEventInviteLink(id: ID!): Boolean!
  joinByInviteLink(code: String!): Event!

  # Event Favourites
  toggleFavourite(eventId: ID!): EventFavourite

  # Feedback mutations
  createFeedbackQuestion(
    input: CreateFeedbackQuestionInput!
  ): EventFeedbackQuestion!
  updateFeedbackQuestion(
    id: ID!
    input: UpdateFeedbackQuestionInput!
  ): EventFeedbackQuestion!
  deleteFeedbackQuestion(id: ID!): Boolean!
  reorderFeedbackQuestions(
    eventId: ID!
    questionIds: [ID!]!
  ): [EventFeedbackQuestion!]!

  # Submit review + feedback (combined)
  submitReviewAndFeedback(
    input: SubmitReviewAndFeedbackInput!
  ): SubmitReviewAndFeedbackResult!

  # Manual trigger for feedback requests (owner/moderator only)
  sendFeedbackRequests(eventId: ID!): SendFeedbackRequestsResult!

  # FAQ Management
  updateEventFaqs(input: UpdateEventFaqsInput!): [EventFaq!]!

  # Agenda Management
  updateEventAgenda(input: UpdateEventAgendaInput!): [EventAgendaItem!]!

  # Join Form Management
  updateEventJoinQuestions(
    input: UpdateEventJoinQuestionsInput!
  ): [EventJoinQuestion!]!

  # Feedback Questions bulk update (replaces create/update/delete/reorder)
  updateEventFeedbackQuestions(
    input: UpdateEventFeedbackQuestionsInput!
  ): [EventFeedbackQuestion!]!

  # notifications
  addNotification(
    recipientId: ID!
    kind: NotificationKind! = SYSTEM
    title: String
    body: String
    data: JSON
    entityType: NotificationEntity! = OTHER
    entityId: ID
  ): Notification!

  markNotificationRead(id: ID!): Boolean!
  deleteNotification(id: ID!): Boolean!
  markAllNotificationsRead(recipientId: ID!): Int!

  # DM
  sendDmMessage(input: SendDmMessageInput!): DmMessage!
  updateDmMessage(id: ID!, input: UpdateDmMessageInput!): DmMessage!
  deleteDmMessage(id: ID!): Boolean!
  markDmMessageRead(id: ID!): Boolean!
  markDmThreadRead(threadId: ID!): Int!
  deleteDmThread(id: ID!): Boolean! # ← DODANE
  createOrGetDmThread(userId: ID!): DmThread!
  publishDmTyping(threadId: ID!, isTyping: Boolean!): Boolean!

  # Comments
  createComment(input: CreateCommentInput!): Comment!
  updateComment(id: ID!, input: UpdateCommentInput!): Comment!
  deleteComment(id: ID!): Boolean!

  # Moderation: Hide/unhide comments (soft delete for moderation)
  hideComment(id: ID!): Boolean!
  unhideComment(id: ID!): Boolean!

  # Reviews
  createReview(input: CreateReviewInput!): Review!
  updateReview(id: ID!, input: UpdateReviewInput!): Review!
  deleteReview(id: ID!): Boolean!

  # Moderation: Hide/unhide reviews (soft delete for moderation)
  hideReview(id: ID!): Boolean!
  unhideReview(id: ID!): Boolean!

  # Reports
  createReport(input: CreateReportInput!): Report!
  updateReportStatus(id: ID!, input: UpdateReportStatusInput!): Report!
  deleteReport(id: ID!): Boolean!

  # Event Chat
  sendEventMessage(input: SendEventMessageInput!): EventChatMessage!
  editEventMessage(id: ID!, input: EditEventMessageInput!): EventChatMessage!
  deleteEventMessage(id: ID!, soft: Boolean = true): Boolean!
  markEventChatRead(eventId: ID!, at: DateTime): Boolean!
  publishEventTyping(eventId: ID!, isTyping: Boolean!): Boolean!

  # Reactions
  addDmReaction(messageId: ID!, emoji: String!): Boolean!
  removeDmReaction(messageId: ID!, emoji: String!): Boolean!
  addEventReaction(messageId: ID!, emoji: String!): Boolean!
  removeEventReaction(messageId: ID!, emoji: String!): Boolean!

  # User Blocks
  blockUser(userId: ID!): UserBlock! # ← DODANE
  unblockUser(userId: ID!): Boolean! # ← DODANE
  # Notification Preferences
  updateNotificationPreferences(
    input: UpdateNotificationPreferenceInput!
  ): NotificationPreference! # ← DODANE
  # Mutes
  muteEvent(eventId: ID!, muted: Boolean!): EventMute!
  muteDmThread(threadId: ID!, muted: Boolean!): DmMute!

  # Admin - User Management
  adminUpdateUser(id: ID!, input: AdminUpdateUserInput!): User!
  adminDeleteUser(id: ID!, anonymize: Boolean): Boolean!
  adminInviteUser(input: AdminInviteUserInput!): User!
  adminCreateUser(input: AdminCreateUserInput!): User!
  adminSuspendUser(id: ID!, reason: String): User!
  adminUnsuspendUser(id: ID!): User!

  # Admin - Event Management
  adminUpdateEvent(id: ID!, input: UpdateEventInput!): Event!
  adminDeleteEvent(id: ID!): Boolean!
  adminCancelEvent(id: ID!, reason: String): Event!
  adminRestoreEvent(id: ID!): Event!
  adminChangeEventOwner(eventId: ID!, newOwnerId: ID!): Event!
  adminBulkUpdateEvents(
    ids: [ID!]!
    input: AdminBulkUpdateEventsInput!
  ): AdminBulkUpdateResult!

  # Admin - Content Moderation
  adminDeleteComment(id: ID!): Boolean!
  adminDeleteReview(id: ID!): Boolean!

  # Admin - Event Member Management
  adminUpdateMemberRole(input: UpdateMemberRoleInput!): Event!
  adminKickMember(input: KickMemberInput!): Event!
  adminBanMember(input: BanMemberInput!): Event!
  adminUnbanMember(input: UnbanMemberInput!): Event!

  # User Profile & Privacy
  updateUserProfile(input: UpdateUserProfileInput!): UserProfile!
  updateUserPrivacy(input: UpdateUserPrivacyInput!): UserPrivacy!

  # User Locale & Timezone
  updateUserLocale(locale: String!): User!
  updateUserTimezone(timezone: String!): User!

  # User Account Deletion
  deleteMyAccount(reason: String): Boolean!

  # User Account Restoration
  requestAccountRestoration(email: String!): Boolean!
  restoreMyAccount(email: String!, token: String!): Boolean!

  # User Category Levels
  upsertUserCategoryLevel(
    input: UpsertUserCategoryLevelInput!
  ): UserCategoryLevel!
  removeUserCategoryLevel(id: ID!): Boolean!

  # User Availability
  upsertUserAvailability(input: UpsertUserAvailabilityInput!): UserAvailability!
  removeUserAvailability(id: ID!): Boolean!

  # User Social Links
  addUserSocialLink(input: AddUserSocialLinkInput!): UserSocialLink!
  removeUserSocialLink(id: ID!): Boolean!

  # Media Upload
  getUploadUrl(purpose: MediaPurpose!, entityId: ID!): PresignedUpload!
  confirmMediaUpload(
    purpose: MediaPurpose!
    entityId: ID!
    uploadKey: String!
  ): ConfirmMediaUploadPayload!

  # ==============================================================================
  # Billing & Subscriptions
  # ==============================================================================

  "Create checkout session for user subscription (auto-renewable)"
  createSubscriptionCheckout(
    input: CreateSubscriptionCheckoutInput!
  ): CheckoutSession!

  "Create checkout session for one-off payment (month or year)"
  createOneOffCheckout(input: CreateOneOffCheckoutInput!): CheckoutSession!

  "Create checkout session for event sponsorship"
  createEventSponsorshipCheckout(
    input: CreateEventSponsorshipCheckoutInput!
  ): EventSponsorshipCheckout!

  "Cancel user subscription (at period end or immediately)"
  cancelSubscription(immediately: Boolean = false): Boolean!

  "Reactivate a subscription that was set to cancel at period end"
  reactivateSubscription: Boolean!

  "Get receipt URL for a user plan period"
  getUserPlanReceiptUrl(periodId: ID!): String

  "Get receipt URL for an event sponsorship period"
  getEventSponsorshipReceiptUrl(periodId: ID!): String

  "Use a boost for event sponsorship"
  useBoost(eventId: ID!): Boolean!

  "Use a local push notification for event sponsorship"
  useLocalPush(eventId: ID!): Boolean!

  "Update event appearance configuration"
  updateEventAppearance(input: UpdateEventAppearanceInput!): EventAppearance!

  # dev only
  devLogin(name: String!): SessionUser
  devLogout: Boolean!
}

# ------------------------------------------------------------------------------
# Subscriptions (scoped per recipient)
# ------------------------------------------------------------------------------

type Subscription {
  notificationAdded(recipientId: ID!): Notification!
  notificationBadgeChanged(recipientId: ID!): NotificationBadgeChanged!

  # Event Chat Subscriptions
  eventMessageAdded(eventId: ID!): EventChatMessage!
  eventMessageUpdated(eventId: ID!): EventChatMessage!
  eventMessageDeleted(eventId: ID!): MessageDeletedEvent!
  eventTyping(eventId: ID!): TypingIndicator!
  eventReactionAdded(eventId: ID!): ReactionEvent!

  # DM Subscriptions
  dmMessageAdded(threadId: ID!): DmMessage!
  dmMessageUpdated(threadId: ID!): DmMessage!
  dmMessageDeleted(threadId: ID!): MessageDeletedEvent!
  dmTyping(threadId: ID!): TypingIndicator!
  dmReactionAdded(threadId: ID!): ReactionEvent!
}

# Reaction event for subscriptions
type ReactionEvent {
  messageId: ID!
  userId: ID!
  emoji: String!
  action: ReactionAction!
}

enum ReactionAction {
  ADD
  REMOVE
}

# Message deleted event for subscriptions
type MessageDeletedEvent {
  messageId: ID!
  deletedAt: DateTime!
}

# Typing indicator for real-time presence
type TypingIndicator {
  userId: ID!
  isTyping: Boolean!
}

# ------------------------------------------------------------------------------
# User Blocks
# ------------------------------------------------------------------------------

"User block for preventing interactions"
type UserBlock {
  id: ID!
  blockerId: ID!
  blockedId: ID!
  createdAt: DateTime!

  blocker: User!
  blocked: User!
}

"Paginated user blocks result"
type UserBlocksResult {
  items: [UserBlock!]!
  pageInfo: PageInfo!
}

# ------------------------------------------------------------------------------
# Event Invite Links
# ------------------------------------------------------------------------------

"Invite link for event with usage limits"
type EventInviteLink {
  id: ID!
  eventId: ID!
  code: String!
  maxUses: Int
  usedCount: Int!
  expiresAt: DateTime
  createdById: ID
  createdBy: User
  label: String
  revokedAt: DateTime
  revokedById: ID
  revokedBy: User
  createdAt: DateTime!
  updatedAt: DateTime

  event: Event!
  uses: [EventInviteLinkUsage!]!

  # Computed
  isExpired: Boolean!
  isMaxedOut: Boolean!
  isValid: Boolean!
  isRevoked: Boolean!
}

"Usage record for invite link"
type EventInviteLinkUsage {
  id: ID!
  linkId: ID!
  userId: ID!
  usedAt: DateTime!
  user: User!
}

"Paginated invite links result"
type EventInviteLinksResult {
  items: [EventInviteLink!]!
  pageInfo: PageInfo!
}

"Validation result for invite link"
type EventInviteLinkValidation {
  valid: Boolean!
  reason: String
  link: EventInviteLink
  event: Event
}

"Input for creating invite link"
input CreateEventInviteLinkInput {
  eventId: ID!
  label: String
  maxUses: Int
  expiresAt: DateTime
}

"Input for updating invite link"
input UpdateEventInviteLinkInput {
  label: String
  maxUses: Int
  expiresAt: DateTime
}

# ------------------------------------------------------------------------------
# FAQ
# ------------------------------------------------------------------------------

"FAQ item for an event"
type EventFaq {
  id: ID!
  eventId: ID!
  order: Int!
  question: String!
  answer: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  event: Event!
}

"Input for creating/updating FAQ"
input EventFaqInput {
  question: String!
  answer: String!
}

"Input for bulk updating FAQs"
input UpdateEventFaqsInput {
  eventId: ID!
  faqs: [EventFaqInput!]!
}

# ------------------------------------------------------------------------------
# Event Appearance
# ------------------------------------------------------------------------------

"Custom appearance configuration for an event"
type EventAppearance {
  id: ID!
  eventId: ID!
  "JSON configuration for card and detail appearance"
  config: JSON!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Input for card appearance configuration"
input EventAppearanceCardInput {
  background: String
  shadow: String
}

"Input for detail panel appearance configuration"
input EventAppearanceDetailPanelInput {
  background: String
  shadow: String
}

"Input for detail appearance configuration"
input EventAppearanceDetailInput {
  background: String
  panel: EventAppearanceDetailPanelInput
}

"Input for updating event appearance"
input UpdateEventAppearanceInput {
  eventId: ID!
  card: EventAppearanceCardInput
  detail: EventAppearanceDetailInput
}

input EventJoinQuestionInput {
  type: JoinQuestionType!
  label: String!
  helpText: String
  required: Boolean!
  order: Int!
  options: [JoinQuestionOptionInput!]
  maxLength: Int
}

input JoinQuestionOptionInput {
  label: String!
}

input UpdateEventJoinQuestionsInput {
  eventId: ID!
  questions: [EventJoinQuestionInput!]!
}

# Feedback Questions bulk update
input EventFeedbackQuestionInput {
  type: FeedbackQuestionType!
  label: String!
  helpText: String
  required: Boolean!
  order: Int!
  options: [FeedbackQuestionOptionInput!]
  maxLength: Int
}

input FeedbackQuestionOptionInput {
  label: String!
}

input UpdateEventFeedbackQuestionsInput {
  eventId: ID!
  questions: [EventFeedbackQuestionInput!]!
}

# ------------------------------------------------------------------------------
# Event Favourites
# ------------------------------------------------------------------------------

"User's saved/favourite event"
type EventFavourite {
  id: ID!
  userId: ID!
  eventId: ID!
  createdAt: DateTime!

  user: User!
  event: Event!
}

"Paginated favourites result"
type EventFavouritesResult {
  items: [EventFavourite!]!
  pageInfo: PageInfo!
}

# ------------------------------------------------------------------------------
# Notification Preferences
# ------------------------------------------------------------------------------

"User notification preferences"
type NotificationPreference {
  id: ID!
  userId: ID!
  emailOnInvite: Boolean!
  emailOnJoinRequest: Boolean!
  emailOnMessage: Boolean!
  pushOnReminder: Boolean!
  inAppOnEverything: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!

  user: User!
}

# ------------------------------------------------------------------------------
# Mutes (Event & DM)
# ------------------------------------------------------------------------------

"Event mute status"
type EventMute {
  id: ID!
  eventId: ID!
  userId: ID!
  muted: Boolean!
  createdAt: DateTime!

  event: Event!
  user: User!
}

"DM thread mute status"
type DmMute {
  id: ID!
  threadId: ID!
  userId: ID!
  muted: Boolean!
  createdAt: DateTime!

  thread: DmThread!
  user: User!
}

# ------------------------------------------------------------------------------
# User Profile & Privacy Inputs
# ------------------------------------------------------------------------------

input UpdateUserProfileInput {
  displayName: String
  bioShort: String
  bioLong: String
  city: String
  country: String
  homeLat: Float
  homeLng: Float
  coverKey: String
  speaks: [String!]
  interests: [String!]
  preferredMode: Mode
  preferredMaxDistanceKm: Float
}

input UpdateUserPrivacyInput {
  dmPolicy: String
  showLastSeen: String
  showLocation: String
  showEvents: String
  showReviews: String
  showStats: String
  defaultAddressVisibility: AddressVisibility
  defaultMembersVisibility: MembersVisibility
}

input UpsertUserCategoryLevelInput {
  id: ID
  categoryId: ID!
  level: Level!
  notes: String
}

input UpsertUserAvailabilityInput {
  id: ID
  weekday: Int!
  startMin: Int!
  endMin: Int!
  tzSnap: String
}

input AddUserSocialLinkInput {
  provider: String!
  url: String!
}

# ------------------------------------------------------------------------------
# Agenda System
# ------------------------------------------------------------------------------

"Host type for agenda slots"
enum AgendaHostKind {
  USER
  MANUAL
}

"Host for an agenda slot"
type EventAgendaItemHost {
  id: ID!
  agendaItemId: ID!
  order: Int!
  kind: AgendaHostKind!

  "For USER kind: the user reference"
  userId: ID
  user: User

  "For MANUAL kind: manually entered name"
  name: String

  "For MANUAL kind: optional avatar URL"
  avatarUrl: String

  createdAt: DateTime!
  updatedAt: DateTime!
}

"Agenda slot for an event"
type EventAgendaItem {
  id: ID!
  eventId: ID!
  order: Int!
  title: String!
  description: String
  startAt: DateTime
  endAt: DateTime

  hosts: [EventAgendaItemHost!]!

  createdAt: DateTime!
  updatedAt: DateTime!
}

"Input for a single host in agenda slot"
input AgendaHostInput {
  kind: AgendaHostKind!
  "Required for USER kind"
  userId: ID
  "Required for MANUAL kind (max 120 chars)"
  name: String
  "Optional for MANUAL kind"
  avatarUrl: String
}

"Input for a single agenda slot"
input AgendaItemInput {
  "Title of the slot (3-120 chars)"
  title: String!
  "Description of the slot (max 1000 chars)"
  description: String
  "Start time (UTC) - if set, endAt must also be set"
  startAt: DateTime
  "End time (UTC) - must be after startAt"
  endAt: DateTime
  "Hosts for this slot (max 10)"
  hosts: [AgendaHostInput!]
}

"Input for bulk updating agenda"
input UpdateEventAgendaInput {
  eventId: ID!
  "Complete list of agenda items (replaces existing, max 50)"
  items: [AgendaItemInput!]!
}
