"""
Custom scalars
"""
scalar DateTime
scalar JSON
scalar JSONObject

# ------------------------------------------------------------------------------
# Enums
# ------------------------------------------------------------------------------

enum UsersSortBy {
  NAME
  CREATED_AT
  ROLE
  VERIFIED_AT
}

enum SortDir {
  ASC
  DESC
}

enum IntentsSortBy {
  START_AT
  CREATED_AT
  UPDATED_AT
  MEMBERS_COUNT
}

type PageInfo {
  total: Int!
  limit: Int!
  offset: Int!
  hasNext: Boolean!
  hasPrev: Boolean!
}

type UsersResult {
  items: [User!]!
  pageInfo: PageInfo!
}

type IntentsResult {
  items: [Intent!]!
  pageInfo: PageInfo!
}

type NotificationsResult {
  items: [Notification!]!
  pageInfo: PageInfo!
}

input UsersSort {
  by: UsersSortBy! = CREATED_AT
  dir: SortDir! = DESC
}

"Visibility of an intent"
enum Visibility {
  PUBLIC
  HIDDEN
}

"Meeting mode / capacity grouping"
enum Mode {
  ONE_TO_ONE
  GROUP
}

"How the meeting happens"
enum MeetingKind {
  ONSITE
  ONLINE
  HYBRID
}

"User role (global)"
enum Role {
  ADMIN
  MODERATOR
  USER
}

"Skill / difficulty level (enum array in DB)"
enum Level {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

"Per-intent role"
enum IntentMemberRole {
  OWNER
  MODERATOR
  PARTICIPANT
}

"Membership lifecycle status"
enum IntentMemberStatus {
  JOINED
  PENDING
  INVITED
  REJECTED
  BANNED
  LEFT
  KICKED
}

"High-level notification category/kind"
enum NotificationKind {
  INTENT_CREATED
  INTENT_UPDATED
  INTENT_CANCELED
  INTENT_DELETED
  INTENT_INVITE
  INTENT_MEMBERSHIP_APPROVED
  INTENT_MEMBERSHIP_REJECTED
  INTENT_REMINDER
  SYSTEM
}

"Polymorphic target for notifications (deep-link)"
enum NotificationEntity {
  INTENT
  MESSAGE
  PAYMENT
  INVOICE
  USER
  SYSTEM
  OTHER
}

"Intent dynamic status (computed on read)"
enum IntentStatus {
  ANY
  ONGOING
  STARTED
  FULL
  LOCKED
  AVAILABLE
  CANCELED
  DELETED
}

# ------------------------------------------------------------------------------
# Types
# ------------------------------------------------------------------------------

"Session"
type SessionUser {
  id: String!
  name: String!
  email: String!
  role: Role!
  imageUrl: String!
  verifiedAt: DateTime
}

"User"
type User {
  id: ID!
  email: String!
  name: String!
  imageUrl: String!
  role: Role!
  verifiedAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSeenAt: DateTime
}

"Category with translated names in JSON, e.g. { pl,de,en }"
type Category {
  id: ID!
  slug: String!
  # Prefer JSONObject to guarantee an object (key->value). Switch to JSON if you truly allow any JSON value.
  names: JSONObject!
  icon: String
  color: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Tag used for search/filtering"
type Tag {
  id: ID!
  label: String!
  slug: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Intent membership (user-in-intent)"
type IntentMember {
  id: ID!
  intentId: ID!
  userId: ID!
  role: IntentMemberRole!
  status: IntentMemberStatus!

  addedBy: User
  joinedAt: DateTime
  leftAt: DateTime
  note: String

  user: User!
}

"Intent"
type Intent {
  id: ID!
  title: String!
  description: String
  notes: String

  categories: [Category!]!
  tags: [Tag!]!

  visibility: Visibility!
  mode: Mode!
  min: Int!
  max: Int!

  startAt: DateTime!
  endAt: DateTime!
  allowJoinLate: Boolean!

  meetingKind: MeetingKind!
  onlineUrl: String

  lat: Float
  lng: Float
  address: String
  placeId: String
  radiusKm: Float

  # PostgreSQL enum[]
  levels: [Level!]!

  # Derived convenience (computed by resolver):
  owner: User
  # Access policy: OWNER/MODERATOR can see all statuses; others see JOINED only.
  members: [IntentMember!]!

  # Computed helpers
  joinedCount: Int!
  isFull: Boolean!
  hasStarted: Boolean!
  hasEnded: Boolean!

  # Cancellation (read-only state)
  canceledAt: DateTime
  canceledBy: User
  cancelReason: String
  isCanceled: Boolean!

  # Soft-delete (read-only state; typically set >= 30d after cancel)
  deletedAt: DateTime
  deletedBy: User
  deleteReason: String
  isDeleted: Boolean!

  createdAt: DateTime!
  updatedAt: DateTime!
}

"Notification stored in DB; polymorphic target"
type Notification {
  id: ID!
  kind: NotificationKind!
  title: String
  body: String
  data: JSON
  dedupeKey: String
  readAt: DateTime
  createdAt: DateTime!

  recipient: User!
  actor: User

  entityType: NotificationEntity!
  entityId: ID

  # Convenience: resolved when entityType=INTENT (join on intentId or entityId)
  intent: Intent
}

type NotificationBadgeChanged {
  recipientId: String!
}

# Simple aggregated counters per intent; useful for badges
type IntentMemberStats {
  joined: Int!
  pending: Int!
  invited: Int!
  rejected: Int!
  banned: Int!
  left: Int!
  kicked: Int!
}

# ------------------------------------------------------------------------------
# Inputs
# ------------------------------------------------------------------------------

input CreateCategoryInput {
  slug: String!
  names: JSONObject! # keep aligned with Category.names
  icon: String
  color: String
}

input UpdateCategoryInput {
  slug: String
  names: JSONObject
  icon: String
  color: String
}

input CreateTagInput {
  label: String!
  slug: String!
}

input UpdateTagInput {
  label: String
  slug: String
}

input LocationInput {
  lat: Float
  lng: Float
  address: String
  placeId: String
  radiusKm: Float
}

input CreateIntentInput {
  title: String!
  description: String
  notes: String

  categorySlugs: [String!]!
  tagSlugs: [String!]

  visibility: Visibility! = PUBLIC
  mode: Mode! = GROUP
  min: Int! = 2
  max: Int! = 50

  startAt: DateTime!
  endAt: DateTime!
  allowJoinLate: Boolean! = true

  meetingKind: MeetingKind! = ONSITE
  onlineUrl: String

  location: LocationInput
  levels: [Level!]
}

input UpdateIntentInput {
  title: String
  categorySlugs: [ID!]
  tagSlugs: [String!]
  description: String
  notes: String

  visibility: Visibility
  mode: Mode
  min: Int
  max: Int

  startAt: DateTime
  endAt: DateTime
  allowJoinLate: Boolean

  meetingKind: MeetingKind
  onlineUrl: String

  location: LocationInput
  levels: [Level!]
}

input InviteMemberInput {
  intentId: ID!
  userId: ID!
}

input ApproveMembershipInput {
  intentId: ID!
  userId: ID!
}

input RejectMembershipInput {
  intentId: ID!
  userId: ID!
  note: String
}

input KickMemberInput {
  intentId: ID!
  userId: ID!
  note: String
}

input UpdateMemberRoleInput {
  intentId: ID!
  userId: ID!
  role: IntentMemberRole!
}

# ------------------------------------------------------------------------------
# Queries
# ------------------------------------------------------------------------------

type Query {
  # Notifications feed; server should enforce recipientId === current user (unless admin policy applies).
  notifications(
    recipientId: ID!
    unreadOnly: Boolean = false
    entityType: NotificationEntity
    limit: Int = 50
    offset: Int = 0
  ): NotificationsResult!

  # Intents listing with rich filters. `status=FULL` requires counting JOINED vs `max` (handle in resolver).
  intents(
    limit: Int = 20
    offset: Int = 0
    visibility: Visibility
    ownerId: ID
    memberId: ID
    upcomingAfter: DateTime
    endingBefore: DateTime
    categorySlugs: [ID!]
    tagSlugs: [String!]
    levels: [Level!]
    kinds: [MeetingKind!]
    keywords: [String!]
    status: IntentStatus
    verifiedOnly: Boolean
    distanceKm: Int
    near: LocationInput
    sortBy: IntentsSortBy = START_AT
    sortDir: SortDir = ASC
  ): IntentsResult!

  intent(id: ID!): Intent

  # Intent members queries; resolvers should restrict visibility for non-mods to JOINED only.
  intentMembers(
    intentId: ID!
    status: IntentMemberStatus
    role: IntentMemberRole
    limit: Int = 50
    offset: Int = 0
  ): [IntentMember!]!

  intentMember(intentId: ID!, userId: ID!): IntentMember

  # Current user's memberships across intents
  myMemberships(
    status: IntentMemberStatus
    role: IntentMemberRole
    limit: Int = 50
    offset: Int = 0
  ): [IntentMember!]!

  # Aggregated counters (owner/mod get full distribution; others get joined-only)
  intentMemberStats(intentId: ID!): IntentMemberStats!

  categoriesBySlugs(slugs: [String!]!, limit: Int): [Category!]!
  categories(query: String, limit: Int = 50): [Category!]!
  category(id: ID, slug: String): Category

  tagsBySlugs(slugs: [String!]!, limit: Int): [Tag!]!
  tags(query: String, limit: Int = 50): [Tag!]!
  tag(id: ID, slug: String): Tag

  users(
    # pagination
    limit: Int = 50
    offset: Int = 0
    # filtering
    q: String
    role: Role
    verifiedOnly: Boolean
    # sorting
    sortBy: UsersSortBy = CREATED_AT
    sortDir: SortDir = DESC
  ): UsersResult!

  user(id: ID!): User

  me: SessionUser
}

# ------------------------------------------------------------------------------
# Mutations
# ------------------------------------------------------------------------------

type Mutation {
  # categories & tags
  createCategory(input: CreateCategoryInput!): Category!
  updateCategory(id: ID!, input: UpdateCategoryInput!): Category!
  deleteCategory(id: ID!): Boolean!

  createTag(input: CreateTagInput!): Tag!
  updateTag(id: ID!, input: UpdateTagInput!): Tag!
  deleteTag(id: ID!): Boolean!

  # intents
  createIntent(input: CreateIntentInput!): Intent!
  updateIntent(id: ID!, input: UpdateIntentInput!): Intent!
  deleteIntent(id: ID!): Boolean!
  cancelIntent(id: ID!, reason: String): Intent!

  # memberships (user endpoints)
  requestJoinIntent(intentId: ID!): Intent! # aliased to joinMember; returns full Intent
  cancelJoinRequest(intentId: ID!): Boolean!
  leaveIntent(intentId: ID!): Intent! # returns updated Intent
  # membership (owner/mod endpoints) â€” all return updated Intent
  inviteMember(input: InviteMemberInput!): Intent!
  approveMembership(input: ApproveMembershipInput!): Intent!
  rejectMembership(input: RejectMembershipInput!): Intent!
  kickMember(input: KickMemberInput!): Intent!
  updateMemberRole(input: UpdateMemberRoleInput!): Intent!

  # notifications
  addNotification(
    recipientId: ID!
    kind: NotificationKind! = SYSTEM
    title: String
    body: String
    data: JSON
    entityType: NotificationEntity! = OTHER
    entityId: ID
  ): Notification!

  markNotificationRead(id: ID!): Boolean!
  deleteNotification(id: ID!): Boolean!
  markAllNotificationsRead(recipientId: ID!): Int! # returns count
  # dev only
  devLogin(name: String!): SessionUser
  devLogout: Boolean!
}

# ------------------------------------------------------------------------------
# Subscriptions (scoped per recipient)
# ------------------------------------------------------------------------------

type Subscription {
  notificationAdded(recipientId: ID!): Notification!
  notificationBadgeChanged(recipientId: ID!): NotificationBadgeChanged!
}
