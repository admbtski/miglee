"""
Custom scalars
"""
scalar DateTime
scalar JSON
scalar JSONObject

# ------------------------------------------------------------------------------
# Enums
# ------------------------------------------------------------------------------

enum UsersSortBy {
  NAME
  CREATED_AT
  ROLE
  VERIFIED_AT
}

enum SortDir {
  ASC
  DESC
}

enum IntentsSortBy {
  START_AT
  CREATED_AT
  UPDATED_AT
  MEMBERS_COUNT
}

type PageInfo {
  total: Int!
  limit: Int!
  offset: Int!
  hasNext: Boolean!
  hasPrev: Boolean!
}

type CursorPageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type UsersResult {
  items: [User!]!
  pageInfo: PageInfo!
}

type IntentsResult {
  items: [Intent!]!
  pageInfo: PageInfo!
}

type NotificationsResult {
  items: [Notification!]!
  pageInfo: PageInfo!
}

type UserEventsResult {
  items: [Intent!]!
  total: Int!
}

type UserReviewsResult {
  items: [Review!]!
  total: Int!
}

input UsersSort {
  by: UsersSortBy! = CREATED_AT
  dir: SortDir! = DESC
}

"Visibility of an intent"
enum Visibility {
  PUBLIC
  HIDDEN
}

enum AddressVisibility {
  PUBLIC
  AFTER_JOIN
  HIDDEN
}

enum MembersVisibility {
  PUBLIC
  AFTER_JOIN
  HIDDEN
}

"Join mode - how users can join an intent"
enum JoinMode {
  OPEN
  REQUEST
  INVITE_ONLY
}

"Meeting mode / capacity grouping"
enum Mode {
  ONE_TO_ONE
  GROUP
}

"How the meeting happens"
enum MeetingKind {
  ONSITE
  ONLINE
  HYBRID
}

"User role (global)"
enum Role {
  ADMIN
  MODERATOR
  USER
}

"Skill / difficulty level (enum array in DB)"
enum Level {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

"Media asset purpose"
enum MediaPurpose {
  USER_AVATAR
  USER_COVER
  INTENT_COVER
  GALLERY_IMAGE
}

"Per-intent role"
enum IntentMemberRole {
  OWNER
  MODERATOR
  PARTICIPANT
}

"Membership lifecycle status"
enum IntentMemberStatus {
  JOINED
  PENDING
  INVITED
  REJECTED
  BANNED
  LEFT
  KICKED
  CANCELLED
  WAITLIST
}

"Member event type for audit log"
enum MemberEvent {
  JOIN
  REQUEST
  APPROVE
  REJECT
  LEAVE
  KICK
  BAN
  UNBAN
  INVITE
  ACCEPT_INVITE
  CANCEL_REQUEST
  WAITLIST
  WAITLIST_LEAVE
  WAITLIST_PROMOTE
}

"Join form question type"
enum JoinQuestionType {
  TEXT
  SINGLE_CHOICE
  MULTI_CHOICE
}

"High-level notification category/kind"
enum NotificationKind {
  INTENT_CREATED
  INTENT_UPDATED
  INTENT_CANCELED
  INTENT_DELETED
  INTENT_INVITE
  INTENT_MEMBERSHIP_APPROVED
  INTENT_MEMBERSHIP_REJECTED
  INTENT_REMINDER
  JOIN_REQUEST
  NEW_MESSAGE
  NEW_COMMENT
  NEW_REVIEW
  BANNED
  UNBANNED
  SYSTEM
  WAITLIST_JOINED
  WAITLIST_PROMOTED
}

"Polymorphic target for notifications (deep-link)"
enum NotificationEntity {
  INTENT
  MESSAGE
  PAYMENT
  INVOICE
  USER
  REVIEW
  SYSTEM
  OTHER
}

"Report entity type"
enum ReportEntity {
  INTENT
  COMMENT
  REVIEW
  USER
  MESSAGE
}

"Subscription plan tiers"
enum SubscriptionPlan {
  PLUS
  PRO
}

"User plan source"
enum UserPlanSource {
  SUBSCRIPTION
  ONE_OFF
}

"Billing period"
enum BillingPeriod {
  MONTHLY
  YEARLY
}

"Subscription status"
enum SubscriptionStatus {
  INCOMPLETE
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  PAUSED
}

"Intent/Event plan tiers"
enum IntentPlan {
  FREE
  PLUS
  PRO
}

"Sponsorship status"
enum SponsorshipStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELED
}

"User effective plan (computed from active periods)"
enum UserEffectivePlan {
  FREE
  PLUS
  PRO
}

"Intent dynamic status (computed on read)"
enum IntentStatus {
  ANY
  ONGOING
  PAST
  FULL
  LOCKED
  AVAILABLE
  CANCELED
  DELETED
}

"Intent lifecycle status filter for myIntents query"
enum IntentLifecycleStatus {
  UPCOMING
  ONGOING
  FINISHED
  CANCELED
  DELETED
}

"Why joining is locked (computed)"
enum JoinLockReason {
  FULL
  INVITE_ONLY
  NOT_OPEN_YET
  CUTOFF
  NO_LATE_JOIN
  LATE_CUTOFF
  MANUAL
  ENDED
  CANCELED
  DELETED
  OTHER
}

# ------------------------------------------------------------------------------
# Types
# ------------------------------------------------------------------------------

"Session"
type SessionUser {
  id: String!
  name: String!
  email: String!
  role: Role!
  avatarKey: String
  avatarBlurhash: String
  verifiedAt: DateTime
  profile: UserProfile

  # Billing & Subscriptions
  effectivePlan: UserEffectivePlan!
}

"Presigned upload URL response"
type PresignedUpload {
  uploadUrl: String!
  uploadKey: String!
  provider: String!
}

type ConfirmMediaUploadPayload {
  success: Boolean!
  mediaKey: String!
  mediaAssetId: ID!
}

"User"
type User {
  id: ID!
  email: String!
  name: String!
  avatarKey: String
  avatarBlurhash: String
  role: Role!
  verifiedAt: DateTime
  suspendedAt: DateTime
  suspensionReason: String
  createdAt: DateTime!
  updatedAt: DateTime!
  lastSeenAt: DateTime

  # Profile / Preferences
  locale: String
  tz: String
  acceptedTermsAt: DateTime
  acceptedMarketingAt: DateTime

  # Extended Profile (1:1 relations)
  profile: UserProfile
  privacy: UserPrivacy
  stats: UserStats

  # Collections
  socialLinks: [UserSocialLink!]!
  disciplines: [UserDiscipline!]!
  availability: [UserAvailability!]!
  badges: [UserBadge!]!

  # Billing & Subscriptions
  effectivePlan: UserEffectivePlan!
  planEndsAt: DateTime
  activeSubscription: UserSubscription
  activePlanPeriods: [UserPlanPeriod!]!
}

type UserProfile {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  displayName: String
  bioShort: String
  bioLong: String

  city: String
  country: String
  homeLat: Float
  homeLng: Float

  coverKey: String
  coverBlurhash: String

  speaks: [String!]!
  interests: [String!]!
  preferredMode: Mode
  preferredMaxDistanceKm: Float
}

type UserPrivacy {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  dmPolicy: String!
  showLastSeen: String!
  showLocation: String!
  showEvents: String!
  showReviews: String!
  showStats: String!

  defaultAddressVisibility: AddressVisibility!
  defaultMembersVisibility: MembersVisibility!
}

type UserStats {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  eventsCreated: Int!
  eventsJoined: Int!
  reviewsCount: Int!

  hostRatingAvg: Float
  attendeeRatingAvg: Float

  lastActiveAt: DateTime
}

type UserSocialLink {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  provider: String!
  url: String!
  verified: Boolean!
}

type UserDiscipline {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  categoryId: ID!
  category: Category!
  level: Level!
  notes: String
}

type UserAvailability {
  id: ID!
  userId: ID!
  createdAt: DateTime!
  updatedAt: DateTime!

  weekday: Int!
  startMin: Int!
  endMin: Int!
  tzSnap: String
}

type UserBadge {
  id: ID!
  userId: ID!
  createdAt: DateTime!

  slug: String!
  data: JSON
  earnedAt: DateTime!
}

# ==============================================================================
# Billing Types
# ==============================================================================

"User subscription (auto-renewable)"
type UserSubscription {
  id: ID!
  userId: ID!
  user: User!

  plan: SubscriptionPlan!
  billingPeriod: BillingPeriod!
  status: SubscriptionStatus!

  stripeCustomerId: String!
  stripeSubscriptionId: String
  stripePriceId: String

  currentPeriodStart: DateTime
  currentPeriodEnd: DateTime
  trialEndsAt: DateTime

  cancelAtPeriodEnd: Boolean!
  canceledAt: DateTime

  createdAt: DateTime!
  updatedAt: DateTime!
}

"User plan period (subscription or one-off)"
type UserPlanPeriod {
  id: ID!
  userId: ID!
  user: User!

  plan: SubscriptionPlan!
  source: UserPlanSource!
  billingPeriod: BillingPeriod!

  amount: Float!
  currency: String!

  stripeCustomerId: String
  stripeSubscriptionId: String
  stripePaymentIntentId: String
  stripeCheckoutSessionId: String

  startsAt: DateTime!
  endsAt: DateTime!

  createdAt: DateTime!
}

"Event/Intent sponsorship"
type EventSponsorship {
  id: ID!
  intentId: ID!
  sponsorId: ID!
  intent: Intent!
  sponsor: User!

  plan: IntentPlan!
  status: SponsorshipStatus!

  startsAt: DateTime
  endsAt: DateTime

  boostsTotal: Int!
  boostsUsed: Int!
  localPushesTotal: Int!
  localPushesUsed: Int!

  stripePaymentIntentId: String
  stripeCheckoutSessionId: String

  createdAt: DateTime!
  updatedAt: DateTime!
}

"Individual event sponsorship transaction (purchase, upgrade, reload)"
type EventSponsorshipPeriod {
  id: ID!
  intentId: ID!
  sponsorId: ID!

  plan: IntentPlan!
  actionType: String!

  boostsAdded: Int!
  localPushesAdded: Int!

  amount: Float!
  currency: String!

  stripeCustomerId: String
  stripePaymentIntentId: String
  stripeCheckoutSessionId: String

  createdAt: DateTime!

  intent: Intent!
  sponsor: User!
}

"Checkout session response"
type CheckoutSession {
  checkoutUrl: String!
  sessionId: String!
}

"Event sponsorship checkout response"
type EventSponsorshipCheckout {
  checkoutUrl: String!
  sessionId: String!
  sponsorshipId: ID!
}

"User plan info (computed)"
type UserPlanInfo {
  plan: UserEffectivePlan!
  planEndsAt: DateTime
  source: UserPlanSource
  billingPeriod: BillingPeriod
}

"Category with translated names in JSON, e.g. { pl,de,en }"
type Category {
  id: ID!
  slug: String!
  names: JSONObject!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Tag used for search/filtering"
type Tag {
  id: ID!
  label: String!
  slug: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Intent membership (user-in-intent)"
type IntentMember {
  id: ID!
  intentId: ID!
  userId: ID!
  role: IntentMemberRole!
  status: IntentMemberStatus!

  addedBy: User
  joinedAt: DateTime
  leftAt: DateTime
  note: String
  rejectReason: String

  user: User!
  intent: Intent!
  joinAnswers: [IntentJoinAnswer!]!
}

"Join form question for REQUEST mode"
type IntentJoinQuestion {
  id: ID!
  intentId: ID!
  order: Int!
  type: JoinQuestionType!
  label: String!
  helpText: String
  required: Boolean!
  options: JSON
  maxLength: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Join form answer from a user"
type IntentJoinAnswer {
  id: ID!
  intentId: ID!
  userId: ID!
  questionId: ID!
  answer: JSON!
  createdAt: DateTime!
  updatedAt: DateTime!
  question: IntentJoinQuestion!
  user: User!
}

"Join request with answers for host review"
type IntentJoinRequest {
  member: IntentMember!
  answers: [IntentJoinAnswer!]!
}

"Result type for paginated join requests"
type IntentJoinRequestsResult {
  items: [IntentJoinRequest!]!
  pageInfo: PageInfo!
}

"Intent"
type Intent {
  id: ID!
  title: String!
  description: String
  notes: String

  categories: [Category!]!
  tags: [Tag!]!

  visibility: Visibility!
  joinMode: JoinMode!
  mode: Mode!
  min: Int!
  max: Int!

  startAt: DateTime!
  endAt: DateTime!

  """
  Open joins X minutes before start (null = open immediately after publish)
  """
  joinOpensMinutesBeforeStart: Int

  """
  Close joins before start when now >= startAt - X minutes (null = no pre-start cutoff)
  """
  joinCutoffMinutesBeforeStart: Int

  """
  Allow joining after the event has started (late join)
  """
  allowJoinLate: Boolean!

  """
  Close late join when now >= startAt + X minutes (null = allowed until endAt)
  """
  lateJoinCutoffMinutesAfterStart: Int

  """
  Manual kill-switch for joins; overrides time/cutoff windows
  """
  joinManuallyClosed: Boolean!
  joinManuallyClosedAt: DateTime
  joinManuallyClosedBy: User
  joinManualCloseReason: String

  meetingKind: MeetingKind!
  onlineUrl: String

  lat: Float
  lng: Float
  address: String
  placeId: String
  radiusKm: Float

  # City information for filtering and grouping
  cityName: String
  cityPlaceId: String

  # PostgreSQL enum[]
  levels: [Level!]!

  # Media
  coverKey: String
  coverBlurhash: String

  addressVisibility: AddressVisibility!
  membersVisibility: MembersVisibility!

  # Derived counters
  joinedCount: Int!
  commentsCount: Int!
  messagesCount: Int!
  savedCount: Int! # How many users saved/favourited this intent (visible to owner/moderators)
  # Ownership
  ownerId: String
  owner: User

  # Access policy: OWNER/MODERATOR can see all statuses; others see JOINED only.
  members: [IntentMember!]!

  # ---------- Computed helpers ----------
  status: IntentStatus! # single, high-level status
  isFull: Boolean!
  hasStarted: Boolean!
  isFavourite: Boolean! # Whether the current user has favourited this intent
  hasEnded: Boolean!
  isOngoing: Boolean!
  canJoin: Boolean! # generic yes/no for primary CTA
  joinOpen: Boolean! # precise: can the viewer join *now*
  lockReason: JoinLockReason # when joinOpen=false, why
  isOnsite: Boolean!
  isOnline: Boolean!
  isHybrid: Boolean!
  withinLock: Boolean! # ← DODAJ TO
  # Cancellation (read-only state)
  canceledAt: DateTime
  canceledBy: User
  cancelReason: String
  isCanceled: Boolean!

  # Soft-delete (read-only state)
  deletedAt: DateTime
  deletedBy: User
  deleteReason: String
  isDeleted: Boolean!

  # Billing & Sponsorship
  sponsorshipPlan: IntentPlan!
  sponsorship: EventSponsorship
  boostedAt: DateTime # Last time event was boosted (for priority sorting)
  highlightColor: String # Custom highlight/ring color (hex format: #RRGGBB)
  # Relations
  inviteLinks: [IntentInviteLink!]!

  createdAt: DateTime!
  updatedAt: DateTime!
}

"Notification stored in DB; polymorphic target"
type Notification {
  id: ID!
  kind: NotificationKind!
  title: String
  body: String
  data: JSON
  dedupeKey: String
  readAt: DateTime
  createdAt: DateTime!

  recipient: User!
  actor: User

  entityType: NotificationEntity!
  entityId: ID

  # Convenience: resolved when entityType=INTENT (join on intentId or entityId)
  intent: Intent
}

type NotificationBadgeChanged {
  recipientId: String!
}

# Simple aggregated counters per intent; useful for badges
type IntentMemberStats {
  joined: Int!
  pending: Int!
  invited: Int!
  rejected: Int!
  banned: Int!
  left: Int!
  kicked: Int!
}

"""
User permissions for a specific intent.
Indicates what actions the current user can perform.
"""
type IntentPermissions {
  "User is the owner of the intent"
  isOwner: Boolean!
  "User is a moderator of the intent"
  isModerator: Boolean!
  "User is a participant (joined member)"
  isParticipant: Boolean!
  "User is an app-level admin"
  isAppAdmin: Boolean!
  "User is an app-level moderator"
  isAppModerator: Boolean!
  "User can access management interface"
  canManage: Boolean!
}

# ------------------------------------------------------------------------------
# Direct Messages (DM)
# ------------------------------------------------------------------------------

"Direct message thread between two users"
type DmThread {
  id: ID!
  aUserId: ID!
  bUserId: ID!
  pairKey: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastMessageAt: DateTime

  aUser: User!
  bUser: User!
  messages: [DmMessage!]!

  # Computed helpers
  unreadCount: Int!
  lastMessage: DmMessage
}

"Direct message in a thread"
type DmMessage {
  id: ID!
  threadId: ID!
  senderId: ID!
  content: String!
  replyToId: ID
  createdAt: DateTime!
  readAt: DateTime
  editedAt: DateTime
  deletedAt: DateTime

  thread: DmThread!
  sender: User!
  replyTo: DmMessage
  reactions: [MessageReaction!]!
}

"DM thread mute preference"
type DmMute {
  id: ID!
  threadId: ID!
  userId: ID!
  muted: Boolean!
  createdAt: DateTime!

  thread: DmThread!
  user: User!
}

"Paginated DM threads result"
type DmThreadsResult {
  items: [DmThread!]!
  pageInfo: PageInfo!
}

"Cursor-based DM messages connection"
type DmMessagesConnection {
  edges: [DmMessageEdge!]!
  pageInfo: CursorPageInfo!
}

type DmMessageEdge {
  node: DmMessage!
  cursor: String!
}

# ------------------------------------------------------------------------------
# Comments
# ------------------------------------------------------------------------------

"Comment on an intent (2-level threading)"
type Comment {
  id: ID!
  intentId: ID!
  authorId: ID!
  threadId: ID!
  parentId: ID
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deletedById: ID
  hiddenAt: DateTime
  hiddenById: ID

  intent: Intent!
  author: User!
  parent: Comment
  replies: [Comment!]!
  deletedBy: User
  hiddenBy: User

  # Computed
  repliesCount: Int!
}

"Paginated comments result"
type CommentsResult {
  items: [Comment!]!
  pageInfo: PageInfo!
}

# ------------------------------------------------------------------------------
# Reviews
# ------------------------------------------------------------------------------

"Review for an intent (1-5 stars)"
type Review {
  id: ID!
  intentId: ID!
  authorId: ID!
  rating: Int!
  content: String
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  deletedById: ID
  hiddenAt: DateTime
  hiddenById: ID

  intent: Intent!
  author: User!
  deletedBy: User
  hiddenBy: User
}

"Paginated reviews result"
type ReviewsResult {
  items: [Review!]!
  pageInfo: PageInfo!
}

"Review statistics for an intent"
type ReviewStats {
  totalCount: Int!
  averageRating: Float!
  ratingDistribution: [RatingCount!]!
}

"Rating count for a specific star rating"
type RatingCount {
  rating: Int!
  count: Int!
}

# ------------------------------------------------------------------------------
# Reports
# ------------------------------------------------------------------------------

"Report status"
enum ReportStatus {
  OPEN
  INVESTIGATING
  RESOLVED
  DISMISSED
}

"Report for content moderation"
type Report {
  id: ID!
  reporterId: ID!
  entity: ReportEntity!
  entityId: ID!
  reason: String!
  status: ReportStatus!
  createdAt: DateTime!
  resolvedAt: DateTime

  reporter: User!
}

"Paginated reports result"
type ReportsResult {
  items: [Report!]!
  pageInfo: PageInfo!
}

# ------------------------------------------------------------------------------
# Event Chat (Intent Chat Messages)
# ------------------------------------------------------------------------------

"Message in an intent chat room"
type IntentChatMessage {
  id: ID!
  intentId: ID!
  authorId: ID!
  content: String!
  replyToId: ID
  createdAt: DateTime!
  editedAt: DateTime
  deletedAt: DateTime

  intent: Intent!
  author: User!
  replyTo: IntentChatMessage
  reactions: [MessageReaction!]!

  # Computed
  isEdited: Boolean!
  isDeleted: Boolean!
}

"Aggregated reaction for a message"
type MessageReaction {
  emoji: String!
  count: Int!
  users: [User!]!
  reacted: Boolean!
}

"Paginated intent chat messages result"
type IntentChatMessagesResult {
  items: [IntentChatMessage!]!
  pageInfo: CursorPageInfo!
  hasMore: Boolean!
}

"Cursor-based Intent messages connection"
type IntentMessagesConnection {
  edges: [IntentMessageEdge!]!
  pageInfo: CursorPageInfo!
}

type IntentMessageEdge {
  node: IntentChatMessage!
  cursor: String!
}

# ------------------------------------------------------------------------------
# Map Clustering
# ------------------------------------------------------------------------------

"Bounding box for map viewport"
input BBoxInput {
  swLat: Float!
  swLon: Float!
  neLat: Float!
  neLon: Float!
}

"Filters for clustering map intents"
input ClusterFiltersInput {
  categorySlugs: [String!]
  levels: [Level!]
  verifiedOnly: Boolean
}

"Clustered point on the map representing one or more intents"
type Cluster {
  id: ID!
  latitude: Float!
  longitude: Float!
  count: Int!
  region: String!
  geoJson: JSON!
}

"Page metadata for region intents"
type PageMeta {
  page: Int!
  totalItems: Int!
  totalPages: Int!
  prevPage: Int
  nextPage: Int
}

"Paginated result for intents in a map region"
type RegionIntentPage {
  data: [Intent!]!
  meta: PageMeta!
}

# ------------------------------------------------------------------------------
# Inputs
# ------------------------------------------------------------------------------

input CreateCategoryInput {
  slug: String!
  names: JSONObject!
}

input UpdateCategoryInput {
  slug: String
  names: JSONObject
}

input CreateTagInput {
  label: String!
  slug: String!
}

input UpdateTagInput {
  label: String
  slug: String
}

input LocationInput {
  lat: Float
  lng: Float
  address: String
  placeId: String
  radiusKm: Float
  cityName: String
  cityPlaceId: String
}

input JoinQuestionInputData {
  type: JoinQuestionType!
  label: String!
  helpText: String
  required: Boolean = true
  options: JSON
  maxLength: Int
}

input CreateIntentInput {
  title: String!
  description: String
  notes: String

  categorySlugs: [String!]!
  tagSlugs: [String!]

  visibility: Visibility! = PUBLIC
  joinMode: JoinMode! = OPEN
  mode: Mode! = GROUP
  min: Int! = 2
  max: Int! = 50

  startAt: DateTime!
  endAt: DateTime!

  # Joins windows / cutoffs
  joinOpensMinutesBeforeStart: Int
  joinCutoffMinutesBeforeStart: Int
  allowJoinLate: Boolean! = true
  lateJoinCutoffMinutesAfterStart: Int

  meetingKind: MeetingKind! = ONSITE
  onlineUrl: String

  location: LocationInput
  levels: [Level!]

  # Privacy
  addressVisibility: AddressVisibility! = PUBLIC

  # Join form questions (optional)
  joinQuestions: [JoinQuestionInputData!]
  membersVisibility: MembersVisibility! = PUBLIC
}

input UpdateIntentInput {
  title: String
  categorySlugs: [String!]
  tagSlugs: [String!]
  description: String
  notes: String

  visibility: Visibility
  joinMode: JoinMode
  mode: Mode
  min: Int
  max: Int

  startAt: DateTime
  endAt: DateTime

  # Joins windows / cutoffs
  joinOpensMinutesBeforeStart: Int
  joinCutoffMinutesBeforeStart: Int
  allowJoinLate: Boolean
  lateJoinCutoffMinutesAfterStart: Int
  joinManuallyClosed: Boolean
  joinManualCloseReason: String

  meetingKind: MeetingKind
  onlineUrl: String

  location: LocationInput
  levels: [Level!]

  addressVisibility: AddressVisibility
  membersVisibility: MembersVisibility
}

input InviteMemberInput {
  intentId: ID!
  userId: ID!
}

input ApproveMembershipInput {
  intentId: ID!
  userId: ID!
}

input RejectMembershipInput {
  intentId: ID!
  userId: ID!
  note: String
}

input KickMemberInput {
  intentId: ID!
  userId: ID!
  note: String
}

input UpdateMemberRoleInput {
  intentId: ID!
  userId: ID!
  role: IntentMemberRole!
}

# NEW: Ban / Unban / Cancel pending-or-invite
input BanMemberInput {
  intentId: ID!
  userId: ID!
  note: String
}

input UnbanMemberInput {
  intentId: ID!
  userId: ID!
}

input CancelPendingOrInviteForUserInput {
  intentId: ID!
  userId: ID!
}

input PromoteFromWaitlistInput {
  intentId: ID!
  userId: ID!
}

# DM Inputs
input SendDmMessageInput {
  recipientId: ID!
  content: String!
  replyToId: ID
}

input UpdateDmMessageInput {
  content: String!
}

# Comment Inputs
input CreateCommentInput {
  intentId: ID!
  content: String!
  parentId: ID
}

input UpdateCommentInput {
  content: String!
}

# Review Inputs
input CreateReviewInput {
  intentId: ID!
  rating: Int!
  content: String
}

input UpdateReviewInput {
  rating: Int
  content: String
}

# Report Inputs
input CreateReportInput {
  entity: ReportEntity!
  entityId: ID!
  reason: String!
}

input UpdateReportStatusInput {
  status: ReportStatus!
}

# Event Chat Inputs
input SendIntentMessageInput {
  intentId: ID!
  content: String!
  replyToId: ID
}

input EditIntentMessageInput {
  content: String!
}

# Intent Invite Link Inputs
input CreateIntentInviteLinkInput {
  intentId: ID!
  maxUses: Int
  expiresAt: DateTime
}

# Join Form Inputs
input CreateJoinQuestionInput {
  intentId: ID!
  order: Int!
  type: JoinQuestionType!
  label: String!
  helpText: String
  required: Boolean = true
  options: JSON
  maxLength: Int
}

input UpdateJoinQuestionInput {
  order: Int
  label: String
  helpText: String
  required: Boolean
  options: JSON
  maxLength: Int
}

input JoinAnswerInput {
  questionId: ID!
  answer: JSON!
}

input RequestJoinIntentInput {
  intentId: ID!
  answers: [JoinAnswerInput!]!
}

input ApproveJoinRequestInput {
  intentId: ID!
  userId: ID!
}

input RejectJoinRequestInput {
  intentId: ID!
  userId: ID!
  reason: String
}

# Notification Preference Inputs
input UpdateNotificationPreferenceInput {
  emailOnInvite: Boolean
  emailOnJoinRequest: Boolean
  emailOnMessage: Boolean
  pushOnReminder: Boolean
  inAppOnEverything: Boolean
}

# ------------------------------------------------------------------------------
# Admin Input Types
# ------------------------------------------------------------------------------

input AdminUpdateUserInput {
  name: String
  email: String
  role: Role
  verifiedAt: DateTime
  locale: String
}

input AdminInviteUserInput {
  email: String!
  name: String
  role: Role! = USER
}

input AdminCreateUserInput {
  email: String!
  name: String
  role: Role! = USER
  verified: Boolean! = false
}

# Admin Intent Management Inputs
input AdminBulkUpdateIntentsInput {
  visibility: Visibility
  joinManuallyClosed: Boolean
  joinManualCloseReason: String
}

type AdminBulkUpdateResult {
  success: Int!
  failed: Int!
  errors: [String!]
}

# ------------------------------------------------------------------------------
# Billing Inputs
# ------------------------------------------------------------------------------

input CreateSubscriptionCheckoutInput {
  plan: SubscriptionPlan!
  billingPeriod: BillingPeriod!
  withTrial: Boolean = true
}

input CreateOneOffCheckoutInput {
  plan: SubscriptionPlan!
  billingPeriod: BillingPeriod!
}

input CreateEventSponsorshipCheckoutInput {
  intentId: ID!
  plan: IntentPlan!
  actionType: String
  actionPackageSize: Int
  highlightColor: String # Hex color for event highlight ring
}

# ------------------------------------------------------------------------------
# Queries
# ------------------------------------------------------------------------------

type Query {
  notifications(
    recipientId: ID!
    unreadOnly: Boolean = false
    entityType: NotificationEntity
    limit: Int = 50
    offset: Int = 0
  ): NotificationsResult!

  intents(
    limit: Int = 20
    offset: Int = 0
    visibility: Visibility
    joinMode: JoinMode
    joinModes: [JoinMode!]
    ownerId: ID
    memberId: ID
    upcomingAfter: DateTime
    endingBefore: DateTime
    categorySlugs: [String!]
    tagSlugs: [String!]
    levels: [Level!]
    kinds: [MeetingKind!]
    keywords: [String!]
    status: IntentStatus
    verifiedOnly: Boolean
    distanceKm: Float
    near: LocationInput
    sortBy: IntentsSortBy = START_AT
    sortDir: SortDir = ASC
  ): IntentsResult!

  intent(id: ID!): Intent

  intentMembers(
    intentId: ID!
    status: IntentMemberStatus
    role: IntentMemberRole
    limit: Int = 50
    offset: Int = 0
  ): [IntentMember!]!

  intentMember(intentId: ID!, userId: ID!): IntentMember

  myMemberships(
    status: IntentMemberStatus
    role: IntentMemberRole
    limit: Int = 50
    offset: Int = 0
  ): [IntentMember!]!

  """
  Get all intents where current user has membership, with flexible filtering.
  Supports filtering by membership role/status AND intent lifecycle status.
  """
  myIntents(
    "Filter by membership role (OWNER, MODERATOR, MEMBER)"
    role: IntentMemberRole
    "Filter by membership status (JOINED, PENDING, INVITED, etc.)"
    membershipStatus: IntentMemberStatus
    "Filter by intent lifecycle status (UPCOMING, ONGOING, FINISHED, etc.) - supports multiple"
    intentStatuses: [IntentLifecycleStatus!]
    "Pagination limit"
    limit: Int = 50
    "Pagination offset"
    offset: Int = 0
  ): [IntentMember!]!

  intentMemberStats(intentId: ID!): IntentMemberStats!

  """
  Check user's permissions for a specific intent.
  Returns permission flags for the current authenticated user.
  """
  intentPermissions(intentId: ID!): IntentPermissions!

  # Intent Invite Links
  intentInviteLinks(
    intentId: ID!
    includeRevoked: Boolean = false
  ): [IntentInviteLink!]!
  intentInviteLink(id: ID, code: String): IntentInviteLink
  validateInviteLink(code: String!): IntentInviteLinkValidation!

  # Intent Favourites
  myFavourites(limit: Int = 20, offset: Int = 0): IntentFavouritesResult!
  isFavourite(intentId: ID!): Boolean!

  # Join Form
  intentJoinQuestions(intentId: ID!): [IntentJoinQuestion!]!
  intentJoinRequests(
    intentId: ID!
    limit: Int = 20
    offset: Int = 0
  ): IntentJoinRequestsResult!
  myJoinRequests(
    status: IntentMemberStatus
    limit: Int = 20
    offset: Int = 0
  ): [IntentMember!]!

  # ==============================================================================
  # Billing & Subscriptions
  # ==============================================================================

  "Get user's current effective plan"
  myPlan: UserPlanInfo!

  "Get user's active subscription (if any)"
  mySubscription: UserSubscription

  "Get user's active plan periods"
  myPlanPeriods(limit: Int = 10): [UserPlanPeriod!]!

  "Get all event sponsorship transaction history for the current user"
  myEventSponsorships(limit: Int = 50): [EventSponsorshipPeriod!]!

  "Get event sponsorship for an intent"
  eventSponsorship(intentId: ID!): EventSponsorship

  categoriesBySlugs(slugs: [String!]!, limit: Int): [Category!]!
  categories(query: String, limit: Int = 50): [Category!]!
  category(id: ID, slug: String): Category
  checkCategorySlugAvailable(slug: String!): Boolean!
  getCategoryUsageCount(slug: String!): Int!

  tagsBySlugs(slugs: [String!]!, limit: Int): [Tag!]!
  tags(query: String, limit: Int = 50): [Tag!]!
  tag(id: ID, slug: String): Tag
  checkTagSlugAvailable(slug: String!): Boolean!
  getTagUsageCount(slug: String!): Int!

  users(
    limit: Int = 50
    offset: Int = 0
    q: String
    role: Role
    verifiedOnly: Boolean
    sortBy: UsersSortBy = CREATED_AT
    sortDir: SortDir = DESC
  ): UsersResult!

  user(id: ID, name: String): User

  me: SessionUser

  # DM Queries
  dmThreads(
    limit: Int = 20
    offset: Int = 0
    unreadOnly: Boolean = false
  ): DmThreadsResult!

  dmThread(id: ID, otherUserId: ID): DmThread

  dmMessages(
    threadId: ID!
    first: Int = 20
    before: String
    after: String
  ): DmMessagesConnection!

  # Comment Queries
  comments(
    intentId: ID!
    limit: Int = 50
    offset: Int = 0
    threadId: ID
    parentId: ID
  ): CommentsResult!

  comment(id: ID!): Comment

  # Review Queries
  reviews(
    intentId: ID!
    limit: Int = 20
    offset: Int = 0
    rating: Int
  ): ReviewsResult!

  review(id: ID!): Review

  reviewStats(intentId: ID!): ReviewStats!

  myReview(intentId: ID!): Review

  # Report Queries (admin only)
  reports(
    limit: Int = 20
    offset: Int = 0
    status: ReportStatus
    entity: ReportEntity
  ): ReportsResult!

  report(id: ID!): Report

  # Event Chat Queries
  intentMessages(
    intentId: ID!
    first: Int = 20
    before: String
    after: String
  ): IntentMessagesConnection!

  intentUnreadCount(intentId: ID!): Int!

  # User Block Queries
  myBlocks(limit: Int = 50, offset: Int = 0): UserBlocksResult!
  isBlocked(userId: ID!): Boolean!

  # Notification Preference Queries
  myNotificationPreferences: NotificationPreference!

  # Mute Queries
  intentMute(intentId: ID!): IntentMute
  dmMute(threadId: ID!): DmMute

  # Map Clustering Queries
  clusters(
    bbox: BBoxInput!
    zoom: Float!
    filters: ClusterFiltersInput
  ): [Cluster!]!

  regionIntents(
    region: String!
    page: Int = 1
    perPage: Int = 20
    filters: ClusterFiltersInput
  ): RegionIntentPage!

  # Admin User Management Queries
  adminUserComments(userId: ID!, limit: Int, offset: Int): AdminCommentsResult!
  adminUserReviews(userId: ID!, limit: Int, offset: Int): AdminReviewsResult!
  adminUserMemberships(
    userId: ID!
    limit: Int
    offset: Int
  ): AdminMembershipsResult!
  adminUserIntents(userId: ID!, limit: Int, offset: Int): AdminIntentsResult!
  adminUserDmThreads(
    userId: ID!
    limit: Int
    offset: Int
  ): AdminDmThreadsResult!
  adminUserNotifications(
    userId: ID!
    limit: Int
    offset: Int
  ): NotificationsResult!

  userEvents(userId: ID!, limit: Int, offset: Int): UserEventsResult!
  userReviews(userId: ID!, limit: Int, offset: Int): UserReviewsResult!

  # Admin Content Moderation Queries
  adminComments(
    limit: Int
    offset: Int
    intentId: ID
    userId: ID
  ): AdminCommentsResult!
  adminReviews(
    limit: Int
    offset: Int
    intentId: ID
    userId: ID
    rating: Int
  ): AdminReviewsResult!
}

# ------------------------------------------------------------------------------
# Admin Result Types
# ------------------------------------------------------------------------------

type AdminCommentsResult {
  items: [Comment!]!
  pageInfo: AdminPageInfo!
}

type AdminReviewsResult {
  items: [Review!]!
  pageInfo: AdminPageInfo!
}

type AdminMembershipsResult {
  items: [AdminMembershipItem!]!
  pageInfo: AdminPageInfo!
}

type AdminIntentsResult {
  items: [AdminIntentItem!]!
  pageInfo: AdminPageInfo!
}

type AdminDmThreadsResult {
  items: [AdminDmThreadItem!]!
  pageInfo: AdminPageInfo!
}

type AdminPageInfo {
  total: Int!
  hasMore: Boolean!
}

type AdminMembershipItem {
  id: ID!
  status: IntentMemberStatus!
  role: IntentMemberRole!
  joinedAt: DateTime
  intent: AdminIntentSummary!
}

type AdminIntentItem {
  id: ID!
  title: String!
  startAt: DateTime!
  status: String!
  joinedCount: Int!
}

type AdminDmThreadItem {
  id: ID!
  createdAt: DateTime!
  lastMessageAt: DateTime
  otherUser: User!
  messageCount: Int!
}

type AdminIntentSummary {
  id: ID!
  title: String!
  startAt: DateTime!
}

# ------------------------------------------------------------------------------
# Mutations
# ------------------------------------------------------------------------------
type Mutation {
  # categories & tags
  createCategory(input: CreateCategoryInput!): Category!
  updateCategory(id: ID!, input: UpdateCategoryInput!): Category!
  deleteCategory(id: ID!): Boolean!

  createTag(input: CreateTagInput!): Tag!
  updateTag(id: ID!, input: UpdateTagInput!): Tag!
  deleteTag(id: ID!): Boolean!

  # intents
  createIntent(input: CreateIntentInput!): Intent!
  updateIntent(id: ID!, input: UpdateIntentInput!): Intent!
  deleteIntent(id: ID!): Boolean!
  cancelIntent(id: ID!, reason: String): Intent!
  closeIntentJoin(intentId: ID!, reason: String): Intent!
  reopenIntentJoin(intentId: ID!): Intent!

  # memberships (user endpoints)
  requestJoinIntent(intentId: ID!): Intent! # Deprecated: use requestJoinIntentWithAnswers
  requestJoinIntentWithAnswers(input: RequestJoinIntentInput!): Intent!
  cancelJoinRequest(intentId: ID!): Boolean!
  leaveIntent(intentId: ID!): Intent!
  acceptInvite(intentId: ID!): Intent!

  # waitlist (user endpoints)
  joinWaitlistOpen(intentId: ID!): Intent!
  leaveWaitlist(intentId: ID!): Boolean!

  # memberships (owner/mod endpoints)
  inviteMember(input: InviteMemberInput!): Intent!
  approveMembership(input: ApproveMembershipInput!): Intent! # Deprecated: use approveJoinRequest
  approveJoinRequest(input: ApproveJoinRequestInput!): Intent!
  rejectMembership(input: RejectMembershipInput!): Intent! # Deprecated: use rejectJoinRequest
  rejectJoinRequest(input: RejectJoinRequestInput!): Intent!
  kickMember(input: KickMemberInput!): Intent!
  updateMemberRole(input: UpdateMemberRoleInput!): Intent!
  banMember(input: BanMemberInput!): Intent!
  unbanMember(input: UnbanMemberInput!): Intent!
  promoteFromWaitlist(input: PromoteFromWaitlistInput!): Intent!
  cancelPendingOrInviteForUser(
    input: CancelPendingOrInviteForUserInput!
  ): Boolean!

  # Intent Invite Links
  createIntentInviteLink(input: CreateIntentInviteLinkInput!): IntentInviteLink!
  updateIntentInviteLink(
    id: ID!
    input: UpdateIntentInviteLinkInput!
  ): IntentInviteLink!
  revokeIntentInviteLink(id: ID!): IntentInviteLink!
  deleteIntentInviteLink(id: ID!): Boolean!
  joinByInviteLink(code: String!): Intent!

  # Intent Favourites
  toggleFavourite(intentId: ID!): IntentFavourite

  # Join Form Management
  createJoinQuestion(input: CreateJoinQuestionInput!): IntentJoinQuestion!
  updateJoinQuestion(
    id: ID!
    input: UpdateJoinQuestionInput!
  ): IntentJoinQuestion!
  deleteJoinQuestion(id: ID!): Boolean!
  reorderJoinQuestions(
    intentId: ID!
    questionIds: [ID!]!
  ): [IntentJoinQuestion!]!

  # notifications
  addNotification(
    recipientId: ID!
    kind: NotificationKind! = SYSTEM
    title: String
    body: String
    data: JSON
    entityType: NotificationEntity! = OTHER
    entityId: ID
  ): Notification!

  markNotificationRead(id: ID!): Boolean!
  deleteNotification(id: ID!): Boolean!
  markAllNotificationsRead(recipientId: ID!): Int!

  # DM
  sendDmMessage(input: SendDmMessageInput!): DmMessage!
  updateDmMessage(id: ID!, input: UpdateDmMessageInput!): DmMessage!
  deleteDmMessage(id: ID!): Boolean!
  markDmMessageRead(id: ID!): Boolean!
  markDmThreadRead(threadId: ID!): Int!
  deleteDmThread(id: ID!): Boolean! # ← DODANE
  createOrGetDmThread(userId: ID!): DmThread!
  publishDmTyping(threadId: ID!, isTyping: Boolean!): Boolean!

  # Comments
  createComment(input: CreateCommentInput!): Comment!
  updateComment(id: ID!, input: UpdateCommentInput!): Comment!
  deleteComment(id: ID!): Boolean!

  # Moderation: Hide/unhide comments (soft delete for moderation)
  hideComment(id: ID!): Boolean!
  unhideComment(id: ID!): Boolean!

  # Reviews
  createReview(input: CreateReviewInput!): Review!
  updateReview(id: ID!, input: UpdateReviewInput!): Review!
  deleteReview(id: ID!): Boolean!

  # Moderation: Hide/unhide reviews (soft delete for moderation)
  hideReview(id: ID!): Boolean!
  unhideReview(id: ID!): Boolean!

  # Reports
  createReport(input: CreateReportInput!): Report!
  updateReportStatus(id: ID!, input: UpdateReportStatusInput!): Report!
  deleteReport(id: ID!): Boolean!

  # Event Chat
  sendIntentMessage(input: SendIntentMessageInput!): IntentChatMessage!
  editIntentMessage(id: ID!, input: EditIntentMessageInput!): IntentChatMessage!
  deleteIntentMessage(id: ID!, soft: Boolean = true): Boolean!
  markIntentChatRead(intentId: ID!, at: DateTime): Boolean!
  publishIntentTyping(intentId: ID!, isTyping: Boolean!): Boolean!

  # Reactions
  addDmReaction(messageId: ID!, emoji: String!): Boolean!
  removeDmReaction(messageId: ID!, emoji: String!): Boolean!
  addIntentReaction(messageId: ID!, emoji: String!): Boolean!
  removeIntentReaction(messageId: ID!, emoji: String!): Boolean!

  # User Blocks
  blockUser(userId: ID!): UserBlock! # ← DODANE
  unblockUser(userId: ID!): Boolean! # ← DODANE
  # Notification Preferences
  updateNotificationPreferences(
    input: UpdateNotificationPreferenceInput!
  ): NotificationPreference! # ← DODANE
  # Mutes
  muteIntent(intentId: ID!, muted: Boolean!): IntentMute!
  muteDmThread(threadId: ID!, muted: Boolean!): DmMute!

  # Admin - User Management
  adminUpdateUser(id: ID!, input: AdminUpdateUserInput!): User!
  adminDeleteUser(id: ID!, anonymize: Boolean): Boolean!
  adminInviteUser(input: AdminInviteUserInput!): User!
  adminCreateUser(input: AdminCreateUserInput!): User!
  adminSuspendUser(id: ID!, reason: String): User!
  adminUnsuspendUser(id: ID!): User!

  # Admin - Intent Management
  adminUpdateIntent(id: ID!, input: UpdateIntentInput!): Intent!
  adminDeleteIntent(id: ID!): Boolean!
  adminCancelIntent(id: ID!, reason: String): Intent!
  adminRestoreIntent(id: ID!): Intent!
  adminChangeIntentOwner(intentId: ID!, newOwnerId: ID!): Intent!
  adminBulkUpdateIntents(
    ids: [ID!]!
    input: AdminBulkUpdateIntentsInput!
  ): AdminBulkUpdateResult!

  # Admin - Content Moderation
  adminDeleteComment(id: ID!): Boolean!
  adminDeleteReview(id: ID!): Boolean!

  # Admin - Intent Member Management
  adminUpdateMemberRole(input: UpdateMemberRoleInput!): Intent!
  adminKickMember(input: KickMemberInput!): Intent!
  adminBanMember(input: BanMemberInput!): Intent!
  adminUnbanMember(input: UnbanMemberInput!): Intent!

  # User Profile & Privacy
  updateUserProfile(input: UpdateUserProfileInput!): UserProfile!
  updateUserPrivacy(input: UpdateUserPrivacyInput!): UserPrivacy!

  # User Disciplines
  upsertUserDiscipline(input: UpsertUserDisciplineInput!): UserDiscipline!
  removeUserDiscipline(id: ID!): Boolean!

  # User Availability
  upsertUserAvailability(input: UpsertUserAvailabilityInput!): UserAvailability!
  removeUserAvailability(id: ID!): Boolean!

  # User Social Links
  addUserSocialLink(input: AddUserSocialLinkInput!): UserSocialLink!
  removeUserSocialLink(id: ID!): Boolean!

  # Media Upload
  getUploadUrl(purpose: MediaPurpose!, entityId: ID!): PresignedUpload!
  confirmMediaUpload(
    purpose: MediaPurpose!
    entityId: ID!
    uploadKey: String!
  ): ConfirmMediaUploadPayload!

  # ==============================================================================
  # Billing & Subscriptions
  # ==============================================================================

  "Create checkout session for user subscription (auto-renewable)"
  createSubscriptionCheckout(
    input: CreateSubscriptionCheckoutInput!
  ): CheckoutSession!

  "Create checkout session for one-off payment (month or year)"
  createOneOffCheckout(input: CreateOneOffCheckoutInput!): CheckoutSession!

  "Create checkout session for event sponsorship"
  createEventSponsorshipCheckout(
    input: CreateEventSponsorshipCheckoutInput!
  ): EventSponsorshipCheckout!

  "Cancel user subscription (at period end or immediately)"
  cancelSubscription(immediately: Boolean = false): Boolean!

  "Reactivate a subscription that was set to cancel at period end"
  reactivateSubscription: Boolean!

  "Get receipt URL for a user plan period"
  getUserPlanReceiptUrl(periodId: ID!): String

  "Get receipt URL for an event sponsorship period"
  getEventSponsorshipReceiptUrl(periodId: ID!): String

  "Use a boost for event sponsorship"
  useBoost(intentId: ID!): Boolean!

  "Use a local push notification for event sponsorship"
  useLocalPush(intentId: ID!): Boolean!

  "Update intent highlight color"
  updateIntentHighlightColor(intentId: ID!, color: String): Boolean!

  # dev only
  devLogin(name: String!): SessionUser
  devLogout: Boolean!
}

# ------------------------------------------------------------------------------
# Subscriptions (scoped per recipient)
# ------------------------------------------------------------------------------

type Subscription {
  notificationAdded(recipientId: ID!): Notification!
  notificationBadgeChanged(recipientId: ID!): NotificationBadgeChanged!

  # Event Chat Subscriptions
  intentMessageAdded(intentId: ID!): IntentChatMessage!
  intentMessageUpdated(intentId: ID!): IntentChatMessage!
  intentMessageDeleted(intentId: ID!): MessageDeletedEvent!
  intentTyping(intentId: ID!): TypingIndicator!
  intentReactionAdded(intentId: ID!): ReactionEvent!

  # DM Subscriptions
  dmMessageAdded(threadId: ID!): DmMessage!
  dmMessageUpdated(threadId: ID!): DmMessage!
  dmMessageDeleted(threadId: ID!): MessageDeletedEvent!
  dmTyping(threadId: ID!): TypingIndicator!
  dmReactionAdded(threadId: ID!): ReactionEvent!
}

# Reaction event for subscriptions
type ReactionEvent {
  messageId: ID!
  userId: ID!
  emoji: String!
  action: ReactionAction!
}

enum ReactionAction {
  ADD
  REMOVE
}

# Message deleted event for subscriptions
type MessageDeletedEvent {
  messageId: ID!
  deletedAt: DateTime!
}

# Typing indicator for real-time presence
type TypingIndicator {
  userId: ID!
  isTyping: Boolean!
}

# ------------------------------------------------------------------------------
# User Blocks
# ------------------------------------------------------------------------------

"User block for preventing interactions"
type UserBlock {
  id: ID!
  blockerId: ID!
  blockedId: ID!
  createdAt: DateTime!

  blocker: User!
  blocked: User!
}

"Paginated user blocks result"
type UserBlocksResult {
  items: [UserBlock!]!
  pageInfo: PageInfo!
}

# ------------------------------------------------------------------------------
# Intent Invite Links
# ------------------------------------------------------------------------------

"Invite link for intent with usage limits"
type IntentInviteLink {
  id: ID!
  intentId: ID!
  code: String!
  maxUses: Int
  usedCount: Int!
  expiresAt: DateTime
  createdById: ID
  createdBy: User
  label: String
  revokedAt: DateTime
  revokedById: ID
  revokedBy: User
  createdAt: DateTime!
  updatedAt: DateTime

  intent: Intent!
  uses: [IntentInviteLinkUsage!]!

  # Computed
  isExpired: Boolean!
  isMaxedOut: Boolean!
  isValid: Boolean!
  isRevoked: Boolean!
}

"Usage record for invite link"
type IntentInviteLinkUsage {
  id: ID!
  linkId: ID!
  userId: ID!
  usedAt: DateTime!
  user: User!
}

"Paginated invite links result"
type IntentInviteLinksResult {
  items: [IntentInviteLink!]!
  pageInfo: PageInfo!
}

"Validation result for invite link"
type IntentInviteLinkValidation {
  valid: Boolean!
  reason: String
  link: IntentInviteLink
  intent: Intent
}

"Input for creating invite link"
input CreateIntentInviteLinkInput {
  intentId: ID!
  label: String
  maxUses: Int
  expiresAt: DateTime
}

"Input for updating invite link"
input UpdateIntentInviteLinkInput {
  label: String
  maxUses: Int
  expiresAt: DateTime
}

# ------------------------------------------------------------------------------
# Intent Favourites
# ------------------------------------------------------------------------------

"User's saved/favourite intent"
type IntentFavourite {
  id: ID!
  userId: ID!
  intentId: ID!
  createdAt: DateTime!

  user: User!
  intent: Intent!
}

"Paginated favourites result"
type IntentFavouritesResult {
  items: [IntentFavourite!]!
  pageInfo: PageInfo!
}

# ------------------------------------------------------------------------------
# Notification Preferences
# ------------------------------------------------------------------------------

"User notification preferences"
type NotificationPreference {
  id: ID!
  userId: ID!
  emailOnInvite: Boolean!
  emailOnJoinRequest: Boolean!
  emailOnMessage: Boolean!
  pushOnReminder: Boolean!
  inAppOnEverything: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!

  user: User!
}

# ------------------------------------------------------------------------------
# Mutes (Intent & DM)
# ------------------------------------------------------------------------------

"Intent mute status"
type IntentMute {
  id: ID!
  intentId: ID!
  userId: ID!
  muted: Boolean!
  createdAt: DateTime!

  intent: Intent!
  user: User!
}

"DM thread mute status"
type DmMute {
  id: ID!
  threadId: ID!
  userId: ID!
  muted: Boolean!
  createdAt: DateTime!

  thread: DmThread!
  user: User!
}

# ------------------------------------------------------------------------------
# User Profile & Privacy Inputs
# ------------------------------------------------------------------------------

input UpdateUserProfileInput {
  displayName: String
  bioShort: String
  bioLong: String
  city: String
  country: String
  homeLat: Float
  homeLng: Float
  coverKey: String
  speaks: [String!]
  interests: [String!]
  preferredMode: Mode
  preferredMaxDistanceKm: Float
}

input UpdateUserPrivacyInput {
  dmPolicy: String
  showLastSeen: String
  showLocation: String
  showEvents: String
  showReviews: String
  showStats: String
  defaultAddressVisibility: AddressVisibility
  defaultMembersVisibility: MembersVisibility
}

input UpsertUserDisciplineInput {
  id: ID
  categoryId: ID!
  level: Level!
  notes: String
}

input UpsertUserAvailabilityInput {
  id: ID
  weekday: Int!
  startMin: Int!
  endMin: Int!
  tzSnap: String
}

input AddUserSocialLinkInput {
  provider: String!
  url: String!
}
