// =============================================================================
// Prisma Client & Datasource
// =============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
/**
 * Enums
 */
// =============================================================================

enum Visibility {
  PUBLIC
  HIDDEN
}

enum AddressVisibility {
  PUBLIC
  AFTER_JOIN
  HIDDEN
}

enum MembersVisibility {
  PUBLIC
  AFTER_JOIN
  HIDDEN
}

enum JoinMode {
  OPEN
  REQUEST
  INVITE_ONLY
}

enum Mode {
  ONE_TO_ONE
  GROUP
  CUSTOM
}

enum MeetingKind {
  ONSITE
  ONLINE
  HYBRID
}

enum Role {
  ADMIN
  MODERATOR
  USER
}

enum Level {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum EventMemberRole {
  OWNER
  MODERATOR
  PARTICIPANT
}

enum EventMemberStatus {
  JOINED
  PENDING
  INVITED
  REJECTED
  BANNED
  LEFT
  KICKED
  CANCELLED // User cancelled their own pending request
  WAITLIST // User is on the waiting list (event is full)
}

enum NotificationKind {
  // Event lifecycle
  EVENT_CREATED
  EVENT_UPDATED
  EVENT_CANCELED
  EVENT_DELETED

  // Membership
  EVENT_INVITE
  EVENT_INVITE_ACCEPTED
  EVENT_MEMBERSHIP_APPROVED
  EVENT_MEMBERSHIP_REJECTED
  EVENT_MEMBER_KICKED
  EVENT_MEMBER_ROLE_CHANGED
  JOIN_REQUEST
  BANNED
  UNBANNED

  // Waitlist
  WAITLIST_JOINED
  WAITLIST_PROMOTED

  // Reviews & Feedback
  EVENT_REVIEW_RECEIVED
  EVENT_FEEDBACK_RECEIVED
  EVENT_FEEDBACK_REQUEST
  REVIEW_HIDDEN

  // Comments
  EVENT_COMMENT_ADDED
  COMMENT_REPLY
  COMMENT_HIDDEN

  // Messages
  NEW_MESSAGE
  NEW_COMMENT
  NEW_REVIEW
  EVENT_CHAT_MESSAGE

  // Check-in
  CHECKIN_CONFIRMED // Check-in successful
  CHECKIN_REJECTED // Check-in was rejected by organizer
  CHECKIN_BLOCKED // Check-in was blocked
  CHECKIN_UNBLOCKED // Check-in was unblocked

  // Reminders & System
  EVENT_REMINDER
  SYSTEM
}

enum NotificationEntity {
  EVENT
  MESSAGE
  PAYMENT
  INVOICE
  USER
  REVIEW
  SYSTEM
  OTHER
}

enum SponsorshipStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELED
}

enum SubscriptionPlan {
  PLUS
  PRO
}

enum UserPlanSource {
  SUBSCRIPTION // auto-renewable subscription
  ONE_OFF // one-time payment (month / year)
}

enum BillingPeriod {
  MONTHLY
  YEARLY
}

enum SubscriptionStatus {
  INCOMPLETE
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  PAUSED
}

enum EventPlan {
  FREE
  PLUS
  PRO
}

enum PublicationStatus {
  DRAFT // Event is not published yet, only visible to owner/moderators
  PUBLISHED // Event is live and visible according to visibility settings
  SCHEDULED // Event is scheduled to be published at a specific time
}

// Check-in related enums
enum CheckinMethod {
  SELF_MANUAL // User clicks "I'm here" button
  MODERATOR_PANEL // Organizer checks in from panel
  EVENT_QR // Scan event's shared QR code
  USER_QR // Organizer scans user's individual QR code
}

enum CheckinAction {
  CHECK_IN // User/moderator performed check-in
  UNCHECK // Check-in was removed
  REJECT // Check-in was rejected (stronger than uncheck)
  BLOCK_ALL // All check-in methods blocked for user
  UNBLOCK_ALL // All check-in methods unblocked
  BLOCK_METHOD // Specific method blocked
  UNBLOCK_METHOD // Specific method unblocked
  QR_TOKEN_ROTATED // QR token was regenerated
  METHODS_CHANGED // Event check-in configuration changed
  ATTEMPT_DENIED // Check-in attempt was denied (logged but not executed)
}

enum CheckinSource {
  USER // Action initiated by the user themselves
  MODERATOR // Action initiated by event owner/moderator
  SYSTEM // Automatic action (e.g., status change invalidation)
}

enum CheckinResult {
  SUCCESS // Action completed successfully
  DENIED // Action was denied (permission/validation issue)
  NOOP // No operation (idempotent call, already in desired state)
}

enum MemberEvent {
  JOIN
  REQUEST
  APPROVE
  REJECT
  LEAVE
  KICK
  BAN
  UNBAN
  INVITE
  ACCEPT_INVITE
  CANCEL_REQUEST // User cancelled their own pending request
  WAITLIST // User joined the waitlist
  WAITLIST_LEAVE // User left the waitlist
  WAITLIST_PROMOTE // User was promoted from waitlist
}

enum JoinQuestionType {
  TEXT
  SINGLE_CHOICE
  MULTI_CHOICE
}

enum FeedbackQuestionType {
  TEXT
  SINGLE_CHOICE
  MULTI_CHOICE
}

enum ReportEntity {
  EVENT
  COMMENT
  REVIEW
  USER
  MESSAGE
  CHAT
}

// =============================================================================
/**
 * Models
 */
// =============================================================================

model User {
  id                     String    @id @default(cuid())
  email                  String    @unique
  name                   String    @unique
  avatarKey              String? // Key to MediaAsset for avatar
  role                   Role      @default(USER)
  verifiedAt             DateTime?
  suspendedAt            DateTime? // Admin suspension
  suspensionReason       String? // Reason for suspension
  deletedAt              DateTime? // Soft delete timestamp
  deletedReason          String? // Reason for account deletion
  restorationToken       String? // Token for self-service restoration
  restorationTokenExpiry DateTime? // Expiry for restoration token
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  lastSeenAt             DateTime?

  // Profile / Preferences
  locale              String    @default("en") // 'en' | 'pl' | 'de' - user's preferred language
  timezone            String    @default("UTC") // IANA timezone, e.g. "Europe/Warsaw", "America/New_York"
  acceptedTermsAt     DateTime?
  acceptedMarketingAt DateTime?

  // Relations
  notifications         Notification[]
  actedNotifications    Notification[]     @relation("NotificationActor")
  eventMembers          EventMember[]
  addedMemberships      EventMember[]      @relation("EventMemberAddedBy")
  canceledEvents        Event[]            @relation("EventCanceledBy")
  deletedEvents         Event[]            @relation("EventDeletedBy")
  ownedEvents           Event[]            @relation("EventOwner")
  memberEventsAsSubject EventMemberEvent[] @relation("MemberEventUser")
  memberEventsAsActor   EventMemberEvent[] @relation("MemberEventActor")

  // NEW: events z rƒôcznie zamkniƒôtymi zapisami
  joinClosedEvents Event[] @relation("EventJoinClosedBy")

  // Social
  commentsWritten Comment[] @relation("CommentAuthor")
  commentsDeleted Comment[] @relation("CommentDeletedBy")
  commentsHidden  Comment[] @relation("CommentHiddenBy")
  reviewsWritten  Review[]  @relation("ReviewAuthor")
  reviewsDeleted  Review[]  @relation("ReviewDeletedBy")
  reviewsHidden   Review[]  @relation("ReviewHiddenBy")

  // DM
  dmThreadsA         DmThread[]          @relation("DmA")
  dmThreadsB         DmThread[]          @relation("DmB")
  dmMessages         DmMessage[]
  dmMutes            DmMute[]
  dmReads            DmRead[] // last read per thread
  dmMessageReactions DmMessageReaction[] @relation("DmMessageReactions")

  // Event Chat
  eventChatMessages         EventChatMessage[]
  eventChatReads            EventChatRead[]
  eventChatMessageReactions EventChatMessageReaction[] @relation("EventChatMessageReactions")

  // Mutes / Prefs
  notificationPreference NotificationPreference?
  eventMutes             EventMute[]

  // Moderation
  reportsFiled    Report[]    @relation("ReportAuthor")
  blocksInitiated UserBlock[] @relation("Blocker")
  blocksReceived  UserBlock[] @relation("Blocked")

  // Ownership transfers
  ownershipTransfersFrom  EventOwnershipTransfer[] @relation("IotFrom")
  ownershipTransfersTo    EventOwnershipTransfer[] @relation("IotTo")
  ownershipTransfersActed EventOwnershipTransfer[] @relation("IotActor")

  // Invite Links
  createdInviteLinks EventInviteLink[]      @relation("EventInviteLinkCreatedBy")
  revokedInviteLinks EventInviteLink[]      @relation("EventInviteLinkRevokedBy")
  inviteLinkUsages   EventInviteLinkUsage[]

  // Favourites
  eventFavourites EventFavourite[]

  // Agenda
  agendaHostings EventAgendaItemHost[] @relation("AgendaItemHosts")

  // Check-in
  checkinLogsAsActor EventCheckinLog[] @relation("CheckinLogActor")
  checkinRejections  EventMember[]     @relation("EventMemberCheckinRejectedBy")

  // Monetization
  subscriptions           UserSubscription[]
  planPeriods             UserPlanPeriod[]
  eventSponsorships       EventSponsorship[]       @relation("SponsorUser")
  eventSponsorshipPeriods EventSponsorshipPeriod[] @relation("EventSponsorshipPeriods")

  // Profile & Privacy
  profile        UserProfile?
  privacy        UserPrivacy?
  stats          UserStats?
  socialLinks    UserSocialLink[]
  categoryLevels UserCategoryLevel[]
  availability   UserAvailability[]
  badges         UserBadge[]

  @@index([email])
  @@index([name])
  @@index([role])
  @@index([lastSeenAt])
  @@map("users")
}

model Category {
  id        String   @id @default(cuid())
  slug      String   @unique
  names     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  events             Event[]
  userCategoryLevels UserCategoryLevel[]

  @@index([slug])
  @@map("categories")
}

model Tag {
  id        String   @id @default(cuid())
  label     String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  events Event[]

  @@index([label])
  @@index([slug])
  @@map("tags")
}

model Event {
  id          String  @id @default(cuid())
  title       String
  description String?
  notes       String?

  categories Category[]
  tags       Tag[]

  visibility Visibility @default(PUBLIC)
  joinMode   JoinMode   @default(OPEN)

  mode Mode @default(GROUP)
  min  Int?
  max  Int?

  startAt DateTime
  endAt   DateTime

  joinOpensMinutesBeforeStart     Int?
  joinCutoffMinutesBeforeStart    Int?
  allowJoinLate                   Boolean   @default(true)
  lateJoinCutoffMinutesAfterStart Int?
  joinManuallyClosed              Boolean   @default(false)
  joinManuallyClosedAt            DateTime?
  joinManuallyClosedById          String?
  joinManuallyClosedBy            User?     @relation("EventJoinClosedBy", fields: [joinManuallyClosedById], references: [id], onDelete: SetNull)
  joinManualCloseReason           String?

  meetingKind MeetingKind @default(ONSITE)
  onlineUrl   String?

  lat      Float?
  lng      Float?
  address  String?
  placeId  String?
  radiusKm Float?

  // City information for filtering and grouping
  cityName    String? // e.g. "Warszawa", "≈Å√≥d≈∫"
  cityPlaceId String? // Google Place ID for the city (locality)

  // Note: PostGIS 'geom' column (geography(Point, 4326)) is managed via SQL migration
  // and not directly in this schema. See migration: 20251104220540_add_postgis_geom
  // The 'geom' column is automatically populated from lat/lng and has a GIST index.
  geom Unsupported("geography(Point, 4326)")?

  levels Level[] @default([])

  // Media
  coverKey String? // Key to MediaAsset for cover image

  addressVisibility AddressVisibility @default(PUBLIC)
  membersVisibility MembersVisibility @default(PUBLIC)

  // Derived counters
  joinedCount   Int @default(0)
  commentsCount Int @default(0)
  messagesCount Int @default(0)
  savedCount    Int @default(0) // How many users saved/favourited this event

  // Sponsorship / Plan
  sponsorshipPlan EventPlan @default(FREE) // Effective plan of the event (Free/Plus/Pro)
  boostedAt       DateTime? // Last time the event was boosted (used for sorting)

  // Publication status
  status             PublicationStatus @default(DRAFT) // DRAFT, PUBLISHED, SCHEDULED
  publishedAt        DateTime? // When the event was published (null for drafts)
  scheduledPublishAt DateTime? // When the event should be auto-published (for SCHEDULED status)

  // Ownership
  ownerId            String?
  owner              User?                    @relation("EventOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  ownershipTransfers EventOwnershipTransfer[]

  // Cancellation / deletion
  canceledAt   DateTime?
  canceledById String?
  canceledBy   User?     @relation("EventCanceledBy", fields: [canceledById], references: [id], onDelete: SetNull)
  cancelReason String?

  deletedAt    DateTime?
  deletedById  String?
  deletedBy    User?     @relation("EventDeletedBy", fields: [deletedById], references: [id], onDelete: SetNull)
  deleteReason String?

  // Relations
  members            EventMember[]
  memberEvents       EventMemberEvent[]
  notifications      Notification[]
  comments           Comment[]
  reviews            Review[]
  sponsorship        EventSponsorship?
  sponsorshipPeriods EventSponsorshipPeriod[] @relation("EventSponsorshipPeriods")
  inviteLinks        EventInviteLink[]
  mutes              EventMute[]
  favourites         EventFavourite[]

  // Event Chat relations
  chatMessages EventChatMessage[]
  chatReads    EventChatRead[]

  // Join Form relations
  joinQuestions EventJoinQuestion[]
  joinAnswers   EventJoinAnswer[]

  // Feedback relations
  feedbackQuestions EventFeedbackQuestion[]
  feedbackAnswers   EventFeedbackAnswer[]

  // FAQ relations
  faqs EventFaq[]

  // Appearance customization
  appearance EventAppearance?

  // Agenda
  agendaItems EventAgendaItem[]

  // Check-in configuration
  checkinEnabled        Boolean         @default(false) // Enable/disable check-in feature for this event
  enabledCheckinMethods CheckinMethod[] @default([]) // Which check-in methods are enabled
  eventCheckinToken     String?         @unique // Token for EVENT_QR method (shared QR code)

  // Check-in relations
  checkinLogs EventCheckinLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes
  @@index([startAt])
  @@index([endAt])
  @@index([boostedAt])
  @@index([visibility])
  @@index([joinMode])
  @@index([mode])
  @@index([meetingKind])
  @@index([lat, lng])
  @@index([placeId])
  @@index([canceledAt])
  @@index([deletedAt])
  @@index([createdAt])
  @@index([visibility, meetingKind, startAt])
  @@index([visibility, startAt, joinedCount])
  @@index([joinManuallyClosed, startAt])
  @@index([joinOpensMinutesBeforeStart])
  @@index([joinCutoffMinutesBeforeStart])
  @@index([lateJoinCutoffMinutesAfterStart])
  @@index([status])
  @@index([status, visibility, startAt])
  @@index([scheduledPublishAt])
  @@map("events")
}

model EventMember {
  id      String @id @default(cuid())
  eventId String
  userId  String

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  role   EventMemberRole   @default(PARTICIPANT)
  status EventMemberStatus @default(PENDING)

  addedById String?
  addedBy   User?   @relation("EventMemberAddedBy", fields: [addedById], references: [id], onDelete: SetNull)

  joinedAt     DateTime?
  leftAt       DateTime?
  note         String?
  rejectReason String? // Reason for rejection (max 500 chars, enforced in app)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations to join form answers
  joinAnswers EventJoinAnswer[]

  // Relations to feedback answers
  feedbackAnswers EventFeedbackAnswer[]

  // Check-in fields
  isCheckedIn        Boolean         @default(false) // Is user currently checked in (derived from checkinMethods.length > 0)
  checkinMethods     CheckinMethod[] @default([]) // Active check-in methods for this user
  lastCheckinAt      DateTime? // Last successful check-in timestamp
  memberCheckinToken String?         @unique // Unique token for USER_QR method

  // Check-in blocking
  checkinBlockedAll     Boolean         @default(false) // Block all check-in methods
  checkinBlockedMethods CheckinMethod[] @default([]) // List of blocked methods

  // Check-in rejection tracking
  lastCheckinRejectionReason String? // Reason for last rejection (visible to user if showToUser flag)
  lastCheckinRejectedAt      DateTime? // When was last rejection
  lastCheckinRejectedById    String? // Who rejected
  lastCheckinRejectedBy      User?     @relation("EventMemberCheckinRejectedBy", fields: [lastCheckinRejectedById], references: [id], onDelete: SetNull)

  // Check-in log relation
  checkinLogs EventCheckinLog[]

  @@unique([eventId, userId])
  @@index([userId, status])
  @@index([eventId, status])
  @@index([eventId, role])
  @@index([eventId, status, role])
  @@index([userId, createdAt])
  @@index([eventId, isCheckedIn]) // For filtering checked-in members
  @@index([eventId, status, isCheckedIn]) // Combined index for member lists
  @@map("event_members")
}

model EventMemberEvent {
  id        String      @id @default(cuid())
  eventId   String
  userId    String
  actorId   String?
  kind      MemberEvent
  note      String?
  createdAt DateTime    @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  user  User  @relation("MemberEventUser", fields: [userId], references: [id], onDelete: Cascade)
  actor User? @relation("MemberEventActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([eventId, createdAt])
  @@index([userId, createdAt])
  @@map("event_member_events")
}

model Comment {
  id        String   @id @default(cuid())
  eventId   String
  authorId  String
  threadId  String // root comment id; dla root√≥w = id (ustaw w app)
  parentId  String?
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Soft delete by author
  deletedAt   DateTime?
  deletedById String?
  deletedBy   User?     @relation("CommentDeletedBy", fields: [deletedById], references: [id], onDelete: SetNull)

  // Hidden by moderator
  hiddenAt   DateTime?
  hiddenById String?
  hiddenBy   User?     @relation("CommentHiddenBy", fields: [hiddenById], references: [id], onDelete: SetNull)

  event   Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  author  User      @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  parent  Comment?  @relation("CommentParent", fields: [parentId], references: [id], onDelete: SetNull)
  replies Comment[] @relation("CommentParent")

  @@index([eventId, createdAt])
  @@index([authorId, createdAt])
  @@index([eventId, threadId, createdAt])
  @@index([parentId, createdAt])
  @@index([deletedById])
  @@index([hiddenById])
  @@map("comments")
}

model Review {
  id        String   @id @default(cuid())
  eventId   String
  authorId  String
  rating    Int // enforce 1..5 in SQL CHECK (migration)
  content   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Soft delete by author
  deletedAt   DateTime?
  deletedById String?
  deletedBy   User?     @relation("ReviewDeletedBy", fields: [deletedById], references: [id], onDelete: SetNull)

  // Hidden by moderator
  hiddenAt   DateTime?
  hiddenById String?
  hiddenBy   User?     @relation("ReviewHiddenBy", fields: [hiddenById], references: [id], onDelete: SetNull)

  event  Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  author User  @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  @@unique([eventId, authorId])
  @@index([eventId, createdAt])
  @@index([authorId, createdAt])
  @@index([eventId, rating, createdAt])
  @@index([deletedById])
  @@index([hiddenById])
  @@map("reviews")
}

model DmThread {
  id            String    @id @default(cuid())
  aUserId       String
  bUserId       String
  pairKey       String    @unique // `${min(aUserId,bUserId)}|${max(aUserId,bUserId)}`
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastMessageAt DateTime?

  aUser    User        @relation("DmA", fields: [aUserId], references: [id], onDelete: Cascade)
  bUser    User        @relation("DmB", fields: [bUserId], references: [id], onDelete: Cascade)
  messages DmMessage[]
  mutes    DmMute[]
  reads    DmRead[] // last read markers per user

  @@index([aUserId, bUserId])
  @@index([lastMessageAt])
  @@map("dm_threads")
}

model DmMessage {
  id        String    @id @default(cuid())
  threadId  String
  senderId  String
  content   String
  replyToId String?
  createdAt DateTime  @default(now())
  readAt    DateTime?
  editedAt  DateTime? // added for parity with event chat
  deletedAt DateTime?

  thread    DmThread            @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender    User                @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reactions DmMessageReaction[]

  replyTo DmMessage?  @relation("DmMessageReply", fields: [replyToId], references: [id], onDelete: SetNull)
  replies DmMessage[] @relation("DmMessageReply")

  @@index([threadId, createdAt])
  @@index([senderId, createdAt])
  @@map("dm_messages")
}

model DmMessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String // üëç, ‚ù§Ô∏è, üòÇ, üòÆ, üò¢, üôè
  createdAt DateTime @default(now())

  message DmMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User      @relation("DmMessageReactions", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("dm_message_reactions")
}

model Notification {
  id String @id @default(cuid())

  kind NotificationKind

  recipientId String
  recipient   User   @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  actorId String?
  actor   User?   @relation("NotificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  entityType NotificationEntity
  entityId   String?

  eventId String?
  event   Event?  @relation(fields: [eventId], references: [id], onDelete: SetNull)

  title     String?
  body      String?
  data      Json?
  dedupeKey String?

  readAt    DateTime?
  createdAt DateTime  @default(now())

  @@unique([recipientId, dedupeKey])
  @@index([recipientId, readAt])
  @@index([recipientId, createdAt])
  @@index([recipientId, entityType, readAt])
  @@index([recipientId, kind, readAt])
  @@index([eventId])
  @@map("notifications")
}

// ========================== Event Chat ==========================

model EventChatMessage {
  id        String    @id @default(cuid())
  eventId   String
  authorId  String
  content   String
  replyToId String?
  createdAt DateTime  @default(now())
  editedAt  DateTime?
  deletedAt DateTime?

  event     Event                      @relation(fields: [eventId], references: [id], onDelete: Cascade)
  author    User                       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  reactions EventChatMessageReaction[]

  replyTo EventChatMessage?  @relation("EventChatReply", fields: [replyToId], references: [id], onDelete: SetNull)
  replies EventChatMessage[] @relation("EventChatReply")

  @@index([eventId, createdAt])
  @@index([authorId, createdAt])
  @@map("event_chat_messages")
}

model EventChatMessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String // üëç, ‚ù§Ô∏è, üòÇ, üòÆ, üò¢, üôè
  createdAt DateTime @default(now())

  message EventChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User             @relation("EventChatMessageReactions", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("event_chat_message_reactions")
}

model EventChatRead {
  id         String   @id @default(cuid())
  eventId    String
  userId     String
  lastReadAt DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([userId, lastReadAt])
  @@map("event_chat_reads")
}

// ========================== DM Reads ==========================

model DmRead {
  id         String   @id @default(cuid())
  threadId   String
  userId     String
  lastReadAt DateTime @default(now())

  thread DmThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@index([userId, lastReadAt])
  @@map("dm_reads")
}

// ========================== Moderation ==========================

model UserBlock {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker User @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockedId])
  @@map("user_blocks")
}

model Report {
  id         String       @id @default(cuid())
  reporterId String
  entity     ReportEntity
  entityId   String
  reason     String
  status     String       @default("OPEN")
  createdAt  DateTime     @default(now())
  resolvedAt DateTime?

  reporter User @relation("ReportAuthor", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([entity, entityId])
  @@index([status, createdAt])
  @@map("reports")
}

// ========================== Monetization ==========================

model UserSubscription {
  id     String @id @default(cuid())
  userId String

  plan          SubscriptionPlan
  billingPeriod BillingPeriod      @default(MONTHLY)
  status        SubscriptionStatus @default(INCOMPLETE)

  stripeCustomerId     String
  stripeSubscriptionId String  @unique
  stripePriceId        String?

  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  trialEndsAt        DateTime?

  cancelAtPeriodEnd Boolean   @default(false)
  canceledAt        DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([currentPeriodEnd])
  @@map("user_subscriptions")
}

model UserPlanPeriod {
  id     String @id @default(cuid())
  userId String

  plan   SubscriptionPlan // PLUS / PRO
  source UserPlanSource // SUBSCRIPTION / ONE_OFF

  billingPeriod BillingPeriod // MONTHLY / YEARLY

  // Payment information
  amount   Float  @default(0) // Amount paid
  currency String @default("pln") // Currency code (pln, eur, usd, etc.)

  // Links to Stripe ‚Äì depends on source
  stripeCustomerId        String?
  stripeSubscriptionId    String? // for SUBSCRIPTION
  stripePaymentEventId    String? // for ONE_OFF
  stripeCheckoutSessionId String? // optional for debug/trace

  startsAt DateTime
  endsAt   DateTime

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, endsAt])
  @@index([stripeSubscriptionId])
  @@index([stripePaymentEventId])
  @@map("user_plan_periods")
}

model EventSponsorship {
  id        String @id @default(cuid())
  eventId   String @unique // 1:1 with Event
  sponsorId String // sponsoring user (usually owner)

  plan   EventPlan // PLUS / PRO (FREE doesn't make sense but enum is shared)
  status SponsorshipStatus @default(PENDING)

  startsAt DateTime?
  endsAt   DateTime?

  boostsTotal      Int @default(0)
  boostsUsed       Int @default(0)
  localPushesTotal Int @default(0)
  localPushesUsed  Int @default(0)

  stripePaymentEventId    String?
  stripeCheckoutSessionId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event   Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  sponsor User  @relation("SponsorUser", fields: [sponsorId], references: [id], onDelete: Cascade)

  periods EventSponsorshipPeriod[] // History of all transactions

  @@index([plan, status])
  @@index([endsAt])
  @@map("event_sponsorships")
}

/// Tracks individual event sponsorship purchases (new, reload, upgrade)
/// Similar to UserPlanPeriod but for event sponsorships
model EventSponsorshipPeriod {
  id        String @id @default(cuid())
  eventId   String
  sponsorId String

  plan       EventPlan // Plan purchased (PLUS/PRO)
  actionType String    @default("new") // 'new', 'reload', 'upgrade'

  boostsAdded      Int @default(0) // How many boosts this purchase added
  localPushesAdded Int @default(0) // How many pushes this purchase added

  amount   Float // Amount paid in PLN
  currency String @default("pln")

  stripeCustomerId        String?
  stripePaymentEventId    String?
  stripeCheckoutSessionId String?

  createdAt DateTime @default(now())

  eventSponsorship EventSponsorship @relation(fields: [eventId], references: [eventId], onDelete: Cascade, map: "event_sponsorship_periods_sponsorshipId_fkey")
  event            Event            @relation("EventSponsorshipPeriods", fields: [eventId], references: [id], onDelete: Cascade)
  sponsor          User             @relation("EventSponsorshipPeriods", fields: [sponsorId], references: [id], onDelete: Cascade)

  @@index([sponsorId])
  @@index([eventId])
  @@index([createdAt])
  @@map("event_sponsorship_periods")
}

model PaymentEvent {
  id          String    @id @default(cuid())
  provider    String    @default("stripe")
  eventId     String    @unique
  type        String
  payload     Json
  receivedAt  DateTime  @default(now())
  processedAt DateTime?
  success     Boolean   @default(false)
  attempt     Int       @default(1)
  lastError   String?

  @@index([type, receivedAt])
  @@map("payment_events")
}

// ========================== Invites ==========================

model EventInviteLink {
  id      String @id @default(cuid())
  eventId String
  code    String @unique // Unique code used in URL (/i/:code)

  /// Maximum number of successful uses (null = unlimited)
  maxUses Int?

  /// Count of successful uses (actual memberships created/updated)
  usedCount Int @default(0)

  /// Expiration date (null = no expiration)
  expiresAt DateTime?

  /// Who created this invite link
  createdById String?
  createdBy   User?   @relation("EventInviteLinkCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  /// Optional label for the link (e.g. "Friends from work")
  label String?

  /// Soft deletion
  revokedAt   DateTime?
  revokedById String?
  revokedBy   User?     @relation("EventInviteLinkRevokedBy", fields: [revokedById], references: [id], onDelete: SetNull)

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  event Event                  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  uses  EventInviteLinkUsage[]

  @@index([code])
  @@index([eventId])
  @@index([eventId, revokedAt])
  @@index([eventId, expiresAt])
  @@index([expiresAt])
  @@map("event_invite_links")
}

/// Track who used which invite link
model EventInviteLinkUsage {
  id     String   @id @default(cuid())
  linkId String
  userId String
  usedAt DateTime @default(now())

  /// IP address (optional, for security/analytics)
  ipAddress String?

  /// User agent (optional, for analytics)
  userAgent String?

  link EventInviteLink @relation(fields: [linkId], references: [id], onDelete: Cascade)
  user User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([linkId, userId]) // One user can only use a link once
  @@index([linkId])
  @@index([userId])
  @@index([usedAt])
  @@map("event_invite_link_usages")
}

/// User's saved/favourite events
model EventFavourite {
  id        String   @id @default(cuid())
  userId    String
  eventId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId]) // One user can only favourite an event once
  @@index([userId, createdAt]) // For user's favourites list sorted by when saved
  @@index([eventId]) // For analytics: how many users saved this event
  @@map("event_favourites")
}

// ========================== Preferences & Mutes ==========================

model NotificationPreference {
  id                 String   @id @default(cuid())
  userId             String   @unique
  emailOnInvite      Boolean  @default(true)
  emailOnJoinRequest Boolean  @default(true)
  emailOnMessage     Boolean  @default(false)
  pushOnReminder     Boolean  @default(true)
  inAppOnEverything  Boolean  @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model EventMute {
  id        String   @id @default(cuid())
  eventId   String
  userId    String
  muted     Boolean  @default(true)
  createdAt DateTime @default(now())

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@map("event_mutes")
}

model DmMute {
  id        String   @id @default(cuid())
  threadId  String
  userId    String
  muted     Boolean  @default(true)
  createdAt DateTime @default(now())

  thread DmThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@map("dm_mutes")
}

// ========================== Ownership transfers ==========================

model EventOwnershipTransfer {
  id         String   @id @default(cuid())
  eventId    String
  fromUserId String
  toUserId   String
  actorId    String?
  reason     String?
  createdAt  DateTime @default(now())

  event    Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  fromUser User  @relation("IotFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User  @relation("IotTo", fields: [toUserId], references: [id], onDelete: Cascade)
  actor    User? @relation("IotActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([eventId, createdAt])
  @@map("event_ownership_transfers")
}

// =============================================================================
/**
 * User Profile & Privacy Models
 */
// =============================================================================

model UserProfile {
  id        String   @id @default(cuid())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Public display
  displayName String?
  bioShort    String? // max 200 chars
  bioLong     String? // max 1000 chars

  // Location
  city    String?
  country String?
  homeLat Float?
  homeLng Float?

  // Media
  coverKey String? // Key to MediaAsset for cover image

  // Preferences
  speaks                 String[] // ["pl", "en"]
  interests              String[] // tags
  preferredMode          Mode? // ONE_TO_ONE / GROUP
  preferredMaxDistanceKm Float?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model UserPrivacy {
  id        String   @id @default(cuid())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // DM policy
  dmPolicy String @default("ALL") // ALL / MEMBERS / INVITE_ONLY / NONE

  // Visibility settings
  showLastSeen String @default("ALL") // ALL / MEMBERS / HIDDEN
  showLocation String @default("CITY") // CITY / APPROX / HIDDEN
  showEvents   String @default("ALL") // ALL / MEMBERS / SELF
  showReviews  String @default("ALL") // ALL / MEMBERS / SELF
  showStats    String @default("ALL") // ALL / MEMBERS / SELF

  // Default visibility for new events
  defaultAddressVisibility AddressVisibility @default(PUBLIC)
  defaultMembersVisibility MembersVisibility @default(PUBLIC)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_privacy")
}

model UserStats {
  id        String   @id @default(cuid())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Denormalized counters
  eventsCreated Int @default(0)
  eventsJoined  Int @default(0)
  reviewsCount  Int @default(0)

  // Ratings
  hostRatingAvg     Float?
  attendeeRatingAvg Float?

  // Activity
  lastActiveAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_stats")
}

model UserSocialLink {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  provider String // instagram / facebook / strava / x / discord / website
  url      String
  verified Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
  @@map("user_social_links")
}

model UserCategoryLevel {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  categoryId String
  level      Level
  notes      String?

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([userId, categoryId])
  @@index([userId])
  @@index([categoryId])
  @@map("user_category_levels")
}

model UserAvailability {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  weekday  Int // 0 = Monday, 6 = Sunday
  startMin Int // 0-1440 (minutes from midnight)
  endMin   Int // 0-1440
  tzSnap   String? // Timezone snapshot

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, weekday])
  @@map("user_availability")
}

model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())

  slug     String // e.g. "first_event", "10_events", "verified"
  data     Json? // Additional metadata
  earnedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, slug])
  @@index([userId])
  @@map("user_badges")
}

// =============================================================================
/**
 * Join Form Models - Questions and Answers for REQUEST mode
 */
// =============================================================================

model EventJoinQuestion {
  id      String           @id @default(cuid())
  eventId String
  order   Int              @default(0) // Display order (0-based)
  type    JoinQuestionType @default(TEXT)

  label     String // Question text (max 200 chars, enforced in app)
  helpText  String? // Optional help text (max 200 chars, enforced in app)
  required  Boolean @default(true)
  options   Json? // For CHOICE types: array of {label: string, value?: string}
  maxLength Int? // For TEXT type: max answer length

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event   Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  answers EventJoinAnswer[]

  @@index([eventId, order])
  @@map("event_join_questions")
}

model EventJoinAnswer {
  id         String @id @default(cuid())
  eventId    String
  userId     String
  questionId String

  answer Json // TEXT: string, SINGLE_CHOICE: string, MULTI_CHOICE: string[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event    Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  question EventJoinQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  member   EventMember       @relation(fields: [eventId, userId], references: [eventId, userId], onDelete: Cascade)

  @@unique([eventId, userId, questionId])
  @@index([eventId, userId])
  @@index([questionId])
  @@map("event_join_answers")
}

// =============================================================================
/**
 * Feedback System
 * Post-event feedback questions and answers
 */
// =============================================================================

model EventFeedbackQuestion {
  id      String               @id @default(cuid())
  eventId String
  order   Int                  @default(0) // Display order (0-based)
  type    FeedbackQuestionType @default(TEXT)

  label     String // Question text (max 200 chars, enforced in app)
  helpText  String? // Optional help text (max 200 chars, enforced in app)
  required  Boolean @default(false)
  options   Json? // For CHOICE types: array of {label: string, value?: string}
  maxLength Int? // For TEXT type: max answer length

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event   Event                 @relation(fields: [eventId], references: [id], onDelete: Cascade)
  answers EventFeedbackAnswer[]

  @@index([eventId, order])
  @@map("event_feedback_questions")
}

model EventFeedbackAnswer {
  id         String @id @default(cuid())
  eventId    String
  userId     String
  questionId String

  answer Json // TEXT: string, SINGLE_CHOICE: string, MULTI_CHOICE: string[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event    Event                 @relation(fields: [eventId], references: [id], onDelete: Cascade)
  question EventFeedbackQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  member   EventMember           @relation(fields: [eventId, userId], references: [eventId, userId], onDelete: Cascade)

  @@unique([eventId, userId, questionId])
  @@index([eventId, userId])
  @@index([questionId])
  @@map("event_feedback_answers")
}

// =============================================================================
/**
 * FAQ System
 * Frequently Asked Questions for events
 */
// =============================================================================

model EventFaq {
  id      String @id @default(cuid())
  eventId String
  order   Int    @default(0) // Display order (0-based)

  question String // FAQ question text (max 500 chars, enforced in app)
  answer   String // FAQ answer text (max 2000 chars, enforced in app)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId, order])
  @@map("event_faqs")
}

// =============================================================================
/**
 * Media Assets - Images with variants on-demand
 */
// =============================================================================

model MediaAsset {
  id  String @id @default(cuid())
  /// Key under which we store the original and variants (e.g. avatars/{userId}/{uuid}, covers/events/{eventId}/{uuid})
  key String @unique

  /// Optional metadata from upload/processing
  blurhash String?
  width    Int?
  height   Int?
  mimeType String?

  // Optional owner metadata - no FK to User/Event (logical reference through key)
  ownerId String? // e.g. userId
  /// USER_AVATAR, USER_COVER, EVENT_COVER, GALLERY_IMAGE, etc.
  purpose String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
  @@index([purpose])
  @@index([createdAt])
  @@map("media_assets")
}

// =============================================================================
/**
 * Event Appearance - Custom visual styling for events
 * Stores configuration for card and detail page appearance
 */
// =============================================================================

model EventAppearance {
  id      String @id @default(cuid())
  eventId String @unique

  /// JSON configuration for appearance customization
  /// Structure: { card: { background, shadow }, detail: { background, panel: { background, shadow } } }
  config Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@map("event_appearances")
}

// =============================================================================
/**
 * Agenda System
 * Event agenda with time slots and hosts
 */
// =============================================================================

enum AgendaHostKind {
  USER // Host is a registered user
  MANUAL // Host is manually entered (external person)
}

model EventAgendaItem {
  id      String @id @default(cuid())
  eventId String

  /// Display order (0-based)
  order Int @default(0)

  /// Required: slot title (3-120 chars)
  title String

  /// Optional: slot description (max 1000 chars)
  description String?

  /// Optional: start time (UTC)
  startAt DateTime?

  /// Optional: end time (UTC) - must be after startAt if both are set
  endAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event Event                 @relation(fields: [eventId], references: [id], onDelete: Cascade)
  hosts EventAgendaItemHost[]

  @@index([eventId, order])
  @@map("event_agenda_items")
}

model EventAgendaItemHost {
  id           String @id @default(cuid())
  agendaItemId String
  order        Int    @default(0)

  /// Type of host: USER (system user) or MANUAL (external person)
  kind AgendaHostKind @default(USER)

  /// For USER kind: reference to User
  userId String?
  user   User?   @relation("AgendaItemHosts", fields: [userId], references: [id], onDelete: SetNull)

  /// For MANUAL kind: manually entered name (required, max 120 chars)
  name String?

  /// For MANUAL kind: optional avatar URL
  avatarUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  agendaItem EventAgendaItem @relation(fields: [agendaItemId], references: [id], onDelete: Cascade)

  @@index([agendaItemId, order])
  @@map("event_agenda_item_hosts")
}

// =============================================================================
/**
 * Event Check-in System
 * Complete audit trail for all check-in related actions
 */
// =============================================================================

model EventCheckinLog {
  id       String  @id @default(cuid())
  eventId  String
  memberId String // EventMember.id (not userId - this is the membership record)
  actorId  String? // Who performed the action (User.id)

  // Action details
  action CheckinAction // What happened (CHECK_IN, UNCHECK, REJECT, BLOCK_ALL, etc.)
  method CheckinMethod? // Which method (null for BLOCK_ALL, METHODS_CHANGED, etc.)
  source CheckinSource // Who initiated (USER, MODERATOR, SYSTEM)
  result CheckinResult // Outcome (SUCCESS, DENIED, NOOP)

  // Additional context
  reason            String? // Denial reason, rejection reason, or other context
  comment           String? // Optional comment from moderator (e.g., rejection note)
  showCommentToUser Boolean @default(true) // Whether rejection comment is visible to user

  // Metadata for analytics
  metadata Json? // Optional: geolocation, device info, etc.

  createdAt DateTime @default(now())

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  actor User? @relation("CheckinLogActor", fields: [actorId], references: [id], onDelete: SetNull)

  // Note: memberId references EventMember.id, but we don't have direct relation
  // to avoid circular dependency issues. Query via eventId + userId if needed.
  EventMember   EventMember? @relation(fields: [eventMemberId], references: [id])
  eventMemberId String?

  @@index([eventId, createdAt(sort: Desc)]) // For log viewing (newest first)
  @@index([memberId, createdAt]) // For user's check-in history
  @@index([eventId, action]) // For filtering by action type
  @@index([eventId, method]) // For method analytics
  @@index([actorId, createdAt]) // For actor's action history
  @@map("event_checkin_logs")
}
