// =============================================================================
// Prisma Client & Datasource
// =============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
/**
 * Enums
 */
// =============================================================================

enum Visibility {
  PUBLIC
  HIDDEN
}

enum AddressVisibility {
  PUBLIC
  AFTER_JOIN
  HIDDEN
}

enum MembersVisibility {
  PUBLIC
  AFTER_JOIN
  HIDDEN
}

enum JoinMode {
  OPEN
  REQUEST
  INVITE_ONLY
}

enum Mode {
  ONE_TO_ONE
  GROUP
}

enum MeetingKind {
  ONSITE
  ONLINE
  HYBRID
}

enum Role {
  ADMIN
  MODERATOR
  USER
}

enum Level {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum IntentMemberRole {
  OWNER
  MODERATOR
  PARTICIPANT
}

enum IntentMemberStatus {
  JOINED
  PENDING
  INVITED
  REJECTED
  BANNED
  LEFT
  KICKED
  CANCELLED // User cancelled their own pending request
  WAITLIST // User is on the waiting list (event is full)
}

enum NotificationKind {
  INTENT_CREATED
  INTENT_UPDATED
  INTENT_CANCELED
  INTENT_DELETED
  INTENT_INVITE
  INTENT_MEMBERSHIP_APPROVED
  INTENT_MEMBERSHIP_REJECTED
  INTENT_REMINDER
  JOIN_REQUEST
  NEW_MESSAGE
  NEW_COMMENT
  NEW_REVIEW
  BANNED
  UNBANNED
  SYSTEM
  WAITLIST_JOINED // User joined the waitlist
  WAITLIST_PROMOTED // User was promoted from waitlist to joined
}

enum NotificationEntity {
  INTENT
  MESSAGE
  PAYMENT
  INVOICE
  USER
  REVIEW
  SYSTEM
  OTHER
}

enum SponsorshipStatus {
  PENDING
  ACTIVE
  EXPIRED
  CANCELED
}

enum SubscriptionPlan {
  PLUS
  PRO
}

enum UserPlanSource {
  SUBSCRIPTION // auto-renewable subscription
  ONE_OFF // one-time payment (month / year)
}

enum BillingPeriod {
  MONTHLY
  YEARLY
}

enum SubscriptionStatus {
  INCOMPLETE
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
  PAUSED
}

enum IntentPlan {
  FREE
  PLUS
  PRO
}

enum MemberEvent {
  JOIN
  REQUEST
  APPROVE
  REJECT
  LEAVE
  KICK
  BAN
  UNBAN
  INVITE
  ACCEPT_INVITE
  CANCEL_REQUEST // User cancelled their own pending request
  WAITLIST // User joined the waitlist
  WAITLIST_LEAVE // User left the waitlist
  WAITLIST_PROMOTE // User was promoted from waitlist
}

enum JoinQuestionType {
  TEXT
  SINGLE_CHOICE
  MULTI_CHOICE
}

enum FeedbackQuestionType {
  TEXT
  SINGLE_CHOICE
  MULTI_CHOICE
}

enum ReportEntity {
  INTENT
  COMMENT
  REVIEW
  USER
  MESSAGE
}

// =============================================================================
/**
 * Models
 */
// =============================================================================

model User {
  id               String    @id @default(cuid())
  email            String    @unique
  name             String    @unique
  avatarKey        String? // Key to MediaAsset for avatar
  role             Role      @default(USER)
  verifiedAt       DateTime?
  suspendedAt      DateTime? // Admin suspension
  suspensionReason String? // Reason for suspension
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  lastSeenAt       DateTime?

  // Profile / Preferences
  locale              String? // e.g. "pl-PL", "en-US"
  tz                  String? // IANA TZ, np. "Europe/Warsaw"
  acceptedTermsAt     DateTime?
  acceptedMarketingAt DateTime?

  // Relations
  notifications         Notification[]
  actedNotifications    Notification[]      @relation("NotificationActor")
  intentMembers         IntentMember[]
  addedMemberships      IntentMember[]      @relation("IntentMemberAddedBy")
  canceledIntents       Intent[]            @relation("IntentCanceledBy")
  deletedIntents        Intent[]            @relation("IntentDeletedBy")
  ownedIntents          Intent[]            @relation("IntentOwner")
  memberEventsAsSubject IntentMemberEvent[] @relation("MemberEventUser")
  memberEventsAsActor   IntentMemberEvent[] @relation("MemberEventActor")

  // NEW: intents z rƒôcznie zamkniƒôtymi zapisami
  joinClosedIntents Intent[] @relation("IntentJoinClosedBy")

  // Social
  commentsWritten Comment[] @relation("CommentAuthor")
  commentsDeleted Comment[] @relation("CommentDeletedBy")
  commentsHidden  Comment[] @relation("CommentHiddenBy")
  reviewsWritten  Review[]  @relation("ReviewAuthor")
  reviewsDeleted  Review[]  @relation("ReviewDeletedBy")
  reviewsHidden   Review[]  @relation("ReviewHiddenBy")

  // DM
  dmThreadsA         DmThread[]          @relation("DmA")
  dmThreadsB         DmThread[]          @relation("DmB")
  dmMessages         DmMessage[]
  dmMutes            DmMute[]
  dmReads            DmRead[] // last read per thread
  dmMessageReactions DmMessageReaction[] @relation("DmMessageReactions")

  // Event Chat
  intentChatMessages         IntentChatMessage[]
  intentChatReads            IntentChatRead[]
  intentChatMessageReactions IntentChatMessageReaction[] @relation("IntentChatMessageReactions")

  // Mutes / Prefs
  notificationPreference NotificationPreference?
  intentMutes            IntentMute[]

  // Moderation
  reportsFiled    Report[]    @relation("ReportAuthor")
  blocksInitiated UserBlock[] @relation("Blocker")
  blocksReceived  UserBlock[] @relation("Blocked")

  // Ownership transfers
  ownershipTransfersFrom  IntentOwnershipTransfer[] @relation("IotFrom")
  ownershipTransfersTo    IntentOwnershipTransfer[] @relation("IotTo")
  ownershipTransfersActed IntentOwnershipTransfer[] @relation("IotActor")

  // Invite Links
  createdInviteLinks IntentInviteLink[]      @relation("IntentInviteLinkCreatedBy")
  revokedInviteLinks IntentInviteLink[]      @relation("IntentInviteLinkRevokedBy")
  inviteLinkUsages   IntentInviteLinkUsage[]

  // Favourites
  intentFavourites IntentFavourite[]

  // Monetization
  subscriptions           UserSubscription[]
  planPeriods             UserPlanPeriod[]
  eventSponsorships       EventSponsorship[]       @relation("SponsorUser")
  eventSponsorshipPeriods EventSponsorshipPeriod[] @relation("EventSponsorshipPeriods")

  // Feedback tracking
  feedbackTracking FeedbackTracking[]

  // Profile & Privacy
  profile      UserProfile?
  privacy      UserPrivacy?
  stats        UserStats?
  socialLinks  UserSocialLink[]
  disciplines  UserDiscipline[]
  availability UserAvailability[]
  badges       UserBadge[]

  @@index([email])
  @@index([name])
  @@index([role])
  @@index([lastSeenAt])
  @@map("users")
}

model Category {
  id        String   @id @default(cuid())
  slug      String   @unique
  names     Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  intents         Intent[]
  userDisciplines UserDiscipline[]

  @@index([slug])
  @@map("categories")
}

model Tag {
  id        String   @id @default(cuid())
  label     String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  intents Intent[]

  @@index([label])
  @@index([slug])
  @@map("tags")
}

model Intent {
  id          String  @id @default(cuid())
  title       String
  description String?
  notes       String?

  categories Category[]
  tags       Tag[]

  visibility Visibility @default(PUBLIC)
  joinMode   JoinMode   @default(OPEN)

  mode Mode @default(GROUP)
  min  Int  @default(2)
  max  Int  @default(50)

  startAt DateTime
  endAt   DateTime

  joinOpensMinutesBeforeStart     Int?
  joinCutoffMinutesBeforeStart    Int?
  allowJoinLate                   Boolean   @default(true)
  lateJoinCutoffMinutesAfterStart Int?
  joinManuallyClosed              Boolean   @default(false)
  joinManuallyClosedAt            DateTime?
  joinManuallyClosedById          String?
  joinManuallyClosedBy            User?     @relation("IntentJoinClosedBy", fields: [joinManuallyClosedById], references: [id], onDelete: SetNull)
  joinManualCloseReason           String?

  meetingKind MeetingKind @default(ONSITE)
  onlineUrl   String?

  lat      Float?
  lng      Float?
  address  String?
  placeId  String?
  radiusKm Float?

  // City information for filtering and grouping
  cityName    String? // e.g. "Warszawa", "≈Å√≥d≈∫"
  cityPlaceId String? // Google Place ID for the city (locality)

  // Note: PostGIS 'geom' column (geography(Point, 4326)) is managed via SQL migration
  // and not directly in this schema. See migration: 20251104220540_add_postgis_geom
  // The 'geom' column is automatically populated from lat/lng and has a GIST index.
  geom Unsupported("geography(Point, 4326)")?

  levels Level[] @default([])

  // Media
  coverKey String? // Key to MediaAsset for cover image

  addressVisibility AddressVisibility @default(PUBLIC)
  membersVisibility MembersVisibility @default(PUBLIC)

  // Derived counters
  joinedCount   Int @default(0)
  commentsCount Int @default(0)
  messagesCount Int @default(0)
  savedCount    Int @default(0) // How many users saved/favourited this intent

  // Sponsorship / Plan
  sponsorshipPlan IntentPlan @default(FREE) // Effective plan of the event (Free/Plus/Pro)
  boostedAt       DateTime? // Last time the event was boosted (used for sorting)
  highlightColor  String? // Custom highlight/ring color (hex format: #RRGGBB)

  // Ownership
  ownerId            String?
  owner              User?                     @relation("IntentOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  ownershipTransfers IntentOwnershipTransfer[]

  // Cancellation / deletion
  canceledAt   DateTime?
  canceledById String?
  canceledBy   User?     @relation("IntentCanceledBy", fields: [canceledById], references: [id], onDelete: SetNull)
  cancelReason String?

  deletedAt    DateTime?
  deletedById  String?
  deletedBy    User?     @relation("IntentDeletedBy", fields: [deletedById], references: [id], onDelete: SetNull)
  deleteReason String?

  // Relations
  members            IntentMember[]
  memberEvents       IntentMemberEvent[]
  notifications      Notification[]
  comments           Comment[]
  reviews            Review[]
  sponsorship        EventSponsorship?
  sponsorshipPeriods EventSponsorshipPeriod[] @relation("EventSponsorshipPeriods")
  inviteLinks        IntentInviteLink[]
  mutes              IntentMute[]
  favourites         IntentFavourite[]

  // Event Chat relations
  chatMessages IntentChatMessage[]
  chatReads    IntentChatRead[]

  // Join Form relations
  joinQuestions IntentJoinQuestion[]
  joinAnswers   IntentJoinAnswer[]

  // Feedback relations
  feedbackQuestions IntentFeedbackQuestion[]
  feedbackAnswers   IntentFeedbackAnswer[]
  feedbackTracking  FeedbackTracking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Indexes
  @@index([startAt])
  @@index([endAt])
  @@index([boostedAt])
  @@index([visibility])
  @@index([joinMode])
  @@index([mode])
  @@index([meetingKind])
  @@index([lat, lng])
  @@index([placeId])
  @@index([canceledAt])
  @@index([deletedAt])
  @@index([createdAt])
  @@index([visibility, meetingKind, startAt])
  @@index([visibility, startAt, joinedCount])
  @@index([joinManuallyClosed, startAt])
  @@index([joinOpensMinutesBeforeStart])
  @@index([joinCutoffMinutesBeforeStart])
  @@index([lateJoinCutoffMinutesAfterStart])
  @@map("intents")
}

model IntentMember {
  id       String @id @default(cuid())
  intentId String
  userId   String

  intent Intent @relation(fields: [intentId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  role   IntentMemberRole   @default(PARTICIPANT)
  status IntentMemberStatus @default(PENDING)

  addedById String?
  addedBy   User?   @relation("IntentMemberAddedBy", fields: [addedById], references: [id], onDelete: SetNull)

  joinedAt     DateTime?
  leftAt       DateTime?
  note         String?
  rejectReason String? // Reason for rejection (max 500 chars, enforced in app)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations to join form answers
  joinAnswers IntentJoinAnswer[]

  // Relations to feedback answers
  feedbackAnswers IntentFeedbackAnswer[]

  @@unique([intentId, userId])
  @@index([userId, status])
  @@index([intentId, status])
  @@index([intentId, role])
  @@index([intentId, status, role])
  @@index([userId, createdAt])
  @@map("intent_members")
}

model IntentMemberEvent {
  id        String      @id @default(cuid())
  intentId  String
  userId    String
  actorId   String?
  kind      MemberEvent
  note      String?
  createdAt DateTime    @default(now())

  intent Intent @relation(fields: [intentId], references: [id], onDelete: Cascade)

  user  User  @relation("MemberEventUser", fields: [userId], references: [id], onDelete: Cascade)
  actor User? @relation("MemberEventActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([intentId, createdAt])
  @@index([userId, createdAt])
  @@map("intent_member_events")
}

model Comment {
  id        String   @id @default(cuid())
  intentId  String
  authorId  String
  threadId  String // root comment id; dla root√≥w = id (ustaw w app)
  parentId  String?
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Soft delete by author
  deletedAt   DateTime?
  deletedById String?
  deletedBy   User?     @relation("CommentDeletedBy", fields: [deletedById], references: [id], onDelete: SetNull)

  // Hidden by moderator
  hiddenAt   DateTime?
  hiddenById String?
  hiddenBy   User?     @relation("CommentHiddenBy", fields: [hiddenById], references: [id], onDelete: SetNull)

  intent  Intent    @relation(fields: [intentId], references: [id], onDelete: Cascade)
  author  User      @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  parent  Comment?  @relation("CommentParent", fields: [parentId], references: [id], onDelete: SetNull)
  replies Comment[] @relation("CommentParent")

  @@index([intentId, createdAt])
  @@index([authorId, createdAt])
  @@index([intentId, threadId, createdAt])
  @@index([parentId, createdAt])
  @@index([deletedById])
  @@index([hiddenById])
  @@map("comments")
}

model Review {
  id        String   @id @default(cuid())
  intentId  String
  authorId  String
  rating    Int // enforce 1..5 in SQL CHECK (migration)
  content   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Soft delete by author
  deletedAt   DateTime?
  deletedById String?
  deletedBy   User?     @relation("ReviewDeletedBy", fields: [deletedById], references: [id], onDelete: SetNull)

  // Hidden by moderator
  hiddenAt   DateTime?
  hiddenById String?
  hiddenBy   User?     @relation("ReviewHiddenBy", fields: [hiddenById], references: [id], onDelete: SetNull)

  intent Intent @relation(fields: [intentId], references: [id], onDelete: Cascade)
  author User   @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  @@unique([intentId, authorId])
  @@index([intentId, createdAt])
  @@index([authorId, createdAt])
  @@index([intentId, rating, createdAt])
  @@index([deletedById])
  @@index([hiddenById])
  @@map("reviews")
}

model DmThread {
  id            String    @id @default(cuid())
  aUserId       String
  bUserId       String
  pairKey       String    @unique // `${min(aUserId,bUserId)}|${max(aUserId,bUserId)}`
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastMessageAt DateTime?

  aUser    User        @relation("DmA", fields: [aUserId], references: [id], onDelete: Cascade)
  bUser    User        @relation("DmB", fields: [bUserId], references: [id], onDelete: Cascade)
  messages DmMessage[]
  mutes    DmMute[]
  reads    DmRead[] // last read markers per user

  @@index([aUserId, bUserId])
  @@index([lastMessageAt])
  @@map("dm_threads")
}

model DmMessage {
  id        String    @id @default(cuid())
  threadId  String
  senderId  String
  content   String
  replyToId String?
  createdAt DateTime  @default(now())
  readAt    DateTime?
  editedAt  DateTime? // added for parity with event chat
  deletedAt DateTime?

  thread    DmThread            @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender    User                @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reactions DmMessageReaction[]

  replyTo DmMessage?  @relation("DmMessageReply", fields: [replyToId], references: [id], onDelete: SetNull)
  replies DmMessage[] @relation("DmMessageReply")

  @@index([threadId, createdAt])
  @@index([senderId, createdAt])
  @@map("dm_messages")
}

model DmMessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String // üëç, ‚ù§Ô∏è, üòÇ, üòÆ, üò¢, üôè
  createdAt DateTime @default(now())

  message DmMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User      @relation("DmMessageReactions", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("dm_message_reactions")
}

model Notification {
  id String @id @default(cuid())

  kind NotificationKind

  recipientId String
  recipient   User   @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  actorId String?
  actor   User?   @relation("NotificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  entityType NotificationEntity
  entityId   String?

  intentId String?
  intent   Intent? @relation(fields: [intentId], references: [id], onDelete: SetNull)

  title     String?
  body      String?
  data      Json?
  dedupeKey String?

  readAt    DateTime?
  createdAt DateTime  @default(now())

  @@unique([recipientId, dedupeKey])
  @@index([recipientId, readAt])
  @@index([recipientId, createdAt])
  @@index([recipientId, entityType, readAt])
  @@index([recipientId, kind, readAt])
  @@index([intentId])
  @@map("notifications")
}

// ========================== Event Chat ==========================

model IntentChatMessage {
  id        String    @id @default(cuid())
  intentId  String
  authorId  String
  content   String
  replyToId String?
  createdAt DateTime  @default(now())
  editedAt  DateTime?
  deletedAt DateTime?

  intent    Intent                      @relation(fields: [intentId], references: [id], onDelete: Cascade)
  author    User                        @relation(fields: [authorId], references: [id], onDelete: Cascade)
  reactions IntentChatMessageReaction[]

  replyTo IntentChatMessage?  @relation("IntentChatReply", fields: [replyToId], references: [id], onDelete: SetNull)
  replies IntentChatMessage[] @relation("IntentChatReply")

  @@index([intentId, createdAt])
  @@index([authorId, createdAt])
  @@map("intent_chat_messages")
}

model IntentChatMessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String // üëç, ‚ù§Ô∏è, üòÇ, üòÆ, üò¢, üôè
  createdAt DateTime @default(now())

  message IntentChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User              @relation("IntentChatMessageReactions", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("intent_chat_message_reactions")
}

model IntentChatRead {
  id         String   @id @default(cuid())
  intentId   String
  userId     String
  lastReadAt DateTime @default(now())

  intent Intent @relation(fields: [intentId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([intentId, userId])
  @@index([userId, lastReadAt])
  @@map("intent_chat_reads")
}

// ========================== DM Reads ==========================

model DmRead {
  id         String   @id @default(cuid())
  threadId   String
  userId     String
  lastReadAt DateTime @default(now())

  thread DmThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@index([userId, lastReadAt])
  @@map("dm_reads")
}

// ========================== Moderation ==========================

model UserBlock {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker User @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockedId])
  @@map("user_blocks")
}

model Report {
  id         String       @id @default(cuid())
  reporterId String
  entity     ReportEntity
  entityId   String
  reason     String
  status     String       @default("OPEN")
  createdAt  DateTime     @default(now())
  resolvedAt DateTime?

  reporter User @relation("ReportAuthor", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([entity, entityId])
  @@index([status, createdAt])
  @@map("reports")
}

// ========================== Monetization ==========================

model UserSubscription {
  id     String @id @default(cuid())
  userId String

  plan          SubscriptionPlan
  billingPeriod BillingPeriod      @default(MONTHLY)
  status        SubscriptionStatus @default(INCOMPLETE)

  stripeCustomerId     String
  stripeSubscriptionId String?
  stripePriceId        String?

  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  trialEndsAt        DateTime?

  cancelAtPeriodEnd Boolean   @default(false)
  canceledAt        DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([stripeSubscriptionId])
  @@index([currentPeriodEnd])
  @@map("user_subscriptions")
}

model UserPlanPeriod {
  id     String @id @default(cuid())
  userId String

  plan   SubscriptionPlan // PLUS / PRO
  source UserPlanSource // SUBSCRIPTION / ONE_OFF

  billingPeriod BillingPeriod // MONTHLY / YEARLY

  // Payment information
  amount   Float  @default(0) // Amount paid
  currency String @default("pln") // Currency code (pln, eur, usd, etc.)

  // Links to Stripe ‚Äì depends on source
  stripeCustomerId        String?
  stripeSubscriptionId    String? // for SUBSCRIPTION
  stripePaymentIntentId   String? // for ONE_OFF
  stripeCheckoutSessionId String? // optional for debug/trace

  startsAt DateTime
  endsAt   DateTime

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, endsAt])
  @@index([stripeSubscriptionId])
  @@index([stripePaymentIntentId])
  @@map("user_plan_periods")
}

model EventSponsorship {
  id        String @id @default(cuid())
  intentId  String @unique // 1:1 with Intent
  sponsorId String // sponsoring user (usually owner)

  plan   IntentPlan // PLUS / PRO (FREE doesn't make sense but enum is shared)
  status SponsorshipStatus @default(PENDING)

  startsAt DateTime?
  endsAt   DateTime?

  boostsTotal      Int @default(0)
  boostsUsed       Int @default(0)
  localPushesTotal Int @default(0)
  localPushesUsed  Int @default(0)

  stripePaymentIntentId   String?
  stripeCheckoutSessionId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  intent  Intent @relation(fields: [intentId], references: [id], onDelete: Cascade)
  sponsor User   @relation("SponsorUser", fields: [sponsorId], references: [id], onDelete: Cascade)

  periods EventSponsorshipPeriod[] // History of all transactions

  @@index([plan, status])
  @@index([endsAt])
  @@map("event_sponsorships")
}

/// Tracks individual event sponsorship purchases (new, reload, upgrade)
/// Similar to UserPlanPeriod but for event sponsorships
model EventSponsorshipPeriod {
  id        String @id @default(cuid())
  intentId  String
  sponsorId String

  plan       IntentPlan // Plan purchased (PLUS/PRO)
  actionType String     @default("new") // 'new', 'reload', 'upgrade'

  boostsAdded      Int @default(0) // How many boosts this purchase added
  localPushesAdded Int @default(0) // How many pushes this purchase added

  amount   Float // Amount paid in PLN
  currency String @default("pln")

  stripeCustomerId        String?
  stripePaymentIntentId   String?
  stripeCheckoutSessionId String?

  createdAt DateTime @default(now())

  eventSponsorship EventSponsorship @relation(fields: [intentId], references: [intentId], onDelete: Cascade, map: "event_sponsorship_periods_sponsorshipId_fkey")
  intent           Intent           @relation("EventSponsorshipPeriods", fields: [intentId], references: [id], onDelete: Cascade)
  sponsor          User             @relation("EventSponsorshipPeriods", fields: [sponsorId], references: [id], onDelete: Cascade)

  @@index([sponsorId])
  @@index([intentId])
  @@index([createdAt])
  @@map("event_sponsorship_periods")
}

model PaymentEvent {
  id          String    @id @default(cuid())
  provider    String    @default("stripe")
  eventId     String    @unique
  type        String
  payload     Json
  receivedAt  DateTime  @default(now())
  processedAt DateTime?
  success     Boolean   @default(false)
  attempt     Int       @default(1)
  lastError   String?

  @@index([type, receivedAt])
  @@map("payment_events")
}

// ========================== Invites ==========================

model IntentInviteLink {
  id       String @id @default(cuid())
  intentId String
  code     String @unique // Unique code used in URL (/i/:code)

  /// Maximum number of successful uses (null = unlimited)
  maxUses Int?

  /// Count of successful uses (actual memberships created/updated)
  usedCount Int @default(0)

  /// Expiration date (null = no expiration)
  expiresAt DateTime?

  /// Who created this invite link
  createdById String?
  createdBy   User?   @relation("IntentInviteLinkCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  /// Optional label for the link (e.g. "Friends from work")
  label String?

  /// Soft deletion
  revokedAt   DateTime?
  revokedById String?
  revokedBy   User?     @relation("IntentInviteLinkRevokedBy", fields: [revokedById], references: [id], onDelete: SetNull)

  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt

  intent Intent                  @relation(fields: [intentId], references: [id], onDelete: Cascade)
  uses   IntentInviteLinkUsage[]

  @@index([code])
  @@index([intentId])
  @@index([intentId, revokedAt])
  @@index([intentId, expiresAt])
  @@index([expiresAt])
  @@map("intent_invite_links")
}

/// Track who used which invite link
model IntentInviteLinkUsage {
  id     String   @id @default(cuid())
  linkId String
  userId String
  usedAt DateTime @default(now())

  /// IP address (optional, for security/analytics)
  ipAddress String?

  /// User agent (optional, for analytics)
  userAgent String?

  link IntentInviteLink @relation(fields: [linkId], references: [id], onDelete: Cascade)
  user User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([linkId, userId]) // One user can only use a link once
  @@index([linkId])
  @@index([userId])
  @@index([usedAt])
  @@map("intent_invite_link_usages")
}

/// User's saved/favourite intents
model IntentFavourite {
  id        String   @id @default(cuid())
  userId    String
  intentId  String
  createdAt DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  intent Intent @relation(fields: [intentId], references: [id], onDelete: Cascade)

  @@unique([userId, intentId]) // One user can only favourite an intent once
  @@index([userId, createdAt]) // For user's favourites list sorted by when saved
  @@index([intentId]) // For analytics: how many users saved this intent
  @@map("intent_favourites")
}

// ========================== Preferences & Mutes ==========================

model NotificationPreference {
  id                 String   @id @default(cuid())
  userId             String   @unique
  emailOnInvite      Boolean  @default(true)
  emailOnJoinRequest Boolean  @default(true)
  emailOnMessage     Boolean  @default(false)
  pushOnReminder     Boolean  @default(true)
  inAppOnEverything  Boolean  @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model IntentMute {
  id        String   @id @default(cuid())
  intentId  String
  userId    String
  muted     Boolean  @default(true)
  createdAt DateTime @default(now())

  intent Intent @relation(fields: [intentId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([intentId, userId])
  @@map("intent_mutes")
}

model DmMute {
  id        String   @id @default(cuid())
  threadId  String
  userId    String
  muted     Boolean  @default(true)
  createdAt DateTime @default(now())

  thread DmThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([threadId, userId])
  @@map("dm_mutes")
}

// ========================== Ownership transfers ==========================

model IntentOwnershipTransfer {
  id         String   @id @default(cuid())
  intentId   String
  fromUserId String
  toUserId   String
  actorId    String?
  reason     String?
  createdAt  DateTime @default(now())

  intent   Intent @relation(fields: [intentId], references: [id], onDelete: Cascade)
  fromUser User   @relation("IotFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser   User   @relation("IotTo", fields: [toUserId], references: [id], onDelete: Cascade)
  actor    User?  @relation("IotActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([intentId, createdAt])
  @@map("intent_ownership_transfers")
}

// =============================================================================
/**
 * User Profile & Privacy Models
 */
// =============================================================================

model UserProfile {
  id        String   @id @default(cuid())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Public display
  displayName String?
  bioShort    String? // max 200 chars
  bioLong     String? // max 1000 chars

  // Location
  city    String?
  country String?
  homeLat Float?
  homeLng Float?

  // Media
  coverKey String? // Key to MediaAsset for cover image

  // Preferences
  speaks                 String[] // ["pl", "en"]
  interests              String[] // tags
  preferredMode          Mode? // ONE_TO_ONE / GROUP
  preferredMaxDistanceKm Float?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

model UserPrivacy {
  id        String   @id @default(cuid())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // DM policy
  dmPolicy String @default("ALL") // ALL / MEMBERS / INVITE_ONLY / NONE

  // Visibility settings
  showLastSeen String @default("ALL") // ALL / MEMBERS / HIDDEN
  showLocation String @default("CITY") // CITY / APPROX / HIDDEN
  showEvents   String @default("ALL") // ALL / MEMBERS / SELF
  showReviews  String @default("ALL") // ALL / MEMBERS / SELF
  showStats    String @default("ALL") // ALL / MEMBERS / SELF

  // Default visibility for new intents
  defaultAddressVisibility AddressVisibility @default(PUBLIC)
  defaultMembersVisibility MembersVisibility @default(PUBLIC)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_privacy")
}

model UserStats {
  id        String   @id @default(cuid())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Denormalized counters
  eventsCreated Int @default(0)
  eventsJoined  Int @default(0)
  reviewsCount  Int @default(0)

  // Ratings
  hostRatingAvg     Float?
  attendeeRatingAvg Float?

  // Activity
  lastActiveAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_stats")
}

model UserSocialLink {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  provider String // instagram / facebook / strava / x / discord / website
  url      String
  verified Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
  @@map("user_social_links")
}

model UserDiscipline {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  categoryId String
  level      Level
  notes      String?

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([userId, categoryId])
  @@index([userId])
  @@index([categoryId])
  @@map("user_disciplines")
}

model UserAvailability {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  weekday  Int // 0 = Monday, 6 = Sunday
  startMin Int // 0-1440 (minutes from midnight)
  endMin   Int // 0-1440
  tzSnap   String? // Timezone snapshot

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, weekday])
  @@map("user_availability")
}

model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  createdAt DateTime @default(now())

  slug     String // e.g. "first_event", "10_events", "verified"
  data     Json? // Additional metadata
  earnedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, slug])
  @@index([userId])
  @@map("user_badges")
}

// =============================================================================
/**
 * Join Form Models - Questions and Answers for REQUEST mode
 */
// =============================================================================

model IntentJoinQuestion {
  id       String           @id @default(cuid())
  intentId String
  order    Int              @default(0) // Display order (0-based)
  type     JoinQuestionType @default(TEXT)

  label     String // Question text (max 200 chars, enforced in app)
  helpText  String? // Optional help text (max 200 chars, enforced in app)
  required  Boolean @default(true)
  options   Json? // For CHOICE types: array of {label: string, value?: string}
  maxLength Int? // For TEXT type: max answer length

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  intent  Intent             @relation(fields: [intentId], references: [id], onDelete: Cascade)
  answers IntentJoinAnswer[]

  @@index([intentId, order])
  @@map("intent_join_questions")
}

model IntentJoinAnswer {
  id         String @id @default(cuid())
  intentId   String
  userId     String
  questionId String

  answer Json // TEXT: string, SINGLE_CHOICE: string, MULTI_CHOICE: string[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  intent   Intent             @relation(fields: [intentId], references: [id], onDelete: Cascade)
  question IntentJoinQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  member   IntentMember       @relation(fields: [intentId, userId], references: [intentId, userId], onDelete: Cascade)

  @@unique([intentId, userId, questionId])
  @@index([intentId, userId])
  @@index([questionId])
  @@map("intent_join_answers")
}

// =============================================================================
/**
 * Feedback System
 * Post-event feedback questions and answers
 */
// =============================================================================

model IntentFeedbackQuestion {
  id       String               @id @default(cuid())
  intentId String
  order    Int                  @default(0) // Display order (0-based)
  type     FeedbackQuestionType @default(TEXT)

  label     String // Question text (max 200 chars, enforced in app)
  helpText  String? // Optional help text (max 200 chars, enforced in app)
  required  Boolean @default(false)
  options   Json? // For CHOICE types: array of {label: string, value?: string}
  maxLength Int? // For TEXT type: max answer length

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  intent  Intent                 @relation(fields: [intentId], references: [id], onDelete: Cascade)
  answers IntentFeedbackAnswer[]

  @@index([intentId, order])
  @@map("intent_feedback_questions")
}

model IntentFeedbackAnswer {
  id         String @id @default(cuid())
  intentId   String
  userId     String
  questionId String

  answer Json // TEXT: string, SINGLE_CHOICE: string, MULTI_CHOICE: string[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  intent   Intent                 @relation(fields: [intentId], references: [id], onDelete: Cascade)
  question IntentFeedbackQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  member   IntentMember           @relation(fields: [intentId, userId], references: [intentId, userId], onDelete: Cascade)

  @@unique([intentId, userId, questionId])
  @@index([intentId, userId])
  @@index([questionId])
  @@map("intent_feedback_answers")
}

// =============================================================================
/**
 * Feedback Conversion Tracking - Analytics for feedback requests
 */
// =============================================================================

enum FeedbackChannel {
  EMAIL
  IN_APP
  PUSH
  DIRECT_LINK
}

model FeedbackTracking {
  id       String @id @default(cuid())
  intentId String
  userId   String

  // Conversion funnel stages
  emailSentAt     DateTime?
  emailOpenedAt   DateTime?
  pageViewedAt    DateTime?
  formStartedAt   DateTime?
  formSubmittedAt DateTime?

  // Channel
  channel FeedbackChannel @default(EMAIL)

  // Additional metadata (device, browser, etc.)
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  intent Intent @relation(fields: [intentId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([intentId, userId])
  @@index([intentId])
  @@index([userId])
  @@index([emailSentAt])
  @@map("feedback_tracking")
}

// =============================================================================
/**
 * Media Assets - Images with variants on-demand
 */
// =============================================================================

model MediaAsset {
  id  String @id @default(cuid())
  /// Key under which we store the original and variants (e.g. avatars/{userId}/{uuid}, covers/intents/{intentId}/{uuid})
  key String @unique

  /// Optional metadata from upload/processing
  blurhash String?
  width    Int?
  height   Int?
  mimeType String?

  // Optional owner metadata - no FK to User/Intent (logical reference through key)
  ownerId String? // e.g. userId
  /// USER_AVATAR, USER_COVER, INTENT_COVER, GALLERY_IMAGE, etc.
  purpose String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([ownerId])
  @@index([purpose])
  @@index([createdAt])
  @@map("media_assets")
}
