
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/*
 * This file exports the `EventFeedbackAnswer` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model EventFeedbackAnswer
 * 
 */
export type EventFeedbackAnswerModel = runtime.Types.Result.DefaultSelection<Prisma.$EventFeedbackAnswerPayload>

export type AggregateEventFeedbackAnswer = {
  _count: EventFeedbackAnswerCountAggregateOutputType | null
  _min: EventFeedbackAnswerMinAggregateOutputType | null
  _max: EventFeedbackAnswerMaxAggregateOutputType | null
}

export type EventFeedbackAnswerMinAggregateOutputType = {
  id: string | null
  eventId: string | null
  userId: string | null
  questionId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type EventFeedbackAnswerMaxAggregateOutputType = {
  id: string | null
  eventId: string | null
  userId: string | null
  questionId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type EventFeedbackAnswerCountAggregateOutputType = {
  id: number
  eventId: number
  userId: number
  questionId: number
  answer: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type EventFeedbackAnswerMinAggregateInputType = {
  id?: true
  eventId?: true
  userId?: true
  questionId?: true
  createdAt?: true
  updatedAt?: true
}

export type EventFeedbackAnswerMaxAggregateInputType = {
  id?: true
  eventId?: true
  userId?: true
  questionId?: true
  createdAt?: true
  updatedAt?: true
}

export type EventFeedbackAnswerCountAggregateInputType = {
  id?: true
  eventId?: true
  userId?: true
  questionId?: true
  answer?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type EventFeedbackAnswerAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which EventFeedbackAnswer to aggregate.
   */
  where?: Prisma.EventFeedbackAnswerWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EventFeedbackAnswers to fetch.
   */
  orderBy?: Prisma.EventFeedbackAnswerOrderByWithRelationInput | Prisma.EventFeedbackAnswerOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.EventFeedbackAnswerWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EventFeedbackAnswers from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EventFeedbackAnswers.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned EventFeedbackAnswers
  **/
  _count?: true | EventFeedbackAnswerCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: EventFeedbackAnswerMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: EventFeedbackAnswerMaxAggregateInputType
}

export type GetEventFeedbackAnswerAggregateType<T extends EventFeedbackAnswerAggregateArgs> = {
      [P in keyof T & keyof AggregateEventFeedbackAnswer]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateEventFeedbackAnswer[P]>
    : Prisma.GetScalarType<T[P], AggregateEventFeedbackAnswer[P]>
}




export type EventFeedbackAnswerGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.EventFeedbackAnswerWhereInput
  orderBy?: Prisma.EventFeedbackAnswerOrderByWithAggregationInput | Prisma.EventFeedbackAnswerOrderByWithAggregationInput[]
  by: Prisma.EventFeedbackAnswerScalarFieldEnum[] | Prisma.EventFeedbackAnswerScalarFieldEnum
  having?: Prisma.EventFeedbackAnswerScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: EventFeedbackAnswerCountAggregateInputType | true
  _min?: EventFeedbackAnswerMinAggregateInputType
  _max?: EventFeedbackAnswerMaxAggregateInputType
}

export type EventFeedbackAnswerGroupByOutputType = {
  id: string
  eventId: string
  userId: string
  questionId: string
  answer: runtime.JsonValue
  createdAt: Date
  updatedAt: Date
  _count: EventFeedbackAnswerCountAggregateOutputType | null
  _min: EventFeedbackAnswerMinAggregateOutputType | null
  _max: EventFeedbackAnswerMaxAggregateOutputType | null
}

type GetEventFeedbackAnswerGroupByPayload<T extends EventFeedbackAnswerGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<EventFeedbackAnswerGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof EventFeedbackAnswerGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], EventFeedbackAnswerGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], EventFeedbackAnswerGroupByOutputType[P]>
      }
    >
  >



export type EventFeedbackAnswerWhereInput = {
  AND?: Prisma.EventFeedbackAnswerWhereInput | Prisma.EventFeedbackAnswerWhereInput[]
  OR?: Prisma.EventFeedbackAnswerWhereInput[]
  NOT?: Prisma.EventFeedbackAnswerWhereInput | Prisma.EventFeedbackAnswerWhereInput[]
  id?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  eventId?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  userId?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  questionId?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  answer?: Prisma.JsonFilter<"EventFeedbackAnswer">
  createdAt?: Prisma.DateTimeFilter<"EventFeedbackAnswer"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"EventFeedbackAnswer"> | Date | string
  event?: Prisma.XOR<Prisma.EventScalarRelationFilter, Prisma.EventWhereInput>
  question?: Prisma.XOR<Prisma.EventFeedbackQuestionScalarRelationFilter, Prisma.EventFeedbackQuestionWhereInput>
  member?: Prisma.XOR<Prisma.EventMemberScalarRelationFilter, Prisma.EventMemberWhereInput>
}

export type EventFeedbackAnswerOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  eventId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  answer?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  event?: Prisma.EventOrderByWithRelationInput
  question?: Prisma.EventFeedbackQuestionOrderByWithRelationInput
  member?: Prisma.EventMemberOrderByWithRelationInput
}

export type EventFeedbackAnswerWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  eventId_userId_questionId?: Prisma.EventFeedbackAnswerEventIdUserIdQuestionIdCompoundUniqueInput
  AND?: Prisma.EventFeedbackAnswerWhereInput | Prisma.EventFeedbackAnswerWhereInput[]
  OR?: Prisma.EventFeedbackAnswerWhereInput[]
  NOT?: Prisma.EventFeedbackAnswerWhereInput | Prisma.EventFeedbackAnswerWhereInput[]
  eventId?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  userId?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  questionId?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  answer?: Prisma.JsonFilter<"EventFeedbackAnswer">
  createdAt?: Prisma.DateTimeFilter<"EventFeedbackAnswer"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"EventFeedbackAnswer"> | Date | string
  event?: Prisma.XOR<Prisma.EventScalarRelationFilter, Prisma.EventWhereInput>
  question?: Prisma.XOR<Prisma.EventFeedbackQuestionScalarRelationFilter, Prisma.EventFeedbackQuestionWhereInput>
  member?: Prisma.XOR<Prisma.EventMemberScalarRelationFilter, Prisma.EventMemberWhereInput>
}, "id" | "eventId_userId_questionId">

export type EventFeedbackAnswerOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  eventId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  answer?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.EventFeedbackAnswerCountOrderByAggregateInput
  _max?: Prisma.EventFeedbackAnswerMaxOrderByAggregateInput
  _min?: Prisma.EventFeedbackAnswerMinOrderByAggregateInput
}

export type EventFeedbackAnswerScalarWhereWithAggregatesInput = {
  AND?: Prisma.EventFeedbackAnswerScalarWhereWithAggregatesInput | Prisma.EventFeedbackAnswerScalarWhereWithAggregatesInput[]
  OR?: Prisma.EventFeedbackAnswerScalarWhereWithAggregatesInput[]
  NOT?: Prisma.EventFeedbackAnswerScalarWhereWithAggregatesInput | Prisma.EventFeedbackAnswerScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"EventFeedbackAnswer"> | string
  eventId?: Prisma.StringWithAggregatesFilter<"EventFeedbackAnswer"> | string
  userId?: Prisma.StringWithAggregatesFilter<"EventFeedbackAnswer"> | string
  questionId?: Prisma.StringWithAggregatesFilter<"EventFeedbackAnswer"> | string
  answer?: Prisma.JsonWithAggregatesFilter<"EventFeedbackAnswer">
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"EventFeedbackAnswer"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"EventFeedbackAnswer"> | Date | string
}

export type EventFeedbackAnswerCreateInput = {
  id?: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
  event: Prisma.EventCreateNestedOneWithoutFeedbackAnswersInput
  question: Prisma.EventFeedbackQuestionCreateNestedOneWithoutAnswersInput
  member: Prisma.EventMemberCreateNestedOneWithoutFeedbackAnswersInput
}

export type EventFeedbackAnswerUncheckedCreateInput = {
  id?: string
  eventId: string
  userId: string
  questionId: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type EventFeedbackAnswerUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  event?: Prisma.EventUpdateOneRequiredWithoutFeedbackAnswersNestedInput
  question?: Prisma.EventFeedbackQuestionUpdateOneRequiredWithoutAnswersNestedInput
  member?: Prisma.EventMemberUpdateOneRequiredWithoutFeedbackAnswersNestedInput
}

export type EventFeedbackAnswerUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  eventId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EventFeedbackAnswerCreateManyInput = {
  id?: string
  eventId: string
  userId: string
  questionId: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type EventFeedbackAnswerUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EventFeedbackAnswerUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  eventId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EventFeedbackAnswerListRelationFilter = {
  every?: Prisma.EventFeedbackAnswerWhereInput
  some?: Prisma.EventFeedbackAnswerWhereInput
  none?: Prisma.EventFeedbackAnswerWhereInput
}

export type EventFeedbackAnswerOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type EventFeedbackAnswerEventIdUserIdQuestionIdCompoundUniqueInput = {
  eventId: string
  userId: string
  questionId: string
}

export type EventFeedbackAnswerCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  eventId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  answer?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type EventFeedbackAnswerMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  eventId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type EventFeedbackAnswerMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  eventId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  questionId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type EventFeedbackAnswerCreateNestedManyWithoutEventInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutEventInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput> | Prisma.EventFeedbackAnswerCreateWithoutEventInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutEventInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutEventInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyEventInputEnvelope
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
}

export type EventFeedbackAnswerUncheckedCreateNestedManyWithoutEventInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutEventInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput> | Prisma.EventFeedbackAnswerCreateWithoutEventInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutEventInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutEventInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyEventInputEnvelope
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
}

export type EventFeedbackAnswerUpdateManyWithoutEventNestedInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutEventInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput> | Prisma.EventFeedbackAnswerCreateWithoutEventInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutEventInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutEventInput[]
  upsert?: Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutEventInput | Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutEventInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyEventInputEnvelope
  set?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  disconnect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  delete?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  update?: Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutEventInput | Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutEventInput[]
  updateMany?: Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutEventInput | Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutEventInput[]
  deleteMany?: Prisma.EventFeedbackAnswerScalarWhereInput | Prisma.EventFeedbackAnswerScalarWhereInput[]
}

export type EventFeedbackAnswerUncheckedUpdateManyWithoutEventNestedInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutEventInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput> | Prisma.EventFeedbackAnswerCreateWithoutEventInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutEventInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutEventInput[]
  upsert?: Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutEventInput | Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutEventInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyEventInputEnvelope
  set?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  disconnect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  delete?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  update?: Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutEventInput | Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutEventInput[]
  updateMany?: Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutEventInput | Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutEventInput[]
  deleteMany?: Prisma.EventFeedbackAnswerScalarWhereInput | Prisma.EventFeedbackAnswerScalarWhereInput[]
}

export type EventFeedbackAnswerCreateNestedManyWithoutMemberInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutMemberInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput> | Prisma.EventFeedbackAnswerCreateWithoutMemberInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutMemberInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutMemberInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyMemberInputEnvelope
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
}

export type EventFeedbackAnswerUncheckedCreateNestedManyWithoutMemberInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutMemberInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput> | Prisma.EventFeedbackAnswerCreateWithoutMemberInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutMemberInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutMemberInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyMemberInputEnvelope
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
}

export type EventFeedbackAnswerUpdateManyWithoutMemberNestedInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutMemberInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput> | Prisma.EventFeedbackAnswerCreateWithoutMemberInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutMemberInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutMemberInput[]
  upsert?: Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutMemberInput | Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutMemberInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyMemberInputEnvelope
  set?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  disconnect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  delete?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  update?: Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutMemberInput | Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutMemberInput[]
  updateMany?: Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutMemberInput | Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutMemberInput[]
  deleteMany?: Prisma.EventFeedbackAnswerScalarWhereInput | Prisma.EventFeedbackAnswerScalarWhereInput[]
}

export type EventFeedbackAnswerUncheckedUpdateManyWithoutMemberNestedInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutMemberInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput> | Prisma.EventFeedbackAnswerCreateWithoutMemberInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutMemberInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutMemberInput[]
  upsert?: Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutMemberInput | Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutMemberInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyMemberInputEnvelope
  set?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  disconnect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  delete?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  update?: Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutMemberInput | Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutMemberInput[]
  updateMany?: Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutMemberInput | Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutMemberInput[]
  deleteMany?: Prisma.EventFeedbackAnswerScalarWhereInput | Prisma.EventFeedbackAnswerScalarWhereInput[]
}

export type EventFeedbackAnswerCreateNestedManyWithoutQuestionInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutQuestionInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput> | Prisma.EventFeedbackAnswerCreateWithoutQuestionInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutQuestionInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutQuestionInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyQuestionInputEnvelope
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
}

export type EventFeedbackAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutQuestionInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput> | Prisma.EventFeedbackAnswerCreateWithoutQuestionInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutQuestionInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutQuestionInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyQuestionInputEnvelope
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
}

export type EventFeedbackAnswerUpdateManyWithoutQuestionNestedInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutQuestionInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput> | Prisma.EventFeedbackAnswerCreateWithoutQuestionInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutQuestionInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutQuestionInput[]
  upsert?: Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutQuestionInput | Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyQuestionInputEnvelope
  set?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  disconnect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  delete?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  update?: Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutQuestionInput | Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
  updateMany?: Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutQuestionInput | Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutQuestionInput[]
  deleteMany?: Prisma.EventFeedbackAnswerScalarWhereInput | Prisma.EventFeedbackAnswerScalarWhereInput[]
}

export type EventFeedbackAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
  create?: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutQuestionInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput> | Prisma.EventFeedbackAnswerCreateWithoutQuestionInput[] | Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput[]
  connectOrCreate?: Prisma.EventFeedbackAnswerCreateOrConnectWithoutQuestionInput | Prisma.EventFeedbackAnswerCreateOrConnectWithoutQuestionInput[]
  upsert?: Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutQuestionInput | Prisma.EventFeedbackAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
  createMany?: Prisma.EventFeedbackAnswerCreateManyQuestionInputEnvelope
  set?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  disconnect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  delete?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  connect?: Prisma.EventFeedbackAnswerWhereUniqueInput | Prisma.EventFeedbackAnswerWhereUniqueInput[]
  update?: Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutQuestionInput | Prisma.EventFeedbackAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
  updateMany?: Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutQuestionInput | Prisma.EventFeedbackAnswerUpdateManyWithWhereWithoutQuestionInput[]
  deleteMany?: Prisma.EventFeedbackAnswerScalarWhereInput | Prisma.EventFeedbackAnswerScalarWhereInput[]
}

export type EventFeedbackAnswerCreateWithoutEventInput = {
  id?: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
  question: Prisma.EventFeedbackQuestionCreateNestedOneWithoutAnswersInput
  member: Prisma.EventMemberCreateNestedOneWithoutFeedbackAnswersInput
}

export type EventFeedbackAnswerUncheckedCreateWithoutEventInput = {
  id?: string
  userId: string
  questionId: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type EventFeedbackAnswerCreateOrConnectWithoutEventInput = {
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  create: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutEventInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput>
}

export type EventFeedbackAnswerCreateManyEventInputEnvelope = {
  data: Prisma.EventFeedbackAnswerCreateManyEventInput | Prisma.EventFeedbackAnswerCreateManyEventInput[]
  skipDuplicates?: boolean
}

export type EventFeedbackAnswerUpsertWithWhereUniqueWithoutEventInput = {
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  update: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateWithoutEventInput, Prisma.EventFeedbackAnswerUncheckedUpdateWithoutEventInput>
  create: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutEventInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutEventInput>
}

export type EventFeedbackAnswerUpdateWithWhereUniqueWithoutEventInput = {
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  data: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateWithoutEventInput, Prisma.EventFeedbackAnswerUncheckedUpdateWithoutEventInput>
}

export type EventFeedbackAnswerUpdateManyWithWhereWithoutEventInput = {
  where: Prisma.EventFeedbackAnswerScalarWhereInput
  data: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateManyMutationInput, Prisma.EventFeedbackAnswerUncheckedUpdateManyWithoutEventInput>
}

export type EventFeedbackAnswerScalarWhereInput = {
  AND?: Prisma.EventFeedbackAnswerScalarWhereInput | Prisma.EventFeedbackAnswerScalarWhereInput[]
  OR?: Prisma.EventFeedbackAnswerScalarWhereInput[]
  NOT?: Prisma.EventFeedbackAnswerScalarWhereInput | Prisma.EventFeedbackAnswerScalarWhereInput[]
  id?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  eventId?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  userId?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  questionId?: Prisma.StringFilter<"EventFeedbackAnswer"> | string
  answer?: Prisma.JsonFilter<"EventFeedbackAnswer">
  createdAt?: Prisma.DateTimeFilter<"EventFeedbackAnswer"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"EventFeedbackAnswer"> | Date | string
}

export type EventFeedbackAnswerCreateWithoutMemberInput = {
  id?: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
  event: Prisma.EventCreateNestedOneWithoutFeedbackAnswersInput
  question: Prisma.EventFeedbackQuestionCreateNestedOneWithoutAnswersInput
}

export type EventFeedbackAnswerUncheckedCreateWithoutMemberInput = {
  id?: string
  questionId: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type EventFeedbackAnswerCreateOrConnectWithoutMemberInput = {
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  create: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutMemberInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput>
}

export type EventFeedbackAnswerCreateManyMemberInputEnvelope = {
  data: Prisma.EventFeedbackAnswerCreateManyMemberInput | Prisma.EventFeedbackAnswerCreateManyMemberInput[]
  skipDuplicates?: boolean
}

export type EventFeedbackAnswerUpsertWithWhereUniqueWithoutMemberInput = {
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  update: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateWithoutMemberInput, Prisma.EventFeedbackAnswerUncheckedUpdateWithoutMemberInput>
  create: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutMemberInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutMemberInput>
}

export type EventFeedbackAnswerUpdateWithWhereUniqueWithoutMemberInput = {
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  data: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateWithoutMemberInput, Prisma.EventFeedbackAnswerUncheckedUpdateWithoutMemberInput>
}

export type EventFeedbackAnswerUpdateManyWithWhereWithoutMemberInput = {
  where: Prisma.EventFeedbackAnswerScalarWhereInput
  data: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateManyMutationInput, Prisma.EventFeedbackAnswerUncheckedUpdateManyWithoutMemberInput>
}

export type EventFeedbackAnswerCreateWithoutQuestionInput = {
  id?: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
  event: Prisma.EventCreateNestedOneWithoutFeedbackAnswersInput
  member: Prisma.EventMemberCreateNestedOneWithoutFeedbackAnswersInput
}

export type EventFeedbackAnswerUncheckedCreateWithoutQuestionInput = {
  id?: string
  eventId: string
  userId: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type EventFeedbackAnswerCreateOrConnectWithoutQuestionInput = {
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  create: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutQuestionInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput>
}

export type EventFeedbackAnswerCreateManyQuestionInputEnvelope = {
  data: Prisma.EventFeedbackAnswerCreateManyQuestionInput | Prisma.EventFeedbackAnswerCreateManyQuestionInput[]
  skipDuplicates?: boolean
}

export type EventFeedbackAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  update: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateWithoutQuestionInput, Prisma.EventFeedbackAnswerUncheckedUpdateWithoutQuestionInput>
  create: Prisma.XOR<Prisma.EventFeedbackAnswerCreateWithoutQuestionInput, Prisma.EventFeedbackAnswerUncheckedCreateWithoutQuestionInput>
}

export type EventFeedbackAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  data: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateWithoutQuestionInput, Prisma.EventFeedbackAnswerUncheckedUpdateWithoutQuestionInput>
}

export type EventFeedbackAnswerUpdateManyWithWhereWithoutQuestionInput = {
  where: Prisma.EventFeedbackAnswerScalarWhereInput
  data: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateManyMutationInput, Prisma.EventFeedbackAnswerUncheckedUpdateManyWithoutQuestionInput>
}

export type EventFeedbackAnswerCreateManyEventInput = {
  id?: string
  userId: string
  questionId: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type EventFeedbackAnswerUpdateWithoutEventInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  question?: Prisma.EventFeedbackQuestionUpdateOneRequiredWithoutAnswersNestedInput
  member?: Prisma.EventMemberUpdateOneRequiredWithoutFeedbackAnswersNestedInput
}

export type EventFeedbackAnswerUncheckedUpdateWithoutEventInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EventFeedbackAnswerUncheckedUpdateManyWithoutEventInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EventFeedbackAnswerCreateManyMemberInput = {
  id?: string
  questionId: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type EventFeedbackAnswerUpdateWithoutMemberInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  event?: Prisma.EventUpdateOneRequiredWithoutFeedbackAnswersNestedInput
  question?: Prisma.EventFeedbackQuestionUpdateOneRequiredWithoutAnswersNestedInput
}

export type EventFeedbackAnswerUncheckedUpdateWithoutMemberInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EventFeedbackAnswerUncheckedUpdateManyWithoutMemberInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  questionId?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EventFeedbackAnswerCreateManyQuestionInput = {
  id?: string
  eventId: string
  userId: string
  answer: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type EventFeedbackAnswerUpdateWithoutQuestionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  event?: Prisma.EventUpdateOneRequiredWithoutFeedbackAnswersNestedInput
  member?: Prisma.EventMemberUpdateOneRequiredWithoutFeedbackAnswersNestedInput
}

export type EventFeedbackAnswerUncheckedUpdateWithoutQuestionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  eventId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type EventFeedbackAnswerUncheckedUpdateManyWithoutQuestionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  eventId?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  answer?: Prisma.JsonNullValueInput | runtime.InputJsonValue
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type EventFeedbackAnswerSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  eventId?: boolean
  userId?: boolean
  questionId?: boolean
  answer?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  question?: boolean | Prisma.EventFeedbackQuestionDefaultArgs<ExtArgs>
  member?: boolean | Prisma.EventMemberDefaultArgs<ExtArgs>
}, ExtArgs["result"]["eventFeedbackAnswer"]>

export type EventFeedbackAnswerSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  eventId?: boolean
  userId?: boolean
  questionId?: boolean
  answer?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  question?: boolean | Prisma.EventFeedbackQuestionDefaultArgs<ExtArgs>
  member?: boolean | Prisma.EventMemberDefaultArgs<ExtArgs>
}, ExtArgs["result"]["eventFeedbackAnswer"]>

export type EventFeedbackAnswerSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  eventId?: boolean
  userId?: boolean
  questionId?: boolean
  answer?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  question?: boolean | Prisma.EventFeedbackQuestionDefaultArgs<ExtArgs>
  member?: boolean | Prisma.EventMemberDefaultArgs<ExtArgs>
}, ExtArgs["result"]["eventFeedbackAnswer"]>

export type EventFeedbackAnswerSelectScalar = {
  id?: boolean
  eventId?: boolean
  userId?: boolean
  questionId?: boolean
  answer?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type EventFeedbackAnswerOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "eventId" | "userId" | "questionId" | "answer" | "createdAt" | "updatedAt", ExtArgs["result"]["eventFeedbackAnswer"]>
export type EventFeedbackAnswerInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  question?: boolean | Prisma.EventFeedbackQuestionDefaultArgs<ExtArgs>
  member?: boolean | Prisma.EventMemberDefaultArgs<ExtArgs>
}
export type EventFeedbackAnswerIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  question?: boolean | Prisma.EventFeedbackQuestionDefaultArgs<ExtArgs>
  member?: boolean | Prisma.EventMemberDefaultArgs<ExtArgs>
}
export type EventFeedbackAnswerIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  question?: boolean | Prisma.EventFeedbackQuestionDefaultArgs<ExtArgs>
  member?: boolean | Prisma.EventMemberDefaultArgs<ExtArgs>
}

export type $EventFeedbackAnswerPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "EventFeedbackAnswer"
  objects: {
    event: Prisma.$EventPayload<ExtArgs>
    question: Prisma.$EventFeedbackQuestionPayload<ExtArgs>
    member: Prisma.$EventMemberPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    eventId: string
    userId: string
    questionId: string
    answer: runtime.JsonValue
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["eventFeedbackAnswer"]>
  composites: {}
}

export type EventFeedbackAnswerGetPayload<S extends boolean | null | undefined | EventFeedbackAnswerDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload, S>

export type EventFeedbackAnswerCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<EventFeedbackAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: EventFeedbackAnswerCountAggregateInputType | true
  }

export interface EventFeedbackAnswerDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventFeedbackAnswer'], meta: { name: 'EventFeedbackAnswer' } }
  /**
   * Find zero or one EventFeedbackAnswer that matches the filter.
   * @param {EventFeedbackAnswerFindUniqueArgs} args - Arguments to find a EventFeedbackAnswer
   * @example
   * // Get one EventFeedbackAnswer
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends EventFeedbackAnswerFindUniqueArgs>(args: Prisma.SelectSubset<T, EventFeedbackAnswerFindUniqueArgs<ExtArgs>>): Prisma.Prisma__EventFeedbackAnswerClient<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one EventFeedbackAnswer that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {EventFeedbackAnswerFindUniqueOrThrowArgs} args - Arguments to find a EventFeedbackAnswer
   * @example
   * // Get one EventFeedbackAnswer
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends EventFeedbackAnswerFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, EventFeedbackAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__EventFeedbackAnswerClient<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first EventFeedbackAnswer that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventFeedbackAnswerFindFirstArgs} args - Arguments to find a EventFeedbackAnswer
   * @example
   * // Get one EventFeedbackAnswer
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends EventFeedbackAnswerFindFirstArgs>(args?: Prisma.SelectSubset<T, EventFeedbackAnswerFindFirstArgs<ExtArgs>>): Prisma.Prisma__EventFeedbackAnswerClient<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first EventFeedbackAnswer that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventFeedbackAnswerFindFirstOrThrowArgs} args - Arguments to find a EventFeedbackAnswer
   * @example
   * // Get one EventFeedbackAnswer
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends EventFeedbackAnswerFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, EventFeedbackAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__EventFeedbackAnswerClient<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more EventFeedbackAnswers that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventFeedbackAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all EventFeedbackAnswers
   * const eventFeedbackAnswers = await prisma.eventFeedbackAnswer.findMany()
   * 
   * // Get first 10 EventFeedbackAnswers
   * const eventFeedbackAnswers = await prisma.eventFeedbackAnswer.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const eventFeedbackAnswerWithIdOnly = await prisma.eventFeedbackAnswer.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends EventFeedbackAnswerFindManyArgs>(args?: Prisma.SelectSubset<T, EventFeedbackAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a EventFeedbackAnswer.
   * @param {EventFeedbackAnswerCreateArgs} args - Arguments to create a EventFeedbackAnswer.
   * @example
   * // Create one EventFeedbackAnswer
   * const EventFeedbackAnswer = await prisma.eventFeedbackAnswer.create({
   *   data: {
   *     // ... data to create a EventFeedbackAnswer
   *   }
   * })
   * 
   */
  create<T extends EventFeedbackAnswerCreateArgs>(args: Prisma.SelectSubset<T, EventFeedbackAnswerCreateArgs<ExtArgs>>): Prisma.Prisma__EventFeedbackAnswerClient<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many EventFeedbackAnswers.
   * @param {EventFeedbackAnswerCreateManyArgs} args - Arguments to create many EventFeedbackAnswers.
   * @example
   * // Create many EventFeedbackAnswers
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends EventFeedbackAnswerCreateManyArgs>(args?: Prisma.SelectSubset<T, EventFeedbackAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many EventFeedbackAnswers and returns the data saved in the database.
   * @param {EventFeedbackAnswerCreateManyAndReturnArgs} args - Arguments to create many EventFeedbackAnswers.
   * @example
   * // Create many EventFeedbackAnswers
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many EventFeedbackAnswers and only return the `id`
   * const eventFeedbackAnswerWithIdOnly = await prisma.eventFeedbackAnswer.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends EventFeedbackAnswerCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, EventFeedbackAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a EventFeedbackAnswer.
   * @param {EventFeedbackAnswerDeleteArgs} args - Arguments to delete one EventFeedbackAnswer.
   * @example
   * // Delete one EventFeedbackAnswer
   * const EventFeedbackAnswer = await prisma.eventFeedbackAnswer.delete({
   *   where: {
   *     // ... filter to delete one EventFeedbackAnswer
   *   }
   * })
   * 
   */
  delete<T extends EventFeedbackAnswerDeleteArgs>(args: Prisma.SelectSubset<T, EventFeedbackAnswerDeleteArgs<ExtArgs>>): Prisma.Prisma__EventFeedbackAnswerClient<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one EventFeedbackAnswer.
   * @param {EventFeedbackAnswerUpdateArgs} args - Arguments to update one EventFeedbackAnswer.
   * @example
   * // Update one EventFeedbackAnswer
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends EventFeedbackAnswerUpdateArgs>(args: Prisma.SelectSubset<T, EventFeedbackAnswerUpdateArgs<ExtArgs>>): Prisma.Prisma__EventFeedbackAnswerClient<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more EventFeedbackAnswers.
   * @param {EventFeedbackAnswerDeleteManyArgs} args - Arguments to filter EventFeedbackAnswers to delete.
   * @example
   * // Delete a few EventFeedbackAnswers
   * const { count } = await prisma.eventFeedbackAnswer.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends EventFeedbackAnswerDeleteManyArgs>(args?: Prisma.SelectSubset<T, EventFeedbackAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more EventFeedbackAnswers.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventFeedbackAnswerUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many EventFeedbackAnswers
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends EventFeedbackAnswerUpdateManyArgs>(args: Prisma.SelectSubset<T, EventFeedbackAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more EventFeedbackAnswers and returns the data updated in the database.
   * @param {EventFeedbackAnswerUpdateManyAndReturnArgs} args - Arguments to update many EventFeedbackAnswers.
   * @example
   * // Update many EventFeedbackAnswers
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more EventFeedbackAnswers and only return the `id`
   * const eventFeedbackAnswerWithIdOnly = await prisma.eventFeedbackAnswer.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends EventFeedbackAnswerUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, EventFeedbackAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one EventFeedbackAnswer.
   * @param {EventFeedbackAnswerUpsertArgs} args - Arguments to update or create a EventFeedbackAnswer.
   * @example
   * // Update or create a EventFeedbackAnswer
   * const eventFeedbackAnswer = await prisma.eventFeedbackAnswer.upsert({
   *   create: {
   *     // ... data to create a EventFeedbackAnswer
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the EventFeedbackAnswer we want to update
   *   }
   * })
   */
  upsert<T extends EventFeedbackAnswerUpsertArgs>(args: Prisma.SelectSubset<T, EventFeedbackAnswerUpsertArgs<ExtArgs>>): Prisma.Prisma__EventFeedbackAnswerClient<runtime.Types.Result.GetResult<Prisma.$EventFeedbackAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of EventFeedbackAnswers.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventFeedbackAnswerCountArgs} args - Arguments to filter EventFeedbackAnswers to count.
   * @example
   * // Count the number of EventFeedbackAnswers
   * const count = await prisma.eventFeedbackAnswer.count({
   *   where: {
   *     // ... the filter for the EventFeedbackAnswers we want to count
   *   }
   * })
  **/
  count<T extends EventFeedbackAnswerCountArgs>(
    args?: Prisma.Subset<T, EventFeedbackAnswerCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], EventFeedbackAnswerCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a EventFeedbackAnswer.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventFeedbackAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends EventFeedbackAnswerAggregateArgs>(args: Prisma.Subset<T, EventFeedbackAnswerAggregateArgs>): Prisma.PrismaPromise<GetEventFeedbackAnswerAggregateType<T>>

  /**
   * Group by EventFeedbackAnswer.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventFeedbackAnswerGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends EventFeedbackAnswerGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: EventFeedbackAnswerGroupByArgs['orderBy'] }
      : { orderBy?: EventFeedbackAnswerGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, EventFeedbackAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventFeedbackAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the EventFeedbackAnswer model
 */
readonly fields: EventFeedbackAnswerFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for EventFeedbackAnswer.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__EventFeedbackAnswerClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  event<T extends Prisma.EventDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EventDefaultArgs<ExtArgs>>): Prisma.Prisma__EventClient<runtime.Types.Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  question<T extends Prisma.EventFeedbackQuestionDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EventFeedbackQuestionDefaultArgs<ExtArgs>>): Prisma.Prisma__EventFeedbackQuestionClient<runtime.Types.Result.GetResult<Prisma.$EventFeedbackQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  member<T extends Prisma.EventMemberDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EventMemberDefaultArgs<ExtArgs>>): Prisma.Prisma__EventMemberClient<runtime.Types.Result.GetResult<Prisma.$EventMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the EventFeedbackAnswer model
 */
export interface EventFeedbackAnswerFieldRefs {
  readonly id: Prisma.FieldRef<"EventFeedbackAnswer", 'String'>
  readonly eventId: Prisma.FieldRef<"EventFeedbackAnswer", 'String'>
  readonly userId: Prisma.FieldRef<"EventFeedbackAnswer", 'String'>
  readonly questionId: Prisma.FieldRef<"EventFeedbackAnswer", 'String'>
  readonly answer: Prisma.FieldRef<"EventFeedbackAnswer", 'Json'>
  readonly createdAt: Prisma.FieldRef<"EventFeedbackAnswer", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"EventFeedbackAnswer", 'DateTime'>
}
    

// Custom InputTypes
/**
 * EventFeedbackAnswer findUnique
 */
export type EventFeedbackAnswerFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
  /**
   * Filter, which EventFeedbackAnswer to fetch.
   */
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
}

/**
 * EventFeedbackAnswer findUniqueOrThrow
 */
export type EventFeedbackAnswerFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
  /**
   * Filter, which EventFeedbackAnswer to fetch.
   */
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
}

/**
 * EventFeedbackAnswer findFirst
 */
export type EventFeedbackAnswerFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
  /**
   * Filter, which EventFeedbackAnswer to fetch.
   */
  where?: Prisma.EventFeedbackAnswerWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EventFeedbackAnswers to fetch.
   */
  orderBy?: Prisma.EventFeedbackAnswerOrderByWithRelationInput | Prisma.EventFeedbackAnswerOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for EventFeedbackAnswers.
   */
  cursor?: Prisma.EventFeedbackAnswerWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EventFeedbackAnswers from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EventFeedbackAnswers.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of EventFeedbackAnswers.
   */
  distinct?: Prisma.EventFeedbackAnswerScalarFieldEnum | Prisma.EventFeedbackAnswerScalarFieldEnum[]
}

/**
 * EventFeedbackAnswer findFirstOrThrow
 */
export type EventFeedbackAnswerFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
  /**
   * Filter, which EventFeedbackAnswer to fetch.
   */
  where?: Prisma.EventFeedbackAnswerWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EventFeedbackAnswers to fetch.
   */
  orderBy?: Prisma.EventFeedbackAnswerOrderByWithRelationInput | Prisma.EventFeedbackAnswerOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for EventFeedbackAnswers.
   */
  cursor?: Prisma.EventFeedbackAnswerWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EventFeedbackAnswers from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EventFeedbackAnswers.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of EventFeedbackAnswers.
   */
  distinct?: Prisma.EventFeedbackAnswerScalarFieldEnum | Prisma.EventFeedbackAnswerScalarFieldEnum[]
}

/**
 * EventFeedbackAnswer findMany
 */
export type EventFeedbackAnswerFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
  /**
   * Filter, which EventFeedbackAnswers to fetch.
   */
  where?: Prisma.EventFeedbackAnswerWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EventFeedbackAnswers to fetch.
   */
  orderBy?: Prisma.EventFeedbackAnswerOrderByWithRelationInput | Prisma.EventFeedbackAnswerOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing EventFeedbackAnswers.
   */
  cursor?: Prisma.EventFeedbackAnswerWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EventFeedbackAnswers from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EventFeedbackAnswers.
   */
  skip?: number
  distinct?: Prisma.EventFeedbackAnswerScalarFieldEnum | Prisma.EventFeedbackAnswerScalarFieldEnum[]
}

/**
 * EventFeedbackAnswer create
 */
export type EventFeedbackAnswerCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
  /**
   * The data needed to create a EventFeedbackAnswer.
   */
  data: Prisma.XOR<Prisma.EventFeedbackAnswerCreateInput, Prisma.EventFeedbackAnswerUncheckedCreateInput>
}

/**
 * EventFeedbackAnswer createMany
 */
export type EventFeedbackAnswerCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many EventFeedbackAnswers.
   */
  data: Prisma.EventFeedbackAnswerCreateManyInput | Prisma.EventFeedbackAnswerCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * EventFeedbackAnswer createManyAndReturn
 */
export type EventFeedbackAnswerCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * The data used to create many EventFeedbackAnswers.
   */
  data: Prisma.EventFeedbackAnswerCreateManyInput | Prisma.EventFeedbackAnswerCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * EventFeedbackAnswer update
 */
export type EventFeedbackAnswerUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
  /**
   * The data needed to update a EventFeedbackAnswer.
   */
  data: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateInput, Prisma.EventFeedbackAnswerUncheckedUpdateInput>
  /**
   * Choose, which EventFeedbackAnswer to update.
   */
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
}

/**
 * EventFeedbackAnswer updateMany
 */
export type EventFeedbackAnswerUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update EventFeedbackAnswers.
   */
  data: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateManyMutationInput, Prisma.EventFeedbackAnswerUncheckedUpdateManyInput>
  /**
   * Filter which EventFeedbackAnswers to update
   */
  where?: Prisma.EventFeedbackAnswerWhereInput
  /**
   * Limit how many EventFeedbackAnswers to update.
   */
  limit?: number
}

/**
 * EventFeedbackAnswer updateManyAndReturn
 */
export type EventFeedbackAnswerUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * The data used to update EventFeedbackAnswers.
   */
  data: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateManyMutationInput, Prisma.EventFeedbackAnswerUncheckedUpdateManyInput>
  /**
   * Filter which EventFeedbackAnswers to update
   */
  where?: Prisma.EventFeedbackAnswerWhereInput
  /**
   * Limit how many EventFeedbackAnswers to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * EventFeedbackAnswer upsert
 */
export type EventFeedbackAnswerUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
  /**
   * The filter to search for the EventFeedbackAnswer to update in case it exists.
   */
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
  /**
   * In case the EventFeedbackAnswer found by the `where` argument doesn't exist, create a new EventFeedbackAnswer with this data.
   */
  create: Prisma.XOR<Prisma.EventFeedbackAnswerCreateInput, Prisma.EventFeedbackAnswerUncheckedCreateInput>
  /**
   * In case the EventFeedbackAnswer was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.EventFeedbackAnswerUpdateInput, Prisma.EventFeedbackAnswerUncheckedUpdateInput>
}

/**
 * EventFeedbackAnswer delete
 */
export type EventFeedbackAnswerDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
  /**
   * Filter which EventFeedbackAnswer to delete.
   */
  where: Prisma.EventFeedbackAnswerWhereUniqueInput
}

/**
 * EventFeedbackAnswer deleteMany
 */
export type EventFeedbackAnswerDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which EventFeedbackAnswers to delete
   */
  where?: Prisma.EventFeedbackAnswerWhereInput
  /**
   * Limit how many EventFeedbackAnswers to delete.
   */
  limit?: number
}

/**
 * EventFeedbackAnswer without action
 */
export type EventFeedbackAnswerDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventFeedbackAnswer
   */
  select?: Prisma.EventFeedbackAnswerSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventFeedbackAnswer
   */
  omit?: Prisma.EventFeedbackAnswerOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventFeedbackAnswerInclude<ExtArgs> | null
}
