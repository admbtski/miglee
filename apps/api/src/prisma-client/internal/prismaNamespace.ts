
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  Category: 'Category',
  Tag: 'Tag',
  Event: 'Event',
  EventMember: 'EventMember',
  EventMemberEvent: 'EventMemberEvent',
  Comment: 'Comment',
  Review: 'Review',
  DmThread: 'DmThread',
  DmMessage: 'DmMessage',
  DmMessageReaction: 'DmMessageReaction',
  Notification: 'Notification',
  EventChatMessage: 'EventChatMessage',
  EventChatMessageReaction: 'EventChatMessageReaction',
  EventChatRead: 'EventChatRead',
  DmRead: 'DmRead',
  UserBlock: 'UserBlock',
  Report: 'Report',
  UserSubscription: 'UserSubscription',
  UserPlanPeriod: 'UserPlanPeriod',
  EventSponsorship: 'EventSponsorship',
  EventSponsorshipPeriod: 'EventSponsorshipPeriod',
  PaymentEvent: 'PaymentEvent',
  EventInviteLink: 'EventInviteLink',
  EventInviteLinkUsage: 'EventInviteLinkUsage',
  EventFavourite: 'EventFavourite',
  NotificationPreference: 'NotificationPreference',
  EventMute: 'EventMute',
  DmMute: 'DmMute',
  EventOwnershipTransfer: 'EventOwnershipTransfer',
  UserProfile: 'UserProfile',
  UserPrivacy: 'UserPrivacy',
  UserStats: 'UserStats',
  UserSocialLink: 'UserSocialLink',
  UserCategoryLevel: 'UserCategoryLevel',
  UserAvailability: 'UserAvailability',
  UserBadge: 'UserBadge',
  EventJoinQuestion: 'EventJoinQuestion',
  EventJoinAnswer: 'EventJoinAnswer',
  EventFeedbackQuestion: 'EventFeedbackQuestion',
  EventFeedbackAnswer: 'EventFeedbackAnswer',
  EventFaq: 'EventFaq',
  MediaAsset: 'MediaAsset',
  EventAppearance: 'EventAppearance',
  EventAgendaItem: 'EventAgendaItem',
  EventAgendaItemHost: 'EventAgendaItemHost',
  EventCheckinLog: 'EventCheckinLog',
  EventAuditLog: 'EventAuditLog'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "category" | "tag" | "event" | "eventMember" | "eventMemberEvent" | "comment" | "review" | "dmThread" | "dmMessage" | "dmMessageReaction" | "notification" | "eventChatMessage" | "eventChatMessageReaction" | "eventChatRead" | "dmRead" | "userBlock" | "report" | "userSubscription" | "userPlanPeriod" | "eventSponsorship" | "eventSponsorshipPeriod" | "paymentEvent" | "eventInviteLink" | "eventInviteLinkUsage" | "eventFavourite" | "notificationPreference" | "eventMute" | "dmMute" | "eventOwnershipTransfer" | "userProfile" | "userPrivacy" | "userStats" | "userSocialLink" | "userCategoryLevel" | "userAvailability" | "userBadge" | "eventJoinQuestion" | "eventJoinAnswer" | "eventFeedbackQuestion" | "eventFeedbackAnswer" | "eventFaq" | "mediaAsset" | "eventAppearance" | "eventAgendaItem" | "eventAgendaItemHost" | "eventCheckinLog" | "eventAuditLog"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Category: {
      payload: Prisma.$CategoryPayload<ExtArgs>
      fields: Prisma.CategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        findFirst: {
          args: Prisma.CategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        findMany: {
          args: Prisma.CategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        create: {
          args: Prisma.CategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        createMany: {
          args: Prisma.CategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        delete: {
          args: Prisma.CategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        update: {
          args: Prisma.CategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        deleteMany: {
          args: Prisma.CategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[]
        }
        upsert: {
          args: Prisma.CategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>
        }
        aggregate: {
          args: Prisma.CategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCategory>
        }
        groupBy: {
          args: Prisma.CategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CategoryCountAggregateOutputType> | number
        }
      }
    }
    Tag: {
      payload: Prisma.$TagPayload<ExtArgs>
      fields: Prisma.TagFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TagFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        findFirst: {
          args: Prisma.TagFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        findMany: {
          args: Prisma.TagFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        create: {
          args: Prisma.TagCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        createMany: {
          args: Prisma.TagCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        delete: {
          args: Prisma.TagDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        update: {
          args: Prisma.TagUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        deleteMany: {
          args: Prisma.TagDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TagUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>[]
        }
        upsert: {
          args: Prisma.TagUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TagPayload>
        }
        aggregate: {
          args: Prisma.TagAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTag>
        }
        groupBy: {
          args: Prisma.TagGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TagGroupByOutputType>[]
        }
        count: {
          args: Prisma.TagCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TagCountAggregateOutputType> | number
        }
      }
    }
    Event: {
      payload: Prisma.$EventPayload<ExtArgs>
      fields: Prisma.EventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findFirst: {
          args: Prisma.EventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findMany: {
          args: Prisma.EventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        create: {
          args: Prisma.EventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        createMany: {
          args: Prisma.EventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        delete: {
          args: Prisma.EventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        update: {
          args: Prisma.EventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        deleteMany: {
          args: Prisma.EventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        upsert: {
          args: Prisma.EventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        aggregate: {
          args: Prisma.EventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEvent>
        }
        groupBy: {
          args: Prisma.EventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventCountAggregateOutputType> | number
        }
      }
    }
    EventMember: {
      payload: Prisma.$EventMemberPayload<ExtArgs>
      fields: Prisma.EventMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload>
        }
        findFirst: {
          args: Prisma.EventMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload>
        }
        findMany: {
          args: Prisma.EventMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload>[]
        }
        create: {
          args: Prisma.EventMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload>
        }
        createMany: {
          args: Prisma.EventMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload>[]
        }
        delete: {
          args: Prisma.EventMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload>
        }
        update: {
          args: Prisma.EventMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload>
        }
        deleteMany: {
          args: Prisma.EventMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload>[]
        }
        upsert: {
          args: Prisma.EventMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberPayload>
        }
        aggregate: {
          args: Prisma.EventMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventMember>
        }
        groupBy: {
          args: Prisma.EventMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventMemberCountAggregateOutputType> | number
        }
      }
    }
    EventMemberEvent: {
      payload: Prisma.$EventMemberEventPayload<ExtArgs>
      fields: Prisma.EventMemberEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventMemberEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventMemberEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload>
        }
        findFirst: {
          args: Prisma.EventMemberEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventMemberEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload>
        }
        findMany: {
          args: Prisma.EventMemberEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload>[]
        }
        create: {
          args: Prisma.EventMemberEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload>
        }
        createMany: {
          args: Prisma.EventMemberEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventMemberEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload>[]
        }
        delete: {
          args: Prisma.EventMemberEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload>
        }
        update: {
          args: Prisma.EventMemberEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload>
        }
        deleteMany: {
          args: Prisma.EventMemberEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventMemberEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventMemberEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload>[]
        }
        upsert: {
          args: Prisma.EventMemberEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMemberEventPayload>
        }
        aggregate: {
          args: Prisma.EventMemberEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventMemberEvent>
        }
        groupBy: {
          args: Prisma.EventMemberEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventMemberEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventMemberEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventMemberEventCountAggregateOutputType> | number
        }
      }
    }
    Comment: {
      payload: Prisma.$CommentPayload<ExtArgs>
      fields: Prisma.CommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findFirst: {
          args: Prisma.CommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findMany: {
          args: Prisma.CommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        create: {
          args: Prisma.CommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        createMany: {
          args: Prisma.CommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        delete: {
          args: Prisma.CommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        update: {
          args: Prisma.CommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        deleteMany: {
          args: Prisma.CommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        upsert: {
          args: Prisma.CommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        aggregate: {
          args: Prisma.CommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateComment>
        }
        groupBy: {
          args: Prisma.CommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentCountAggregateOutputType> | number
        }
      }
    }
    Review: {
      payload: Prisma.$ReviewPayload<ExtArgs>
      fields: Prisma.ReviewFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReviewFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        findFirst: {
          args: Prisma.ReviewFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        findMany: {
          args: Prisma.ReviewFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>[]
        }
        create: {
          args: Prisma.ReviewCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        createMany: {
          args: Prisma.ReviewCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>[]
        }
        delete: {
          args: Prisma.ReviewDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        update: {
          args: Prisma.ReviewUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        deleteMany: {
          args: Prisma.ReviewDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReviewUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>[]
        }
        upsert: {
          args: Prisma.ReviewUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReviewPayload>
        }
        aggregate: {
          args: Prisma.ReviewAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReview>
        }
        groupBy: {
          args: Prisma.ReviewGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReviewGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReviewCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReviewCountAggregateOutputType> | number
        }
      }
    }
    DmThread: {
      payload: Prisma.$DmThreadPayload<ExtArgs>
      fields: Prisma.DmThreadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DmThreadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DmThreadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload>
        }
        findFirst: {
          args: Prisma.DmThreadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DmThreadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload>
        }
        findMany: {
          args: Prisma.DmThreadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload>[]
        }
        create: {
          args: Prisma.DmThreadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload>
        }
        createMany: {
          args: Prisma.DmThreadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DmThreadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload>[]
        }
        delete: {
          args: Prisma.DmThreadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload>
        }
        update: {
          args: Prisma.DmThreadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload>
        }
        deleteMany: {
          args: Prisma.DmThreadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DmThreadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DmThreadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload>[]
        }
        upsert: {
          args: Prisma.DmThreadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmThreadPayload>
        }
        aggregate: {
          args: Prisma.DmThreadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDmThread>
        }
        groupBy: {
          args: Prisma.DmThreadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmThreadGroupByOutputType>[]
        }
        count: {
          args: Prisma.DmThreadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmThreadCountAggregateOutputType> | number
        }
      }
    }
    DmMessage: {
      payload: Prisma.$DmMessagePayload<ExtArgs>
      fields: Prisma.DmMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DmMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DmMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload>
        }
        findFirst: {
          args: Prisma.DmMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DmMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload>
        }
        findMany: {
          args: Prisma.DmMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload>[]
        }
        create: {
          args: Prisma.DmMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload>
        }
        createMany: {
          args: Prisma.DmMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DmMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload>[]
        }
        delete: {
          args: Prisma.DmMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload>
        }
        update: {
          args: Prisma.DmMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload>
        }
        deleteMany: {
          args: Prisma.DmMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DmMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DmMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload>[]
        }
        upsert: {
          args: Prisma.DmMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessagePayload>
        }
        aggregate: {
          args: Prisma.DmMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDmMessage>
        }
        groupBy: {
          args: Prisma.DmMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.DmMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmMessageCountAggregateOutputType> | number
        }
      }
    }
    DmMessageReaction: {
      payload: Prisma.$DmMessageReactionPayload<ExtArgs>
      fields: Prisma.DmMessageReactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DmMessageReactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DmMessageReactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload>
        }
        findFirst: {
          args: Prisma.DmMessageReactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DmMessageReactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload>
        }
        findMany: {
          args: Prisma.DmMessageReactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload>[]
        }
        create: {
          args: Prisma.DmMessageReactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload>
        }
        createMany: {
          args: Prisma.DmMessageReactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DmMessageReactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload>[]
        }
        delete: {
          args: Prisma.DmMessageReactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload>
        }
        update: {
          args: Prisma.DmMessageReactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload>
        }
        deleteMany: {
          args: Prisma.DmMessageReactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DmMessageReactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DmMessageReactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload>[]
        }
        upsert: {
          args: Prisma.DmMessageReactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMessageReactionPayload>
        }
        aggregate: {
          args: Prisma.DmMessageReactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDmMessageReaction>
        }
        groupBy: {
          args: Prisma.DmMessageReactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmMessageReactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.DmMessageReactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmMessageReactionCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    EventChatMessage: {
      payload: Prisma.$EventChatMessagePayload<ExtArgs>
      fields: Prisma.EventChatMessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventChatMessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventChatMessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload>
        }
        findFirst: {
          args: Prisma.EventChatMessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventChatMessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload>
        }
        findMany: {
          args: Prisma.EventChatMessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload>[]
        }
        create: {
          args: Prisma.EventChatMessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload>
        }
        createMany: {
          args: Prisma.EventChatMessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventChatMessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload>[]
        }
        delete: {
          args: Prisma.EventChatMessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload>
        }
        update: {
          args: Prisma.EventChatMessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload>
        }
        deleteMany: {
          args: Prisma.EventChatMessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventChatMessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventChatMessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload>[]
        }
        upsert: {
          args: Prisma.EventChatMessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessagePayload>
        }
        aggregate: {
          args: Prisma.EventChatMessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventChatMessage>
        }
        groupBy: {
          args: Prisma.EventChatMessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventChatMessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventChatMessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventChatMessageCountAggregateOutputType> | number
        }
      }
    }
    EventChatMessageReaction: {
      payload: Prisma.$EventChatMessageReactionPayload<ExtArgs>
      fields: Prisma.EventChatMessageReactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventChatMessageReactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventChatMessageReactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload>
        }
        findFirst: {
          args: Prisma.EventChatMessageReactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventChatMessageReactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload>
        }
        findMany: {
          args: Prisma.EventChatMessageReactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload>[]
        }
        create: {
          args: Prisma.EventChatMessageReactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload>
        }
        createMany: {
          args: Prisma.EventChatMessageReactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventChatMessageReactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload>[]
        }
        delete: {
          args: Prisma.EventChatMessageReactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload>
        }
        update: {
          args: Prisma.EventChatMessageReactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload>
        }
        deleteMany: {
          args: Prisma.EventChatMessageReactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventChatMessageReactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventChatMessageReactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload>[]
        }
        upsert: {
          args: Prisma.EventChatMessageReactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatMessageReactionPayload>
        }
        aggregate: {
          args: Prisma.EventChatMessageReactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventChatMessageReaction>
        }
        groupBy: {
          args: Prisma.EventChatMessageReactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventChatMessageReactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventChatMessageReactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventChatMessageReactionCountAggregateOutputType> | number
        }
      }
    }
    EventChatRead: {
      payload: Prisma.$EventChatReadPayload<ExtArgs>
      fields: Prisma.EventChatReadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventChatReadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventChatReadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload>
        }
        findFirst: {
          args: Prisma.EventChatReadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventChatReadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload>
        }
        findMany: {
          args: Prisma.EventChatReadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload>[]
        }
        create: {
          args: Prisma.EventChatReadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload>
        }
        createMany: {
          args: Prisma.EventChatReadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventChatReadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload>[]
        }
        delete: {
          args: Prisma.EventChatReadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload>
        }
        update: {
          args: Prisma.EventChatReadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload>
        }
        deleteMany: {
          args: Prisma.EventChatReadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventChatReadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventChatReadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload>[]
        }
        upsert: {
          args: Prisma.EventChatReadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventChatReadPayload>
        }
        aggregate: {
          args: Prisma.EventChatReadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventChatRead>
        }
        groupBy: {
          args: Prisma.EventChatReadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventChatReadGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventChatReadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventChatReadCountAggregateOutputType> | number
        }
      }
    }
    DmRead: {
      payload: Prisma.$DmReadPayload<ExtArgs>
      fields: Prisma.DmReadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DmReadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DmReadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload>
        }
        findFirst: {
          args: Prisma.DmReadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DmReadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload>
        }
        findMany: {
          args: Prisma.DmReadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload>[]
        }
        create: {
          args: Prisma.DmReadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload>
        }
        createMany: {
          args: Prisma.DmReadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DmReadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload>[]
        }
        delete: {
          args: Prisma.DmReadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload>
        }
        update: {
          args: Prisma.DmReadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload>
        }
        deleteMany: {
          args: Prisma.DmReadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DmReadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DmReadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload>[]
        }
        upsert: {
          args: Prisma.DmReadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmReadPayload>
        }
        aggregate: {
          args: Prisma.DmReadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDmRead>
        }
        groupBy: {
          args: Prisma.DmReadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmReadGroupByOutputType>[]
        }
        count: {
          args: Prisma.DmReadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmReadCountAggregateOutputType> | number
        }
      }
    }
    UserBlock: {
      payload: Prisma.$UserBlockPayload<ExtArgs>
      fields: Prisma.UserBlockFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserBlockFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserBlockFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload>
        }
        findFirst: {
          args: Prisma.UserBlockFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserBlockFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload>
        }
        findMany: {
          args: Prisma.UserBlockFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload>[]
        }
        create: {
          args: Prisma.UserBlockCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload>
        }
        createMany: {
          args: Prisma.UserBlockCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserBlockCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload>[]
        }
        delete: {
          args: Prisma.UserBlockDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload>
        }
        update: {
          args: Prisma.UserBlockUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload>
        }
        deleteMany: {
          args: Prisma.UserBlockDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserBlockUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserBlockUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload>[]
        }
        upsert: {
          args: Prisma.UserBlockUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBlockPayload>
        }
        aggregate: {
          args: Prisma.UserBlockAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserBlock>
        }
        groupBy: {
          args: Prisma.UserBlockGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserBlockGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserBlockCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserBlockCountAggregateOutputType> | number
        }
      }
    }
    Report: {
      payload: Prisma.$ReportPayload<ExtArgs>
      fields: Prisma.ReportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        findFirst: {
          args: Prisma.ReportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        findMany: {
          args: Prisma.ReportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[]
        }
        create: {
          args: Prisma.ReportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        createMany: {
          args: Prisma.ReportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[]
        }
        delete: {
          args: Prisma.ReportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        update: {
          args: Prisma.ReportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        deleteMany: {
          args: Prisma.ReportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[]
        }
        upsert: {
          args: Prisma.ReportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        aggregate: {
          args: Prisma.ReportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReport>
        }
        groupBy: {
          args: Prisma.ReportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportCountAggregateOutputType> | number
        }
      }
    }
    UserSubscription: {
      payload: Prisma.$UserSubscriptionPayload<ExtArgs>
      fields: Prisma.UserSubscriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
        }
        findFirst: {
          args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
        }
        findMany: {
          args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
        }
        create: {
          args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
        }
        createMany: {
          args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
        }
        delete: {
          args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
        }
        update: {
          args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
        }
        deleteMany: {
          args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserSubscriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
        }
        upsert: {
          args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
        }
        aggregate: {
          args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserSubscription>
        }
        groupBy: {
          args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSubscriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserSubscriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSubscriptionCountAggregateOutputType> | number
        }
      }
    }
    UserPlanPeriod: {
      payload: Prisma.$UserPlanPeriodPayload<ExtArgs>
      fields: Prisma.UserPlanPeriodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserPlanPeriodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserPlanPeriodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload>
        }
        findFirst: {
          args: Prisma.UserPlanPeriodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserPlanPeriodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload>
        }
        findMany: {
          args: Prisma.UserPlanPeriodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload>[]
        }
        create: {
          args: Prisma.UserPlanPeriodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload>
        }
        createMany: {
          args: Prisma.UserPlanPeriodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserPlanPeriodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload>[]
        }
        delete: {
          args: Prisma.UserPlanPeriodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload>
        }
        update: {
          args: Prisma.UserPlanPeriodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload>
        }
        deleteMany: {
          args: Prisma.UserPlanPeriodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserPlanPeriodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserPlanPeriodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload>[]
        }
        upsert: {
          args: Prisma.UserPlanPeriodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPlanPeriodPayload>
        }
        aggregate: {
          args: Prisma.UserPlanPeriodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserPlanPeriod>
        }
        groupBy: {
          args: Prisma.UserPlanPeriodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPlanPeriodGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserPlanPeriodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPlanPeriodCountAggregateOutputType> | number
        }
      }
    }
    EventSponsorship: {
      payload: Prisma.$EventSponsorshipPayload<ExtArgs>
      fields: Prisma.EventSponsorshipFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventSponsorshipFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventSponsorshipFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload>
        }
        findFirst: {
          args: Prisma.EventSponsorshipFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventSponsorshipFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload>
        }
        findMany: {
          args: Prisma.EventSponsorshipFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload>[]
        }
        create: {
          args: Prisma.EventSponsorshipCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload>
        }
        createMany: {
          args: Prisma.EventSponsorshipCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventSponsorshipCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload>[]
        }
        delete: {
          args: Prisma.EventSponsorshipDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload>
        }
        update: {
          args: Prisma.EventSponsorshipUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload>
        }
        deleteMany: {
          args: Prisma.EventSponsorshipDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventSponsorshipUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventSponsorshipUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload>[]
        }
        upsert: {
          args: Prisma.EventSponsorshipUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPayload>
        }
        aggregate: {
          args: Prisma.EventSponsorshipAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventSponsorship>
        }
        groupBy: {
          args: Prisma.EventSponsorshipGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSponsorshipGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventSponsorshipCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSponsorshipCountAggregateOutputType> | number
        }
      }
    }
    EventSponsorshipPeriod: {
      payload: Prisma.$EventSponsorshipPeriodPayload<ExtArgs>
      fields: Prisma.EventSponsorshipPeriodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventSponsorshipPeriodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventSponsorshipPeriodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload>
        }
        findFirst: {
          args: Prisma.EventSponsorshipPeriodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventSponsorshipPeriodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload>
        }
        findMany: {
          args: Prisma.EventSponsorshipPeriodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload>[]
        }
        create: {
          args: Prisma.EventSponsorshipPeriodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload>
        }
        createMany: {
          args: Prisma.EventSponsorshipPeriodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventSponsorshipPeriodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload>[]
        }
        delete: {
          args: Prisma.EventSponsorshipPeriodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload>
        }
        update: {
          args: Prisma.EventSponsorshipPeriodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload>
        }
        deleteMany: {
          args: Prisma.EventSponsorshipPeriodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventSponsorshipPeriodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventSponsorshipPeriodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload>[]
        }
        upsert: {
          args: Prisma.EventSponsorshipPeriodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventSponsorshipPeriodPayload>
        }
        aggregate: {
          args: Prisma.EventSponsorshipPeriodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventSponsorshipPeriod>
        }
        groupBy: {
          args: Prisma.EventSponsorshipPeriodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSponsorshipPeriodGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventSponsorshipPeriodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventSponsorshipPeriodCountAggregateOutputType> | number
        }
      }
    }
    PaymentEvent: {
      payload: Prisma.$PaymentEventPayload<ExtArgs>
      fields: Prisma.PaymentEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload>
        }
        findFirst: {
          args: Prisma.PaymentEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload>
        }
        findMany: {
          args: Prisma.PaymentEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload>[]
        }
        create: {
          args: Prisma.PaymentEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload>
        }
        createMany: {
          args: Prisma.PaymentEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload>[]
        }
        delete: {
          args: Prisma.PaymentEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload>
        }
        update: {
          args: Prisma.PaymentEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload>
        }
        deleteMany: {
          args: Prisma.PaymentEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload>[]
        }
        upsert: {
          args: Prisma.PaymentEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentEventPayload>
        }
        aggregate: {
          args: Prisma.PaymentEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentEvent>
        }
        groupBy: {
          args: Prisma.PaymentEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentEventCountAggregateOutputType> | number
        }
      }
    }
    EventInviteLink: {
      payload: Prisma.$EventInviteLinkPayload<ExtArgs>
      fields: Prisma.EventInviteLinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventInviteLinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventInviteLinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload>
        }
        findFirst: {
          args: Prisma.EventInviteLinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventInviteLinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload>
        }
        findMany: {
          args: Prisma.EventInviteLinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload>[]
        }
        create: {
          args: Prisma.EventInviteLinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload>
        }
        createMany: {
          args: Prisma.EventInviteLinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventInviteLinkCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload>[]
        }
        delete: {
          args: Prisma.EventInviteLinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload>
        }
        update: {
          args: Prisma.EventInviteLinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload>
        }
        deleteMany: {
          args: Prisma.EventInviteLinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventInviteLinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventInviteLinkUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload>[]
        }
        upsert: {
          args: Prisma.EventInviteLinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkPayload>
        }
        aggregate: {
          args: Prisma.EventInviteLinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventInviteLink>
        }
        groupBy: {
          args: Prisma.EventInviteLinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventInviteLinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventInviteLinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventInviteLinkCountAggregateOutputType> | number
        }
      }
    }
    EventInviteLinkUsage: {
      payload: Prisma.$EventInviteLinkUsagePayload<ExtArgs>
      fields: Prisma.EventInviteLinkUsageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventInviteLinkUsageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventInviteLinkUsageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload>
        }
        findFirst: {
          args: Prisma.EventInviteLinkUsageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventInviteLinkUsageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload>
        }
        findMany: {
          args: Prisma.EventInviteLinkUsageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload>[]
        }
        create: {
          args: Prisma.EventInviteLinkUsageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload>
        }
        createMany: {
          args: Prisma.EventInviteLinkUsageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventInviteLinkUsageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload>[]
        }
        delete: {
          args: Prisma.EventInviteLinkUsageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload>
        }
        update: {
          args: Prisma.EventInviteLinkUsageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload>
        }
        deleteMany: {
          args: Prisma.EventInviteLinkUsageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventInviteLinkUsageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventInviteLinkUsageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload>[]
        }
        upsert: {
          args: Prisma.EventInviteLinkUsageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventInviteLinkUsagePayload>
        }
        aggregate: {
          args: Prisma.EventInviteLinkUsageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventInviteLinkUsage>
        }
        groupBy: {
          args: Prisma.EventInviteLinkUsageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventInviteLinkUsageGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventInviteLinkUsageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventInviteLinkUsageCountAggregateOutputType> | number
        }
      }
    }
    EventFavourite: {
      payload: Prisma.$EventFavouritePayload<ExtArgs>
      fields: Prisma.EventFavouriteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventFavouriteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventFavouriteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload>
        }
        findFirst: {
          args: Prisma.EventFavouriteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventFavouriteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload>
        }
        findMany: {
          args: Prisma.EventFavouriteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload>[]
        }
        create: {
          args: Prisma.EventFavouriteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload>
        }
        createMany: {
          args: Prisma.EventFavouriteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventFavouriteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload>[]
        }
        delete: {
          args: Prisma.EventFavouriteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload>
        }
        update: {
          args: Prisma.EventFavouriteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload>
        }
        deleteMany: {
          args: Prisma.EventFavouriteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventFavouriteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventFavouriteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload>[]
        }
        upsert: {
          args: Prisma.EventFavouriteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFavouritePayload>
        }
        aggregate: {
          args: Prisma.EventFavouriteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventFavourite>
        }
        groupBy: {
          args: Prisma.EventFavouriteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventFavouriteGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventFavouriteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventFavouriteCountAggregateOutputType> | number
        }
      }
    }
    NotificationPreference: {
      payload: Prisma.$NotificationPreferencePayload<ExtArgs>
      fields: Prisma.NotificationPreferenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationPreferenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationPreferenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findFirst: {
          args: Prisma.NotificationPreferenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationPreferenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        findMany: {
          args: Prisma.NotificationPreferenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        create: {
          args: Prisma.NotificationPreferenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        createMany: {
          args: Prisma.NotificationPreferenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationPreferenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        delete: {
          args: Prisma.NotificationPreferenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        update: {
          args: Prisma.NotificationPreferenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        deleteMany: {
          args: Prisma.NotificationPreferenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationPreferenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationPreferenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>[]
        }
        upsert: {
          args: Prisma.NotificationPreferenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPreferencePayload>
        }
        aggregate: {
          args: Prisma.NotificationPreferenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationPreference>
        }
        groupBy: {
          args: Prisma.NotificationPreferenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationPreferenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationPreferenceCountAggregateOutputType> | number
        }
      }
    }
    EventMute: {
      payload: Prisma.$EventMutePayload<ExtArgs>
      fields: Prisma.EventMuteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventMuteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventMuteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload>
        }
        findFirst: {
          args: Prisma.EventMuteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventMuteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload>
        }
        findMany: {
          args: Prisma.EventMuteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload>[]
        }
        create: {
          args: Prisma.EventMuteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload>
        }
        createMany: {
          args: Prisma.EventMuteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventMuteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload>[]
        }
        delete: {
          args: Prisma.EventMuteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload>
        }
        update: {
          args: Prisma.EventMuteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload>
        }
        deleteMany: {
          args: Prisma.EventMuteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventMuteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventMuteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload>[]
        }
        upsert: {
          args: Prisma.EventMuteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventMutePayload>
        }
        aggregate: {
          args: Prisma.EventMuteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventMute>
        }
        groupBy: {
          args: Prisma.EventMuteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventMuteGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventMuteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventMuteCountAggregateOutputType> | number
        }
      }
    }
    DmMute: {
      payload: Prisma.$DmMutePayload<ExtArgs>
      fields: Prisma.DmMuteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DmMuteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DmMuteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload>
        }
        findFirst: {
          args: Prisma.DmMuteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DmMuteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload>
        }
        findMany: {
          args: Prisma.DmMuteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload>[]
        }
        create: {
          args: Prisma.DmMuteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload>
        }
        createMany: {
          args: Prisma.DmMuteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DmMuteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload>[]
        }
        delete: {
          args: Prisma.DmMuteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload>
        }
        update: {
          args: Prisma.DmMuteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload>
        }
        deleteMany: {
          args: Prisma.DmMuteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DmMuteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DmMuteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload>[]
        }
        upsert: {
          args: Prisma.DmMuteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DmMutePayload>
        }
        aggregate: {
          args: Prisma.DmMuteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDmMute>
        }
        groupBy: {
          args: Prisma.DmMuteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmMuteGroupByOutputType>[]
        }
        count: {
          args: Prisma.DmMuteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DmMuteCountAggregateOutputType> | number
        }
      }
    }
    EventOwnershipTransfer: {
      payload: Prisma.$EventOwnershipTransferPayload<ExtArgs>
      fields: Prisma.EventOwnershipTransferFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventOwnershipTransferFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventOwnershipTransferFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload>
        }
        findFirst: {
          args: Prisma.EventOwnershipTransferFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventOwnershipTransferFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload>
        }
        findMany: {
          args: Prisma.EventOwnershipTransferFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload>[]
        }
        create: {
          args: Prisma.EventOwnershipTransferCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload>
        }
        createMany: {
          args: Prisma.EventOwnershipTransferCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventOwnershipTransferCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload>[]
        }
        delete: {
          args: Prisma.EventOwnershipTransferDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload>
        }
        update: {
          args: Prisma.EventOwnershipTransferUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload>
        }
        deleteMany: {
          args: Prisma.EventOwnershipTransferDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventOwnershipTransferUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventOwnershipTransferUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload>[]
        }
        upsert: {
          args: Prisma.EventOwnershipTransferUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventOwnershipTransferPayload>
        }
        aggregate: {
          args: Prisma.EventOwnershipTransferAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventOwnershipTransfer>
        }
        groupBy: {
          args: Prisma.EventOwnershipTransferGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventOwnershipTransferGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventOwnershipTransferCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventOwnershipTransferCountAggregateOutputType> | number
        }
      }
    }
    UserProfile: {
      payload: Prisma.$UserProfilePayload<ExtArgs>
      fields: Prisma.UserProfileFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        findFirst: {
          args: Prisma.UserProfileFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        findMany: {
          args: Prisma.UserProfileFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
        }
        create: {
          args: Prisma.UserProfileCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        createMany: {
          args: Prisma.UserProfileCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
        }
        delete: {
          args: Prisma.UserProfileDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        update: {
          args: Prisma.UserProfileUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        deleteMany: {
          args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
        }
        upsert: {
          args: Prisma.UserProfileUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProfilePayload>
        }
        aggregate: {
          args: Prisma.UserProfileAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserProfile>
        }
        groupBy: {
          args: Prisma.UserProfileGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProfileGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserProfileCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProfileCountAggregateOutputType> | number
        }
      }
    }
    UserPrivacy: {
      payload: Prisma.$UserPrivacyPayload<ExtArgs>
      fields: Prisma.UserPrivacyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserPrivacyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserPrivacyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload>
        }
        findFirst: {
          args: Prisma.UserPrivacyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserPrivacyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload>
        }
        findMany: {
          args: Prisma.UserPrivacyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload>[]
        }
        create: {
          args: Prisma.UserPrivacyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload>
        }
        createMany: {
          args: Prisma.UserPrivacyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserPrivacyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload>[]
        }
        delete: {
          args: Prisma.UserPrivacyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload>
        }
        update: {
          args: Prisma.UserPrivacyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload>
        }
        deleteMany: {
          args: Prisma.UserPrivacyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserPrivacyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserPrivacyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload>[]
        }
        upsert: {
          args: Prisma.UserPrivacyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPrivacyPayload>
        }
        aggregate: {
          args: Prisma.UserPrivacyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserPrivacy>
        }
        groupBy: {
          args: Prisma.UserPrivacyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPrivacyGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserPrivacyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserPrivacyCountAggregateOutputType> | number
        }
      }
    }
    UserStats: {
      payload: Prisma.$UserStatsPayload<ExtArgs>
      fields: Prisma.UserStatsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserStatsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserStatsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload>
        }
        findFirst: {
          args: Prisma.UserStatsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserStatsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload>
        }
        findMany: {
          args: Prisma.UserStatsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
        }
        create: {
          args: Prisma.UserStatsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload>
        }
        createMany: {
          args: Prisma.UserStatsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserStatsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
        }
        delete: {
          args: Prisma.UserStatsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload>
        }
        update: {
          args: Prisma.UserStatsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload>
        }
        deleteMany: {
          args: Prisma.UserStatsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserStatsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserStatsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload>[]
        }
        upsert: {
          args: Prisma.UserStatsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserStatsPayload>
        }
        aggregate: {
          args: Prisma.UserStatsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserStats>
        }
        groupBy: {
          args: Prisma.UserStatsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserStatsGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserStatsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserStatsCountAggregateOutputType> | number
        }
      }
    }
    UserSocialLink: {
      payload: Prisma.$UserSocialLinkPayload<ExtArgs>
      fields: Prisma.UserSocialLinkFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserSocialLinkFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserSocialLinkFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
        }
        findFirst: {
          args: Prisma.UserSocialLinkFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserSocialLinkFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
        }
        findMany: {
          args: Prisma.UserSocialLinkFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>[]
        }
        create: {
          args: Prisma.UserSocialLinkCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
        }
        createMany: {
          args: Prisma.UserSocialLinkCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserSocialLinkCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>[]
        }
        delete: {
          args: Prisma.UserSocialLinkDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
        }
        update: {
          args: Prisma.UserSocialLinkUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
        }
        deleteMany: {
          args: Prisma.UserSocialLinkDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserSocialLinkUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserSocialLinkUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>[]
        }
        upsert: {
          args: Prisma.UserSocialLinkUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSocialLinkPayload>
        }
        aggregate: {
          args: Prisma.UserSocialLinkAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserSocialLink>
        }
        groupBy: {
          args: Prisma.UserSocialLinkGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSocialLinkGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserSocialLinkCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSocialLinkCountAggregateOutputType> | number
        }
      }
    }
    UserCategoryLevel: {
      payload: Prisma.$UserCategoryLevelPayload<ExtArgs>
      fields: Prisma.UserCategoryLevelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserCategoryLevelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserCategoryLevelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload>
        }
        findFirst: {
          args: Prisma.UserCategoryLevelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserCategoryLevelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload>
        }
        findMany: {
          args: Prisma.UserCategoryLevelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload>[]
        }
        create: {
          args: Prisma.UserCategoryLevelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload>
        }
        createMany: {
          args: Prisma.UserCategoryLevelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCategoryLevelCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload>[]
        }
        delete: {
          args: Prisma.UserCategoryLevelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload>
        }
        update: {
          args: Prisma.UserCategoryLevelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload>
        }
        deleteMany: {
          args: Prisma.UserCategoryLevelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserCategoryLevelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserCategoryLevelUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload>[]
        }
        upsert: {
          args: Prisma.UserCategoryLevelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserCategoryLevelPayload>
        }
        aggregate: {
          args: Prisma.UserCategoryLevelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserCategoryLevel>
        }
        groupBy: {
          args: Prisma.UserCategoryLevelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCategoryLevelGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCategoryLevelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCategoryLevelCountAggregateOutputType> | number
        }
      }
    }
    UserAvailability: {
      payload: Prisma.$UserAvailabilityPayload<ExtArgs>
      fields: Prisma.UserAvailabilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserAvailabilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserAvailabilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
        }
        findFirst: {
          args: Prisma.UserAvailabilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserAvailabilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
        }
        findMany: {
          args: Prisma.UserAvailabilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>[]
        }
        create: {
          args: Prisma.UserAvailabilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
        }
        createMany: {
          args: Prisma.UserAvailabilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserAvailabilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>[]
        }
        delete: {
          args: Prisma.UserAvailabilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
        }
        update: {
          args: Prisma.UserAvailabilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
        }
        deleteMany: {
          args: Prisma.UserAvailabilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserAvailabilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserAvailabilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>[]
        }
        upsert: {
          args: Prisma.UserAvailabilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAvailabilityPayload>
        }
        aggregate: {
          args: Prisma.UserAvailabilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserAvailability>
        }
        groupBy: {
          args: Prisma.UserAvailabilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserAvailabilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserAvailabilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserAvailabilityCountAggregateOutputType> | number
        }
      }
    }
    UserBadge: {
      payload: Prisma.$UserBadgePayload<ExtArgs>
      fields: Prisma.UserBadgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        findFirst: {
          args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        findMany: {
          args: Prisma.UserBadgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
        }
        create: {
          args: Prisma.UserBadgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        createMany: {
          args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
        }
        delete: {
          args: Prisma.UserBadgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        update: {
          args: Prisma.UserBadgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        deleteMany: {
          args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserBadgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
        }
        upsert: {
          args: Prisma.UserBadgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        aggregate: {
          args: Prisma.UserBadgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserBadge>
        }
        groupBy: {
          args: Prisma.UserBadgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserBadgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserBadgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserBadgeCountAggregateOutputType> | number
        }
      }
    }
    EventJoinQuestion: {
      payload: Prisma.$EventJoinQuestionPayload<ExtArgs>
      fields: Prisma.EventJoinQuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventJoinQuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventJoinQuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload>
        }
        findFirst: {
          args: Prisma.EventJoinQuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventJoinQuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload>
        }
        findMany: {
          args: Prisma.EventJoinQuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload>[]
        }
        create: {
          args: Prisma.EventJoinQuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload>
        }
        createMany: {
          args: Prisma.EventJoinQuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventJoinQuestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload>[]
        }
        delete: {
          args: Prisma.EventJoinQuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload>
        }
        update: {
          args: Prisma.EventJoinQuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload>
        }
        deleteMany: {
          args: Prisma.EventJoinQuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventJoinQuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventJoinQuestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload>[]
        }
        upsert: {
          args: Prisma.EventJoinQuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinQuestionPayload>
        }
        aggregate: {
          args: Prisma.EventJoinQuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventJoinQuestion>
        }
        groupBy: {
          args: Prisma.EventJoinQuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventJoinQuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventJoinQuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventJoinQuestionCountAggregateOutputType> | number
        }
      }
    }
    EventJoinAnswer: {
      payload: Prisma.$EventJoinAnswerPayload<ExtArgs>
      fields: Prisma.EventJoinAnswerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventJoinAnswerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventJoinAnswerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload>
        }
        findFirst: {
          args: Prisma.EventJoinAnswerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventJoinAnswerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload>
        }
        findMany: {
          args: Prisma.EventJoinAnswerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload>[]
        }
        create: {
          args: Prisma.EventJoinAnswerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload>
        }
        createMany: {
          args: Prisma.EventJoinAnswerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventJoinAnswerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload>[]
        }
        delete: {
          args: Prisma.EventJoinAnswerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload>
        }
        update: {
          args: Prisma.EventJoinAnswerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload>
        }
        deleteMany: {
          args: Prisma.EventJoinAnswerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventJoinAnswerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventJoinAnswerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload>[]
        }
        upsert: {
          args: Prisma.EventJoinAnswerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventJoinAnswerPayload>
        }
        aggregate: {
          args: Prisma.EventJoinAnswerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventJoinAnswer>
        }
        groupBy: {
          args: Prisma.EventJoinAnswerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventJoinAnswerGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventJoinAnswerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventJoinAnswerCountAggregateOutputType> | number
        }
      }
    }
    EventFeedbackQuestion: {
      payload: Prisma.$EventFeedbackQuestionPayload<ExtArgs>
      fields: Prisma.EventFeedbackQuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventFeedbackQuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventFeedbackQuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload>
        }
        findFirst: {
          args: Prisma.EventFeedbackQuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventFeedbackQuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload>
        }
        findMany: {
          args: Prisma.EventFeedbackQuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload>[]
        }
        create: {
          args: Prisma.EventFeedbackQuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload>
        }
        createMany: {
          args: Prisma.EventFeedbackQuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventFeedbackQuestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload>[]
        }
        delete: {
          args: Prisma.EventFeedbackQuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload>
        }
        update: {
          args: Prisma.EventFeedbackQuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload>
        }
        deleteMany: {
          args: Prisma.EventFeedbackQuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventFeedbackQuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventFeedbackQuestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload>[]
        }
        upsert: {
          args: Prisma.EventFeedbackQuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackQuestionPayload>
        }
        aggregate: {
          args: Prisma.EventFeedbackQuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventFeedbackQuestion>
        }
        groupBy: {
          args: Prisma.EventFeedbackQuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventFeedbackQuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventFeedbackQuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventFeedbackQuestionCountAggregateOutputType> | number
        }
      }
    }
    EventFeedbackAnswer: {
      payload: Prisma.$EventFeedbackAnswerPayload<ExtArgs>
      fields: Prisma.EventFeedbackAnswerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventFeedbackAnswerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventFeedbackAnswerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload>
        }
        findFirst: {
          args: Prisma.EventFeedbackAnswerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventFeedbackAnswerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload>
        }
        findMany: {
          args: Prisma.EventFeedbackAnswerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload>[]
        }
        create: {
          args: Prisma.EventFeedbackAnswerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload>
        }
        createMany: {
          args: Prisma.EventFeedbackAnswerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventFeedbackAnswerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload>[]
        }
        delete: {
          args: Prisma.EventFeedbackAnswerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload>
        }
        update: {
          args: Prisma.EventFeedbackAnswerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload>
        }
        deleteMany: {
          args: Prisma.EventFeedbackAnswerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventFeedbackAnswerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventFeedbackAnswerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload>[]
        }
        upsert: {
          args: Prisma.EventFeedbackAnswerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFeedbackAnswerPayload>
        }
        aggregate: {
          args: Prisma.EventFeedbackAnswerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventFeedbackAnswer>
        }
        groupBy: {
          args: Prisma.EventFeedbackAnswerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventFeedbackAnswerGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventFeedbackAnswerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventFeedbackAnswerCountAggregateOutputType> | number
        }
      }
    }
    EventFaq: {
      payload: Prisma.$EventFaqPayload<ExtArgs>
      fields: Prisma.EventFaqFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventFaqFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventFaqFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload>
        }
        findFirst: {
          args: Prisma.EventFaqFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventFaqFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload>
        }
        findMany: {
          args: Prisma.EventFaqFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload>[]
        }
        create: {
          args: Prisma.EventFaqCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload>
        }
        createMany: {
          args: Prisma.EventFaqCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventFaqCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload>[]
        }
        delete: {
          args: Prisma.EventFaqDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload>
        }
        update: {
          args: Prisma.EventFaqUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload>
        }
        deleteMany: {
          args: Prisma.EventFaqDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventFaqUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventFaqUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload>[]
        }
        upsert: {
          args: Prisma.EventFaqUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventFaqPayload>
        }
        aggregate: {
          args: Prisma.EventFaqAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventFaq>
        }
        groupBy: {
          args: Prisma.EventFaqGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventFaqGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventFaqCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventFaqCountAggregateOutputType> | number
        }
      }
    }
    MediaAsset: {
      payload: Prisma.$MediaAssetPayload<ExtArgs>
      fields: Prisma.MediaAssetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MediaAssetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MediaAssetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        findFirst: {
          args: Prisma.MediaAssetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MediaAssetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        findMany: {
          args: Prisma.MediaAssetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
        }
        create: {
          args: Prisma.MediaAssetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        createMany: {
          args: Prisma.MediaAssetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MediaAssetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
        }
        delete: {
          args: Prisma.MediaAssetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        update: {
          args: Prisma.MediaAssetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        deleteMany: {
          args: Prisma.MediaAssetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MediaAssetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MediaAssetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>[]
        }
        upsert: {
          args: Prisma.MediaAssetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaAssetPayload>
        }
        aggregate: {
          args: Prisma.MediaAssetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMediaAsset>
        }
        groupBy: {
          args: Prisma.MediaAssetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaAssetGroupByOutputType>[]
        }
        count: {
          args: Prisma.MediaAssetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaAssetCountAggregateOutputType> | number
        }
      }
    }
    EventAppearance: {
      payload: Prisma.$EventAppearancePayload<ExtArgs>
      fields: Prisma.EventAppearanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventAppearanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventAppearanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload>
        }
        findFirst: {
          args: Prisma.EventAppearanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventAppearanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload>
        }
        findMany: {
          args: Prisma.EventAppearanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload>[]
        }
        create: {
          args: Prisma.EventAppearanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload>
        }
        createMany: {
          args: Prisma.EventAppearanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventAppearanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload>[]
        }
        delete: {
          args: Prisma.EventAppearanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload>
        }
        update: {
          args: Prisma.EventAppearanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload>
        }
        deleteMany: {
          args: Prisma.EventAppearanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventAppearanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventAppearanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload>[]
        }
        upsert: {
          args: Prisma.EventAppearanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAppearancePayload>
        }
        aggregate: {
          args: Prisma.EventAppearanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventAppearance>
        }
        groupBy: {
          args: Prisma.EventAppearanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAppearanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventAppearanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAppearanceCountAggregateOutputType> | number
        }
      }
    }
    EventAgendaItem: {
      payload: Prisma.$EventAgendaItemPayload<ExtArgs>
      fields: Prisma.EventAgendaItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventAgendaItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventAgendaItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload>
        }
        findFirst: {
          args: Prisma.EventAgendaItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventAgendaItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload>
        }
        findMany: {
          args: Prisma.EventAgendaItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload>[]
        }
        create: {
          args: Prisma.EventAgendaItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload>
        }
        createMany: {
          args: Prisma.EventAgendaItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventAgendaItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload>[]
        }
        delete: {
          args: Prisma.EventAgendaItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload>
        }
        update: {
          args: Prisma.EventAgendaItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload>
        }
        deleteMany: {
          args: Prisma.EventAgendaItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventAgendaItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventAgendaItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload>[]
        }
        upsert: {
          args: Prisma.EventAgendaItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemPayload>
        }
        aggregate: {
          args: Prisma.EventAgendaItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventAgendaItem>
        }
        groupBy: {
          args: Prisma.EventAgendaItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAgendaItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventAgendaItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAgendaItemCountAggregateOutputType> | number
        }
      }
    }
    EventAgendaItemHost: {
      payload: Prisma.$EventAgendaItemHostPayload<ExtArgs>
      fields: Prisma.EventAgendaItemHostFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventAgendaItemHostFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventAgendaItemHostFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload>
        }
        findFirst: {
          args: Prisma.EventAgendaItemHostFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventAgendaItemHostFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload>
        }
        findMany: {
          args: Prisma.EventAgendaItemHostFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload>[]
        }
        create: {
          args: Prisma.EventAgendaItemHostCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload>
        }
        createMany: {
          args: Prisma.EventAgendaItemHostCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventAgendaItemHostCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload>[]
        }
        delete: {
          args: Prisma.EventAgendaItemHostDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload>
        }
        update: {
          args: Prisma.EventAgendaItemHostUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload>
        }
        deleteMany: {
          args: Prisma.EventAgendaItemHostDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventAgendaItemHostUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventAgendaItemHostUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload>[]
        }
        upsert: {
          args: Prisma.EventAgendaItemHostUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAgendaItemHostPayload>
        }
        aggregate: {
          args: Prisma.EventAgendaItemHostAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventAgendaItemHost>
        }
        groupBy: {
          args: Prisma.EventAgendaItemHostGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAgendaItemHostGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventAgendaItemHostCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAgendaItemHostCountAggregateOutputType> | number
        }
      }
    }
    EventCheckinLog: {
      payload: Prisma.$EventCheckinLogPayload<ExtArgs>
      fields: Prisma.EventCheckinLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventCheckinLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventCheckinLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload>
        }
        findFirst: {
          args: Prisma.EventCheckinLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventCheckinLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload>
        }
        findMany: {
          args: Prisma.EventCheckinLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload>[]
        }
        create: {
          args: Prisma.EventCheckinLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload>
        }
        createMany: {
          args: Prisma.EventCheckinLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventCheckinLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload>[]
        }
        delete: {
          args: Prisma.EventCheckinLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload>
        }
        update: {
          args: Prisma.EventCheckinLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload>
        }
        deleteMany: {
          args: Prisma.EventCheckinLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventCheckinLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventCheckinLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload>[]
        }
        upsert: {
          args: Prisma.EventCheckinLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckinLogPayload>
        }
        aggregate: {
          args: Prisma.EventCheckinLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventCheckinLog>
        }
        groupBy: {
          args: Prisma.EventCheckinLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventCheckinLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventCheckinLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventCheckinLogCountAggregateOutputType> | number
        }
      }
    }
    EventAuditLog: {
      payload: Prisma.$EventAuditLogPayload<ExtArgs>
      fields: Prisma.EventAuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventAuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventAuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload>
        }
        findFirst: {
          args: Prisma.EventAuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventAuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload>
        }
        findMany: {
          args: Prisma.EventAuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload>[]
        }
        create: {
          args: Prisma.EventAuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload>
        }
        createMany: {
          args: Prisma.EventAuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventAuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload>[]
        }
        delete: {
          args: Prisma.EventAuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload>
        }
        update: {
          args: Prisma.EventAuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload>
        }
        deleteMany: {
          args: Prisma.EventAuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventAuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventAuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload>[]
        }
        upsert: {
          args: Prisma.EventAuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventAuditLogPayload>
        }
        aggregate: {
          args: Prisma.EventAuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventAuditLog>
        }
        groupBy: {
          args: Prisma.EventAuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventAuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventAuditLogCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  avatarKey: 'avatarKey',
  role: 'role',
  verifiedAt: 'verifiedAt',
  suspendedAt: 'suspendedAt',
  suspensionReason: 'suspensionReason',
  deletedAt: 'deletedAt',
  deletedReason: 'deletedReason',
  restorationToken: 'restorationToken',
  restorationTokenExpiry: 'restorationTokenExpiry',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  lastSeenAt: 'lastSeenAt',
  locale: 'locale',
  timezone: 'timezone',
  acceptedTermsAt: 'acceptedTermsAt',
  acceptedMarketingAt: 'acceptedMarketingAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const CategoryScalarFieldEnum = {
  id: 'id',
  slug: 'slug',
  names: 'names',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


export const TagScalarFieldEnum = {
  id: 'id',
  label: 'label',
  slug: 'slug',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


export const EventScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  notes: 'notes',
  visibility: 'visibility',
  joinMode: 'joinMode',
  mode: 'mode',
  min: 'min',
  max: 'max',
  startAt: 'startAt',
  endAt: 'endAt',
  joinOpensMinutesBeforeStart: 'joinOpensMinutesBeforeStart',
  joinCutoffMinutesBeforeStart: 'joinCutoffMinutesBeforeStart',
  allowJoinLate: 'allowJoinLate',
  lateJoinCutoffMinutesAfterStart: 'lateJoinCutoffMinutesAfterStart',
  joinManuallyClosed: 'joinManuallyClosed',
  joinManuallyClosedAt: 'joinManuallyClosedAt',
  joinManuallyClosedById: 'joinManuallyClosedById',
  joinManualCloseReason: 'joinManualCloseReason',
  meetingKind: 'meetingKind',
  onlineUrl: 'onlineUrl',
  lat: 'lat',
  lng: 'lng',
  address: 'address',
  placeId: 'placeId',
  radiusKm: 'radiusKm',
  cityName: 'cityName',
  cityPlaceId: 'cityPlaceId',
  levels: 'levels',
  coverKey: 'coverKey',
  addressVisibility: 'addressVisibility',
  membersVisibility: 'membersVisibility',
  joinedCount: 'joinedCount',
  commentsCount: 'commentsCount',
  messagesCount: 'messagesCount',
  savedCount: 'savedCount',
  sponsorshipPlan: 'sponsorshipPlan',
  boostedAt: 'boostedAt',
  status: 'status',
  publishedAt: 'publishedAt',
  scheduledPublishAt: 'scheduledPublishAt',
  ownerId: 'ownerId',
  canceledAt: 'canceledAt',
  canceledById: 'canceledById',
  cancelReason: 'cancelReason',
  deletedAt: 'deletedAt',
  deletedById: 'deletedById',
  deleteReason: 'deleteReason',
  checkinEnabled: 'checkinEnabled',
  enabledCheckinMethods: 'enabledCheckinMethods',
  eventCheckinToken: 'eventCheckinToken',
  auditArchivedAt: 'auditArchivedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


export const EventMemberScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  userId: 'userId',
  role: 'role',
  status: 'status',
  addedById: 'addedById',
  joinedAt: 'joinedAt',
  leftAt: 'leftAt',
  note: 'note',
  rejectReason: 'rejectReason',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  isCheckedIn: 'isCheckedIn',
  checkinMethods: 'checkinMethods',
  lastCheckinAt: 'lastCheckinAt',
  memberCheckinToken: 'memberCheckinToken',
  checkinBlockedAll: 'checkinBlockedAll',
  checkinBlockedMethods: 'checkinBlockedMethods',
  lastCheckinRejectionReason: 'lastCheckinRejectionReason',
  lastCheckinRejectedAt: 'lastCheckinRejectedAt',
  lastCheckinRejectedById: 'lastCheckinRejectedById'
} as const

export type EventMemberScalarFieldEnum = (typeof EventMemberScalarFieldEnum)[keyof typeof EventMemberScalarFieldEnum]


export const EventMemberEventScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  userId: 'userId',
  actorId: 'actorId',
  kind: 'kind',
  note: 'note',
  createdAt: 'createdAt'
} as const

export type EventMemberEventScalarFieldEnum = (typeof EventMemberEventScalarFieldEnum)[keyof typeof EventMemberEventScalarFieldEnum]


export const CommentScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  authorId: 'authorId',
  threadId: 'threadId',
  parentId: 'parentId',
  content: 'content',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  deletedById: 'deletedById',
  hiddenAt: 'hiddenAt',
  hiddenById: 'hiddenById'
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


export const ReviewScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  authorId: 'authorId',
  rating: 'rating',
  content: 'content',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  deletedAt: 'deletedAt',
  deletedById: 'deletedById',
  hiddenAt: 'hiddenAt',
  hiddenById: 'hiddenById'
} as const

export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


export const DmThreadScalarFieldEnum = {
  id: 'id',
  aUserId: 'aUserId',
  bUserId: 'bUserId',
  pairKey: 'pairKey',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  lastMessageAt: 'lastMessageAt'
} as const

export type DmThreadScalarFieldEnum = (typeof DmThreadScalarFieldEnum)[keyof typeof DmThreadScalarFieldEnum]


export const DmMessageScalarFieldEnum = {
  id: 'id',
  threadId: 'threadId',
  senderId: 'senderId',
  content: 'content',
  replyToId: 'replyToId',
  createdAt: 'createdAt',
  readAt: 'readAt',
  editedAt: 'editedAt',
  deletedAt: 'deletedAt'
} as const

export type DmMessageScalarFieldEnum = (typeof DmMessageScalarFieldEnum)[keyof typeof DmMessageScalarFieldEnum]


export const DmMessageReactionScalarFieldEnum = {
  id: 'id',
  messageId: 'messageId',
  userId: 'userId',
  emoji: 'emoji',
  createdAt: 'createdAt'
} as const

export type DmMessageReactionScalarFieldEnum = (typeof DmMessageReactionScalarFieldEnum)[keyof typeof DmMessageReactionScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  kind: 'kind',
  recipientId: 'recipientId',
  actorId: 'actorId',
  entityType: 'entityType',
  entityId: 'entityId',
  eventId: 'eventId',
  title: 'title',
  body: 'body',
  data: 'data',
  dedupeKey: 'dedupeKey',
  readAt: 'readAt',
  createdAt: 'createdAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const EventChatMessageScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  authorId: 'authorId',
  content: 'content',
  replyToId: 'replyToId',
  createdAt: 'createdAt',
  editedAt: 'editedAt',
  deletedAt: 'deletedAt'
} as const

export type EventChatMessageScalarFieldEnum = (typeof EventChatMessageScalarFieldEnum)[keyof typeof EventChatMessageScalarFieldEnum]


export const EventChatMessageReactionScalarFieldEnum = {
  id: 'id',
  messageId: 'messageId',
  userId: 'userId',
  emoji: 'emoji',
  createdAt: 'createdAt'
} as const

export type EventChatMessageReactionScalarFieldEnum = (typeof EventChatMessageReactionScalarFieldEnum)[keyof typeof EventChatMessageReactionScalarFieldEnum]


export const EventChatReadScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  userId: 'userId',
  lastReadAt: 'lastReadAt'
} as const

export type EventChatReadScalarFieldEnum = (typeof EventChatReadScalarFieldEnum)[keyof typeof EventChatReadScalarFieldEnum]


export const DmReadScalarFieldEnum = {
  id: 'id',
  threadId: 'threadId',
  userId: 'userId',
  lastReadAt: 'lastReadAt'
} as const

export type DmReadScalarFieldEnum = (typeof DmReadScalarFieldEnum)[keyof typeof DmReadScalarFieldEnum]


export const UserBlockScalarFieldEnum = {
  id: 'id',
  blockerId: 'blockerId',
  blockedId: 'blockedId',
  createdAt: 'createdAt'
} as const

export type UserBlockScalarFieldEnum = (typeof UserBlockScalarFieldEnum)[keyof typeof UserBlockScalarFieldEnum]


export const ReportScalarFieldEnum = {
  id: 'id',
  reporterId: 'reporterId',
  entity: 'entity',
  entityId: 'entityId',
  reason: 'reason',
  status: 'status',
  createdAt: 'createdAt',
  resolvedAt: 'resolvedAt'
} as const

export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


export const UserSubscriptionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  plan: 'plan',
  billingPeriod: 'billingPeriod',
  status: 'status',
  stripeCustomerId: 'stripeCustomerId',
  stripeSubscriptionId: 'stripeSubscriptionId',
  stripePriceId: 'stripePriceId',
  currentPeriodStart: 'currentPeriodStart',
  currentPeriodEnd: 'currentPeriodEnd',
  trialEndsAt: 'trialEndsAt',
  cancelAtPeriodEnd: 'cancelAtPeriodEnd',
  canceledAt: 'canceledAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


export const UserPlanPeriodScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  plan: 'plan',
  source: 'source',
  billingPeriod: 'billingPeriod',
  amount: 'amount',
  currency: 'currency',
  stripeCustomerId: 'stripeCustomerId',
  stripeSubscriptionId: 'stripeSubscriptionId',
  stripePaymentEventId: 'stripePaymentEventId',
  stripeCheckoutSessionId: 'stripeCheckoutSessionId',
  startsAt: 'startsAt',
  endsAt: 'endsAt',
  createdAt: 'createdAt'
} as const

export type UserPlanPeriodScalarFieldEnum = (typeof UserPlanPeriodScalarFieldEnum)[keyof typeof UserPlanPeriodScalarFieldEnum]


export const EventSponsorshipScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  sponsorId: 'sponsorId',
  plan: 'plan',
  status: 'status',
  startsAt: 'startsAt',
  endsAt: 'endsAt',
  boostsTotal: 'boostsTotal',
  boostsUsed: 'boostsUsed',
  localPushesTotal: 'localPushesTotal',
  localPushesUsed: 'localPushesUsed',
  stripePaymentEventId: 'stripePaymentEventId',
  stripeCheckoutSessionId: 'stripeCheckoutSessionId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventSponsorshipScalarFieldEnum = (typeof EventSponsorshipScalarFieldEnum)[keyof typeof EventSponsorshipScalarFieldEnum]


export const EventSponsorshipPeriodScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  sponsorId: 'sponsorId',
  plan: 'plan',
  actionType: 'actionType',
  boostsAdded: 'boostsAdded',
  localPushesAdded: 'localPushesAdded',
  amount: 'amount',
  currency: 'currency',
  stripeCustomerId: 'stripeCustomerId',
  stripePaymentEventId: 'stripePaymentEventId',
  stripeCheckoutSessionId: 'stripeCheckoutSessionId',
  createdAt: 'createdAt'
} as const

export type EventSponsorshipPeriodScalarFieldEnum = (typeof EventSponsorshipPeriodScalarFieldEnum)[keyof typeof EventSponsorshipPeriodScalarFieldEnum]


export const PaymentEventScalarFieldEnum = {
  id: 'id',
  provider: 'provider',
  eventId: 'eventId',
  type: 'type',
  payload: 'payload',
  receivedAt: 'receivedAt',
  processedAt: 'processedAt',
  success: 'success',
  attempt: 'attempt',
  lastError: 'lastError'
} as const

export type PaymentEventScalarFieldEnum = (typeof PaymentEventScalarFieldEnum)[keyof typeof PaymentEventScalarFieldEnum]


export const EventInviteLinkScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  code: 'code',
  maxUses: 'maxUses',
  usedCount: 'usedCount',
  expiresAt: 'expiresAt',
  createdById: 'createdById',
  label: 'label',
  revokedAt: 'revokedAt',
  revokedById: 'revokedById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventInviteLinkScalarFieldEnum = (typeof EventInviteLinkScalarFieldEnum)[keyof typeof EventInviteLinkScalarFieldEnum]


export const EventInviteLinkUsageScalarFieldEnum = {
  id: 'id',
  linkId: 'linkId',
  userId: 'userId',
  usedAt: 'usedAt',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent'
} as const

export type EventInviteLinkUsageScalarFieldEnum = (typeof EventInviteLinkUsageScalarFieldEnum)[keyof typeof EventInviteLinkUsageScalarFieldEnum]


export const EventFavouriteScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  eventId: 'eventId',
  createdAt: 'createdAt'
} as const

export type EventFavouriteScalarFieldEnum = (typeof EventFavouriteScalarFieldEnum)[keyof typeof EventFavouriteScalarFieldEnum]


export const NotificationPreferenceScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  emailOnInvite: 'emailOnInvite',
  emailOnJoinRequest: 'emailOnJoinRequest',
  emailOnMessage: 'emailOnMessage',
  pushOnReminder: 'pushOnReminder',
  inAppOnEverything: 'inAppOnEverything',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NotificationPreferenceScalarFieldEnum = (typeof NotificationPreferenceScalarFieldEnum)[keyof typeof NotificationPreferenceScalarFieldEnum]


export const EventMuteScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  userId: 'userId',
  muted: 'muted',
  createdAt: 'createdAt'
} as const

export type EventMuteScalarFieldEnum = (typeof EventMuteScalarFieldEnum)[keyof typeof EventMuteScalarFieldEnum]


export const DmMuteScalarFieldEnum = {
  id: 'id',
  threadId: 'threadId',
  userId: 'userId',
  muted: 'muted',
  createdAt: 'createdAt'
} as const

export type DmMuteScalarFieldEnum = (typeof DmMuteScalarFieldEnum)[keyof typeof DmMuteScalarFieldEnum]


export const EventOwnershipTransferScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  fromUserId: 'fromUserId',
  toUserId: 'toUserId',
  actorId: 'actorId',
  reason: 'reason',
  createdAt: 'createdAt'
} as const

export type EventOwnershipTransferScalarFieldEnum = (typeof EventOwnershipTransferScalarFieldEnum)[keyof typeof EventOwnershipTransferScalarFieldEnum]


export const UserProfileScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  displayName: 'displayName',
  bioShort: 'bioShort',
  bioLong: 'bioLong',
  city: 'city',
  country: 'country',
  homeLat: 'homeLat',
  homeLng: 'homeLng',
  coverKey: 'coverKey',
  speaks: 'speaks',
  interests: 'interests',
  preferredMode: 'preferredMode',
  preferredMaxDistanceKm: 'preferredMaxDistanceKm'
} as const

export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


export const UserPrivacyScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  dmPolicy: 'dmPolicy',
  showLastSeen: 'showLastSeen',
  showLocation: 'showLocation',
  showEvents: 'showEvents',
  showReviews: 'showReviews',
  showStats: 'showStats',
  defaultAddressVisibility: 'defaultAddressVisibility',
  defaultMembersVisibility: 'defaultMembersVisibility'
} as const

export type UserPrivacyScalarFieldEnum = (typeof UserPrivacyScalarFieldEnum)[keyof typeof UserPrivacyScalarFieldEnum]


export const UserStatsScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  eventsCreated: 'eventsCreated',
  eventsJoined: 'eventsJoined',
  reviewsCount: 'reviewsCount',
  hostRatingAvg: 'hostRatingAvg',
  attendeeRatingAvg: 'attendeeRatingAvg',
  lastActiveAt: 'lastActiveAt'
} as const

export type UserStatsScalarFieldEnum = (typeof UserStatsScalarFieldEnum)[keyof typeof UserStatsScalarFieldEnum]


export const UserSocialLinkScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  provider: 'provider',
  url: 'url',
  verified: 'verified'
} as const

export type UserSocialLinkScalarFieldEnum = (typeof UserSocialLinkScalarFieldEnum)[keyof typeof UserSocialLinkScalarFieldEnum]


export const UserCategoryLevelScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId',
  level: 'level',
  notes: 'notes'
} as const

export type UserCategoryLevelScalarFieldEnum = (typeof UserCategoryLevelScalarFieldEnum)[keyof typeof UserCategoryLevelScalarFieldEnum]


export const UserAvailabilityScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  weekday: 'weekday',
  startMin: 'startMin',
  endMin: 'endMin',
  tzSnap: 'tzSnap'
} as const

export type UserAvailabilityScalarFieldEnum = (typeof UserAvailabilityScalarFieldEnum)[keyof typeof UserAvailabilityScalarFieldEnum]


export const UserBadgeScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  createdAt: 'createdAt',
  slug: 'slug',
  data: 'data',
  earnedAt: 'earnedAt'
} as const

export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


export const EventJoinQuestionScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  order: 'order',
  type: 'type',
  label: 'label',
  helpText: 'helpText',
  required: 'required',
  options: 'options',
  maxLength: 'maxLength',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventJoinQuestionScalarFieldEnum = (typeof EventJoinQuestionScalarFieldEnum)[keyof typeof EventJoinQuestionScalarFieldEnum]


export const EventJoinAnswerScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  userId: 'userId',
  questionId: 'questionId',
  answer: 'answer',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventJoinAnswerScalarFieldEnum = (typeof EventJoinAnswerScalarFieldEnum)[keyof typeof EventJoinAnswerScalarFieldEnum]


export const EventFeedbackQuestionScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  order: 'order',
  type: 'type',
  label: 'label',
  helpText: 'helpText',
  required: 'required',
  options: 'options',
  maxLength: 'maxLength',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventFeedbackQuestionScalarFieldEnum = (typeof EventFeedbackQuestionScalarFieldEnum)[keyof typeof EventFeedbackQuestionScalarFieldEnum]


export const EventFeedbackAnswerScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  userId: 'userId',
  questionId: 'questionId',
  answer: 'answer',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventFeedbackAnswerScalarFieldEnum = (typeof EventFeedbackAnswerScalarFieldEnum)[keyof typeof EventFeedbackAnswerScalarFieldEnum]


export const EventFaqScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  order: 'order',
  question: 'question',
  answer: 'answer',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventFaqScalarFieldEnum = (typeof EventFaqScalarFieldEnum)[keyof typeof EventFaqScalarFieldEnum]


export const MediaAssetScalarFieldEnum = {
  id: 'id',
  key: 'key',
  blurhash: 'blurhash',
  width: 'width',
  height: 'height',
  mimeType: 'mimeType',
  ownerId: 'ownerId',
  purpose: 'purpose',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MediaAssetScalarFieldEnum = (typeof MediaAssetScalarFieldEnum)[keyof typeof MediaAssetScalarFieldEnum]


export const EventAppearanceScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  config: 'config',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventAppearanceScalarFieldEnum = (typeof EventAppearanceScalarFieldEnum)[keyof typeof EventAppearanceScalarFieldEnum]


export const EventAgendaItemScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  order: 'order',
  title: 'title',
  description: 'description',
  startAt: 'startAt',
  endAt: 'endAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventAgendaItemScalarFieldEnum = (typeof EventAgendaItemScalarFieldEnum)[keyof typeof EventAgendaItemScalarFieldEnum]


export const EventAgendaItemHostScalarFieldEnum = {
  id: 'id',
  agendaItemId: 'agendaItemId',
  order: 'order',
  kind: 'kind',
  userId: 'userId',
  name: 'name',
  avatarUrl: 'avatarUrl',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventAgendaItemHostScalarFieldEnum = (typeof EventAgendaItemHostScalarFieldEnum)[keyof typeof EventAgendaItemHostScalarFieldEnum]


export const EventCheckinLogScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  memberId: 'memberId',
  actorId: 'actorId',
  action: 'action',
  method: 'method',
  source: 'source',
  result: 'result',
  reason: 'reason',
  comment: 'comment',
  showCommentToUser: 'showCommentToUser',
  metadata: 'metadata',
  createdAt: 'createdAt',
  eventMemberId: 'eventMemberId'
} as const

export type EventCheckinLogScalarFieldEnum = (typeof EventCheckinLogScalarFieldEnum)[keyof typeof EventCheckinLogScalarFieldEnum]


export const EventAuditLogScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  scope: 'scope',
  action: 'action',
  entityType: 'entityType',
  entityId: 'entityId',
  actorType: 'actorType',
  actorId: 'actorId',
  actorRole: 'actorRole',
  diff: 'diff',
  meta: 'meta',
  severity: 'severity',
  createdAt: 'createdAt'
} as const

export type EventAuditLogScalarFieldEnum = (typeof EventAuditLogScalarFieldEnum)[keyof typeof EventAuditLogScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Role'
 */
export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


/**
 * Reference to a field of type 'Role[]'
 */
export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'Visibility'
 */
export type EnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility'>
    


/**
 * Reference to a field of type 'Visibility[]'
 */
export type ListEnumVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Visibility[]'>
    


/**
 * Reference to a field of type 'JoinMode'
 */
export type EnumJoinModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JoinMode'>
    


/**
 * Reference to a field of type 'JoinMode[]'
 */
export type ListEnumJoinModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JoinMode[]'>
    


/**
 * Reference to a field of type 'Mode'
 */
export type EnumModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Mode'>
    


/**
 * Reference to a field of type 'Mode[]'
 */
export type ListEnumModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Mode[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'MeetingKind'
 */
export type EnumMeetingKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingKind'>
    


/**
 * Reference to a field of type 'MeetingKind[]'
 */
export type ListEnumMeetingKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingKind[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'Level[]'
 */
export type ListEnumLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Level[]'>
    


/**
 * Reference to a field of type 'Level'
 */
export type EnumLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Level'>
    


/**
 * Reference to a field of type 'AddressVisibility'
 */
export type EnumAddressVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressVisibility'>
    


/**
 * Reference to a field of type 'AddressVisibility[]'
 */
export type ListEnumAddressVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressVisibility[]'>
    


/**
 * Reference to a field of type 'MembersVisibility'
 */
export type EnumMembersVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembersVisibility'>
    


/**
 * Reference to a field of type 'MembersVisibility[]'
 */
export type ListEnumMembersVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MembersVisibility[]'>
    


/**
 * Reference to a field of type 'EventPlan'
 */
export type EnumEventPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventPlan'>
    


/**
 * Reference to a field of type 'EventPlan[]'
 */
export type ListEnumEventPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventPlan[]'>
    


/**
 * Reference to a field of type 'PublicationStatus'
 */
export type EnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus'>
    


/**
 * Reference to a field of type 'PublicationStatus[]'
 */
export type ListEnumPublicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublicationStatus[]'>
    


/**
 * Reference to a field of type 'CheckinMethod[]'
 */
export type ListEnumCheckinMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckinMethod[]'>
    


/**
 * Reference to a field of type 'CheckinMethod'
 */
export type EnumCheckinMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckinMethod'>
    


/**
 * Reference to a field of type 'EventMemberRole'
 */
export type EnumEventMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventMemberRole'>
    


/**
 * Reference to a field of type 'EventMemberRole[]'
 */
export type ListEnumEventMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventMemberRole[]'>
    


/**
 * Reference to a field of type 'EventMemberStatus'
 */
export type EnumEventMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventMemberStatus'>
    


/**
 * Reference to a field of type 'EventMemberStatus[]'
 */
export type ListEnumEventMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventMemberStatus[]'>
    


/**
 * Reference to a field of type 'MemberEvent'
 */
export type EnumMemberEventFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberEvent'>
    


/**
 * Reference to a field of type 'MemberEvent[]'
 */
export type ListEnumMemberEventFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberEvent[]'>
    


/**
 * Reference to a field of type 'NotificationKind'
 */
export type EnumNotificationKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationKind'>
    


/**
 * Reference to a field of type 'NotificationKind[]'
 */
export type ListEnumNotificationKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationKind[]'>
    


/**
 * Reference to a field of type 'NotificationEntity'
 */
export type EnumNotificationEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationEntity'>
    


/**
 * Reference to a field of type 'NotificationEntity[]'
 */
export type ListEnumNotificationEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationEntity[]'>
    


/**
 * Reference to a field of type 'ReportEntity'
 */
export type EnumReportEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportEntity'>
    


/**
 * Reference to a field of type 'ReportEntity[]'
 */
export type ListEnumReportEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportEntity[]'>
    


/**
 * Reference to a field of type 'SubscriptionPlan'
 */
export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


/**
 * Reference to a field of type 'SubscriptionPlan[]'
 */
export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


/**
 * Reference to a field of type 'BillingPeriod'
 */
export type EnumBillingPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingPeriod'>
    


/**
 * Reference to a field of type 'BillingPeriod[]'
 */
export type ListEnumBillingPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingPeriod[]'>
    


/**
 * Reference to a field of type 'SubscriptionStatus'
 */
export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


/**
 * Reference to a field of type 'SubscriptionStatus[]'
 */
export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


/**
 * Reference to a field of type 'UserPlanSource'
 */
export type EnumUserPlanSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserPlanSource'>
    


/**
 * Reference to a field of type 'UserPlanSource[]'
 */
export type ListEnumUserPlanSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserPlanSource[]'>
    


/**
 * Reference to a field of type 'SponsorshipStatus'
 */
export type EnumSponsorshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SponsorshipStatus'>
    


/**
 * Reference to a field of type 'SponsorshipStatus[]'
 */
export type ListEnumSponsorshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SponsorshipStatus[]'>
    


/**
 * Reference to a field of type 'JoinQuestionType'
 */
export type EnumJoinQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JoinQuestionType'>
    


/**
 * Reference to a field of type 'JoinQuestionType[]'
 */
export type ListEnumJoinQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JoinQuestionType[]'>
    


/**
 * Reference to a field of type 'FeedbackQuestionType'
 */
export type EnumFeedbackQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackQuestionType'>
    


/**
 * Reference to a field of type 'FeedbackQuestionType[]'
 */
export type ListEnumFeedbackQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackQuestionType[]'>
    


/**
 * Reference to a field of type 'AgendaHostKind'
 */
export type EnumAgendaHostKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgendaHostKind'>
    


/**
 * Reference to a field of type 'AgendaHostKind[]'
 */
export type ListEnumAgendaHostKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgendaHostKind[]'>
    


/**
 * Reference to a field of type 'CheckinAction'
 */
export type EnumCheckinActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckinAction'>
    


/**
 * Reference to a field of type 'CheckinAction[]'
 */
export type ListEnumCheckinActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckinAction[]'>
    


/**
 * Reference to a field of type 'CheckinSource'
 */
export type EnumCheckinSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckinSource'>
    


/**
 * Reference to a field of type 'CheckinSource[]'
 */
export type ListEnumCheckinSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckinSource[]'>
    


/**
 * Reference to a field of type 'CheckinResult'
 */
export type EnumCheckinResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckinResult'>
    


/**
 * Reference to a field of type 'CheckinResult[]'
 */
export type ListEnumCheckinResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckinResult[]'>
    


/**
 * Reference to a field of type 'AuditScope'
 */
export type EnumAuditScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditScope'>
    


/**
 * Reference to a field of type 'AuditScope[]'
 */
export type ListEnumAuditScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditScope[]'>
    


/**
 * Reference to a field of type 'AuditAction'
 */
export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


/**
 * Reference to a field of type 'AuditAction[]'
 */
export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


/**
 * Reference to a field of type 'AuditActorType'
 */
export type EnumAuditActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditActorType'>
    


/**
 * Reference to a field of type 'AuditActorType[]'
 */
export type ListEnumAuditActorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditActorType[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  category?: Prisma.CategoryOmit
  tag?: Prisma.TagOmit
  event?: Prisma.EventOmit
  eventMember?: Prisma.EventMemberOmit
  eventMemberEvent?: Prisma.EventMemberEventOmit
  comment?: Prisma.CommentOmit
  review?: Prisma.ReviewOmit
  dmThread?: Prisma.DmThreadOmit
  dmMessage?: Prisma.DmMessageOmit
  dmMessageReaction?: Prisma.DmMessageReactionOmit
  notification?: Prisma.NotificationOmit
  eventChatMessage?: Prisma.EventChatMessageOmit
  eventChatMessageReaction?: Prisma.EventChatMessageReactionOmit
  eventChatRead?: Prisma.EventChatReadOmit
  dmRead?: Prisma.DmReadOmit
  userBlock?: Prisma.UserBlockOmit
  report?: Prisma.ReportOmit
  userSubscription?: Prisma.UserSubscriptionOmit
  userPlanPeriod?: Prisma.UserPlanPeriodOmit
  eventSponsorship?: Prisma.EventSponsorshipOmit
  eventSponsorshipPeriod?: Prisma.EventSponsorshipPeriodOmit
  paymentEvent?: Prisma.PaymentEventOmit
  eventInviteLink?: Prisma.EventInviteLinkOmit
  eventInviteLinkUsage?: Prisma.EventInviteLinkUsageOmit
  eventFavourite?: Prisma.EventFavouriteOmit
  notificationPreference?: Prisma.NotificationPreferenceOmit
  eventMute?: Prisma.EventMuteOmit
  dmMute?: Prisma.DmMuteOmit
  eventOwnershipTransfer?: Prisma.EventOwnershipTransferOmit
  userProfile?: Prisma.UserProfileOmit
  userPrivacy?: Prisma.UserPrivacyOmit
  userStats?: Prisma.UserStatsOmit
  userSocialLink?: Prisma.UserSocialLinkOmit
  userCategoryLevel?: Prisma.UserCategoryLevelOmit
  userAvailability?: Prisma.UserAvailabilityOmit
  userBadge?: Prisma.UserBadgeOmit
  eventJoinQuestion?: Prisma.EventJoinQuestionOmit
  eventJoinAnswer?: Prisma.EventJoinAnswerOmit
  eventFeedbackQuestion?: Prisma.EventFeedbackQuestionOmit
  eventFeedbackAnswer?: Prisma.EventFeedbackAnswerOmit
  eventFaq?: Prisma.EventFaqOmit
  mediaAsset?: Prisma.MediaAssetOmit
  eventAppearance?: Prisma.EventAppearanceOmit
  eventAgendaItem?: Prisma.EventAgendaItemOmit
  eventAgendaItemHost?: Prisma.EventAgendaItemHostOmit
  eventCheckinLog?: Prisma.EventCheckinLogOmit
  eventAuditLog?: Prisma.EventAuditLogOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

