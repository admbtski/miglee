# =============================================================================
# Web Dockerfile (Next.js 15 SSR) â€” standalone output
# pnpm + turborepo monorepo
# - turbo prune -> minimal workspace context
# - Next.js standalone output -> minimal runtime
# =============================================================================

# -----------------------------------------------------------------------------
# Base (pnpm)
# -----------------------------------------------------------------------------
FROM node:24-alpine AS base

RUN apk add --no-cache libc6-compat
RUN corepack enable && corepack prepare pnpm@10.27.0 --activate

ENV PNPM_HOME="/root/.local/share/pnpm"
ENV PATH="${PNPM_HOME}:${PATH}"

WORKDIR /app

# -----------------------------------------------------------------------------
# Pruner (turbo prune for minimal workspace)
# -----------------------------------------------------------------------------
FROM base AS pruner

RUN apk add --no-cache git

COPY package.json pnpm-lock.yaml pnpm-workspace.yaml turbo.json ./
COPY apps ./apps
COPY packages ./packages

# Create pruned output for @appname/web
RUN pnpm dlx turbo@2.5.8 prune @appname/web --docker

# -----------------------------------------------------------------------------
# Dependencies (install deps for pruned workspace)
# -----------------------------------------------------------------------------
FROM base AS deps

# Copy pruned manifests only
COPY --from=pruner /app/out/json/ ./
COPY --from=pruner /app/out/pnpm-lock.yaml ./pnpm-lock.yaml

RUN pnpm install --frozen-lockfile

# -----------------------------------------------------------------------------
# Development stage (with hot reload via webpack)
# -----------------------------------------------------------------------------
FROM base AS development

COPY --from=pruner /app/out/full/ ./
COPY --from=deps /app/node_modules ./node_modules
COPY --from=deps /app/apps/web/node_modules ./apps/web/node_modules
COPY --from=deps /app/pnpm-lock.yaml ./pnpm-lock.yaml

ENV NODE_ENV=development
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

EXPOSE 3000

# Use webpack instead of Turbopack for Docker compatibility
CMD ["pnpm", "-C", "apps/web", "_dev"]

# -----------------------------------------------------------------------------
# Builder (build Next.js with standalone output)
# -----------------------------------------------------------------------------
FROM base AS builder

# Build-time env vars (baked into client bundle)
ARG NEXT_PUBLIC_API_URL
ARG NEXT_PUBLIC_WS_URL
ARG NEXT_PUBLIC_GOOGLE_MAPS_API_KEY
ARG NEXT_PUBLIC_SITE_URL

ENV NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}
ENV NEXT_PUBLIC_WS_URL=${NEXT_PUBLIC_WS_URL}
ENV NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=${NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}
ENV NEXT_PUBLIC_SITE_URL=${NEXT_PUBLIC_SITE_URL}

COPY --from=pruner /app/out/full/ ./
COPY --from=deps /app/node_modules ./node_modules
COPY --from=deps /app/apps/web/node_modules ./apps/web/node_modules
COPY --from=deps /app/pnpm-lock.yaml ./pnpm-lock.yaml

# Build Next.js (outputs to apps/web/.next/standalone)
RUN pnpm -C apps/web build

# -----------------------------------------------------------------------------
# Production (minimal runtime, standalone output)
# -----------------------------------------------------------------------------
FROM node:24-alpine AS production

# Runtime deps + TLS certs + tini for proper signal handling
RUN apk add --no-cache libc6-compat ca-certificates tini && \
    update-ca-certificates

WORKDIR /app

# Non-root user
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nextjs

# Copy standalone output (includes node_modules subset + server.js)
COPY --from=builder --chown=nextjs:nodejs /app/apps/web/.next/standalone ./

# Copy static files (required for SSR)
COPY --from=builder --chown=nextjs:nodejs /app/apps/web/.next/static ./apps/web/.next/static

# Copy public assets
COPY --from=builder --chown=nextjs:nodejs /app/apps/web/public ./apps/web/public

USER nextjs

ENV NODE_ENV=production
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

EXPOSE 3000

# Use tini as init to properly handle signals and reap zombie processes
# K8s livenessProbe/readinessProbe handles health checks (no Docker HEALTHCHECK needed)
ENTRYPOINT ["tini", "--"]
CMD ["node", "apps/web/server.js"]
